// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: common/commands/base_commands.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_common_2fcommands_2fbase_5fcommands_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_common_2fcommands_2fbase_5fcommands_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "common/types/base_types.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_common_2fcommands_2fbase_5fcommands_2eproto KIAPI_IMPORTEXPORT
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct KIAPI_IMPORTEXPORT TableStruct_common_2fcommands_2fbase_5fcommands_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[12]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
KIAPI_IMPORTEXPORT extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_common_2fcommands_2fbase_5fcommands_2eproto;
namespace kiapi {
namespace common {
namespace commands {
class GetKiCadBinaryPath;
struct GetKiCadBinaryPathDefaultTypeInternal;
KIAPI_IMPORTEXPORT extern GetKiCadBinaryPathDefaultTypeInternal _GetKiCadBinaryPath_default_instance_;
class GetPluginSettingsPath;
struct GetPluginSettingsPathDefaultTypeInternal;
KIAPI_IMPORTEXPORT extern GetPluginSettingsPathDefaultTypeInternal _GetPluginSettingsPath_default_instance_;
class GetTextAsShapes;
struct GetTextAsShapesDefaultTypeInternal;
KIAPI_IMPORTEXPORT extern GetTextAsShapesDefaultTypeInternal _GetTextAsShapes_default_instance_;
class GetTextAsShapesResponse;
struct GetTextAsShapesResponseDefaultTypeInternal;
KIAPI_IMPORTEXPORT extern GetTextAsShapesResponseDefaultTypeInternal _GetTextAsShapesResponse_default_instance_;
class GetTextExtents;
struct GetTextExtentsDefaultTypeInternal;
KIAPI_IMPORTEXPORT extern GetTextExtentsDefaultTypeInternal _GetTextExtents_default_instance_;
class GetVersion;
struct GetVersionDefaultTypeInternal;
KIAPI_IMPORTEXPORT extern GetVersionDefaultTypeInternal _GetVersion_default_instance_;
class GetVersionResponse;
struct GetVersionResponseDefaultTypeInternal;
KIAPI_IMPORTEXPORT extern GetVersionResponseDefaultTypeInternal _GetVersionResponse_default_instance_;
class PathResponse;
struct PathResponseDefaultTypeInternal;
KIAPI_IMPORTEXPORT extern PathResponseDefaultTypeInternal _PathResponse_default_instance_;
class Ping;
struct PingDefaultTypeInternal;
KIAPI_IMPORTEXPORT extern PingDefaultTypeInternal _Ping_default_instance_;
class StringResponse;
struct StringResponseDefaultTypeInternal;
KIAPI_IMPORTEXPORT extern StringResponseDefaultTypeInternal _StringResponse_default_instance_;
class TextOrTextBox;
struct TextOrTextBoxDefaultTypeInternal;
KIAPI_IMPORTEXPORT extern TextOrTextBoxDefaultTypeInternal _TextOrTextBox_default_instance_;
class TextWithShapes;
struct TextWithShapesDefaultTypeInternal;
KIAPI_IMPORTEXPORT extern TextWithShapesDefaultTypeInternal _TextWithShapes_default_instance_;
}  // namespace commands
}  // namespace common
}  // namespace kiapi
PROTOBUF_NAMESPACE_OPEN
template<> KIAPI_IMPORTEXPORT ::kiapi::common::commands::GetKiCadBinaryPath* Arena::CreateMaybeMessage<::kiapi::common::commands::GetKiCadBinaryPath>(Arena*);
template<> KIAPI_IMPORTEXPORT ::kiapi::common::commands::GetPluginSettingsPath* Arena::CreateMaybeMessage<::kiapi::common::commands::GetPluginSettingsPath>(Arena*);
template<> KIAPI_IMPORTEXPORT ::kiapi::common::commands::GetTextAsShapes* Arena::CreateMaybeMessage<::kiapi::common::commands::GetTextAsShapes>(Arena*);
template<> KIAPI_IMPORTEXPORT ::kiapi::common::commands::GetTextAsShapesResponse* Arena::CreateMaybeMessage<::kiapi::common::commands::GetTextAsShapesResponse>(Arena*);
template<> KIAPI_IMPORTEXPORT ::kiapi::common::commands::GetTextExtents* Arena::CreateMaybeMessage<::kiapi::common::commands::GetTextExtents>(Arena*);
template<> KIAPI_IMPORTEXPORT ::kiapi::common::commands::GetVersion* Arena::CreateMaybeMessage<::kiapi::common::commands::GetVersion>(Arena*);
template<> KIAPI_IMPORTEXPORT ::kiapi::common::commands::GetVersionResponse* Arena::CreateMaybeMessage<::kiapi::common::commands::GetVersionResponse>(Arena*);
template<> KIAPI_IMPORTEXPORT ::kiapi::common::commands::PathResponse* Arena::CreateMaybeMessage<::kiapi::common::commands::PathResponse>(Arena*);
template<> KIAPI_IMPORTEXPORT ::kiapi::common::commands::Ping* Arena::CreateMaybeMessage<::kiapi::common::commands::Ping>(Arena*);
template<> KIAPI_IMPORTEXPORT ::kiapi::common::commands::StringResponse* Arena::CreateMaybeMessage<::kiapi::common::commands::StringResponse>(Arena*);
template<> KIAPI_IMPORTEXPORT ::kiapi::common::commands::TextOrTextBox* Arena::CreateMaybeMessage<::kiapi::common::commands::TextOrTextBox>(Arena*);
template<> KIAPI_IMPORTEXPORT ::kiapi::common::commands::TextWithShapes* Arena::CreateMaybeMessage<::kiapi::common::commands::TextWithShapes>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace kiapi {
namespace common {
namespace commands {

// ===================================================================

class KIAPI_IMPORTEXPORT GetVersion final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:kiapi.common.commands.GetVersion) */ {
 public:
  inline GetVersion() : GetVersion(nullptr) {}
  explicit constexpr GetVersion(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetVersion(const GetVersion& from);
  GetVersion(GetVersion&& from) noexcept
    : GetVersion() {
    *this = ::std::move(from);
  }

  inline GetVersion& operator=(const GetVersion& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetVersion& operator=(GetVersion&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetVersion& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetVersion* internal_default_instance() {
    return reinterpret_cast<const GetVersion*>(
               &_GetVersion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(GetVersion& a, GetVersion& b) {
    a.Swap(&b);
  }
  inline void Swap(GetVersion* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetVersion* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetVersion* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetVersion>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetVersion& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetVersion& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kiapi.common.commands.GetVersion";
  }
  protected:
  explicit GetVersion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:kiapi.common.commands.GetVersion)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2fcommands_2fbase_5fcommands_2eproto;
};
// -------------------------------------------------------------------

class KIAPI_IMPORTEXPORT GetVersionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kiapi.common.commands.GetVersionResponse) */ {
 public:
  inline GetVersionResponse() : GetVersionResponse(nullptr) {}
  ~GetVersionResponse() override;
  explicit constexpr GetVersionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetVersionResponse(const GetVersionResponse& from);
  GetVersionResponse(GetVersionResponse&& from) noexcept
    : GetVersionResponse() {
    *this = ::std::move(from);
  }

  inline GetVersionResponse& operator=(const GetVersionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetVersionResponse& operator=(GetVersionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetVersionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetVersionResponse* internal_default_instance() {
    return reinterpret_cast<const GetVersionResponse*>(
               &_GetVersionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(GetVersionResponse& a, GetVersionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetVersionResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetVersionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetVersionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetVersionResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetVersionResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetVersionResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetVersionResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kiapi.common.commands.GetVersionResponse";
  }
  protected:
  explicit GetVersionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 1,
  };
  // .kiapi.common.types.KiCadVersion version = 1;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  const ::kiapi::common::types::KiCadVersion& version() const;
  PROTOBUF_NODISCARD ::kiapi::common::types::KiCadVersion* release_version();
  ::kiapi::common::types::KiCadVersion* mutable_version();
  void set_allocated_version(::kiapi::common::types::KiCadVersion* version);
  private:
  const ::kiapi::common::types::KiCadVersion& _internal_version() const;
  ::kiapi::common::types::KiCadVersion* _internal_mutable_version();
  public:
  void unsafe_arena_set_allocated_version(
      ::kiapi::common::types::KiCadVersion* version);
  ::kiapi::common::types::KiCadVersion* unsafe_arena_release_version();

  // @@protoc_insertion_point(class_scope:kiapi.common.commands.GetVersionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::kiapi::common::types::KiCadVersion* version_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2fcommands_2fbase_5fcommands_2eproto;
};
// -------------------------------------------------------------------

class KIAPI_IMPORTEXPORT Ping final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:kiapi.common.commands.Ping) */ {
 public:
  inline Ping() : Ping(nullptr) {}
  explicit constexpr Ping(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Ping(const Ping& from);
  Ping(Ping&& from) noexcept
    : Ping() {
    *this = ::std::move(from);
  }

  inline Ping& operator=(const Ping& from) {
    CopyFrom(from);
    return *this;
  }
  inline Ping& operator=(Ping&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Ping& default_instance() {
    return *internal_default_instance();
  }
  static inline const Ping* internal_default_instance() {
    return reinterpret_cast<const Ping*>(
               &_Ping_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Ping& a, Ping& b) {
    a.Swap(&b);
  }
  inline void Swap(Ping* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Ping* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Ping* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Ping>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Ping& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Ping& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kiapi.common.commands.Ping";
  }
  protected:
  explicit Ping(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:kiapi.common.commands.Ping)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2fcommands_2fbase_5fcommands_2eproto;
};
// -------------------------------------------------------------------

class KIAPI_IMPORTEXPORT GetKiCadBinaryPath final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kiapi.common.commands.GetKiCadBinaryPath) */ {
 public:
  inline GetKiCadBinaryPath() : GetKiCadBinaryPath(nullptr) {}
  ~GetKiCadBinaryPath() override;
  explicit constexpr GetKiCadBinaryPath(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetKiCadBinaryPath(const GetKiCadBinaryPath& from);
  GetKiCadBinaryPath(GetKiCadBinaryPath&& from) noexcept
    : GetKiCadBinaryPath() {
    *this = ::std::move(from);
  }

  inline GetKiCadBinaryPath& operator=(const GetKiCadBinaryPath& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetKiCadBinaryPath& operator=(GetKiCadBinaryPath&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetKiCadBinaryPath& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetKiCadBinaryPath* internal_default_instance() {
    return reinterpret_cast<const GetKiCadBinaryPath*>(
               &_GetKiCadBinaryPath_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(GetKiCadBinaryPath& a, GetKiCadBinaryPath& b) {
    a.Swap(&b);
  }
  inline void Swap(GetKiCadBinaryPath* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetKiCadBinaryPath* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetKiCadBinaryPath* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetKiCadBinaryPath>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetKiCadBinaryPath& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetKiCadBinaryPath& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetKiCadBinaryPath* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kiapi.common.commands.GetKiCadBinaryPath";
  }
  protected:
  explicit GetKiCadBinaryPath(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBinaryNameFieldNumber = 1,
  };
  // string binary_name = 1;
  void clear_binary_name();
  const std::string& binary_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_binary_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_binary_name();
  PROTOBUF_NODISCARD std::string* release_binary_name();
  void set_allocated_binary_name(std::string* binary_name);
  private:
  const std::string& _internal_binary_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_binary_name(const std::string& value);
  std::string* _internal_mutable_binary_name();
  public:

  // @@protoc_insertion_point(class_scope:kiapi.common.commands.GetKiCadBinaryPath)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr binary_name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2fcommands_2fbase_5fcommands_2eproto;
};
// -------------------------------------------------------------------

class KIAPI_IMPORTEXPORT PathResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kiapi.common.commands.PathResponse) */ {
 public:
  inline PathResponse() : PathResponse(nullptr) {}
  ~PathResponse() override;
  explicit constexpr PathResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PathResponse(const PathResponse& from);
  PathResponse(PathResponse&& from) noexcept
    : PathResponse() {
    *this = ::std::move(from);
  }

  inline PathResponse& operator=(const PathResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PathResponse& operator=(PathResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PathResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PathResponse* internal_default_instance() {
    return reinterpret_cast<const PathResponse*>(
               &_PathResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(PathResponse& a, PathResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PathResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PathResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PathResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PathResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PathResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PathResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PathResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kiapi.common.commands.PathResponse";
  }
  protected:
  explicit PathResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 1,
  };
  // string path = 1;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // @@protoc_insertion_point(class_scope:kiapi.common.commands.PathResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2fcommands_2fbase_5fcommands_2eproto;
};
// -------------------------------------------------------------------

class KIAPI_IMPORTEXPORT GetTextExtents final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kiapi.common.commands.GetTextExtents) */ {
 public:
  inline GetTextExtents() : GetTextExtents(nullptr) {}
  ~GetTextExtents() override;
  explicit constexpr GetTextExtents(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetTextExtents(const GetTextExtents& from);
  GetTextExtents(GetTextExtents&& from) noexcept
    : GetTextExtents() {
    *this = ::std::move(from);
  }

  inline GetTextExtents& operator=(const GetTextExtents& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTextExtents& operator=(GetTextExtents&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTextExtents& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTextExtents* internal_default_instance() {
    return reinterpret_cast<const GetTextExtents*>(
               &_GetTextExtents_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(GetTextExtents& a, GetTextExtents& b) {
    a.Swap(&b);
  }
  inline void Swap(GetTextExtents* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTextExtents* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetTextExtents* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetTextExtents>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetTextExtents& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetTextExtents& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTextExtents* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kiapi.common.commands.GetTextExtents";
  }
  protected:
  explicit GetTextExtents(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 1,
  };
  // .kiapi.common.types.Text text = 1;
  bool has_text() const;
  private:
  bool _internal_has_text() const;
  public:
  void clear_text();
  const ::kiapi::common::types::Text& text() const;
  PROTOBUF_NODISCARD ::kiapi::common::types::Text* release_text();
  ::kiapi::common::types::Text* mutable_text();
  void set_allocated_text(::kiapi::common::types::Text* text);
  private:
  const ::kiapi::common::types::Text& _internal_text() const;
  ::kiapi::common::types::Text* _internal_mutable_text();
  public:
  void unsafe_arena_set_allocated_text(
      ::kiapi::common::types::Text* text);
  ::kiapi::common::types::Text* unsafe_arena_release_text();

  // @@protoc_insertion_point(class_scope:kiapi.common.commands.GetTextExtents)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::kiapi::common::types::Text* text_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2fcommands_2fbase_5fcommands_2eproto;
};
// -------------------------------------------------------------------

class KIAPI_IMPORTEXPORT TextOrTextBox final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kiapi.common.commands.TextOrTextBox) */ {
 public:
  inline TextOrTextBox() : TextOrTextBox(nullptr) {}
  ~TextOrTextBox() override;
  explicit constexpr TextOrTextBox(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TextOrTextBox(const TextOrTextBox& from);
  TextOrTextBox(TextOrTextBox&& from) noexcept
    : TextOrTextBox() {
    *this = ::std::move(from);
  }

  inline TextOrTextBox& operator=(const TextOrTextBox& from) {
    CopyFrom(from);
    return *this;
  }
  inline TextOrTextBox& operator=(TextOrTextBox&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TextOrTextBox& default_instance() {
    return *internal_default_instance();
  }
  enum InnerCase {
    kText = 1,
    kTextbox = 2,
    INNER_NOT_SET = 0,
  };

  static inline const TextOrTextBox* internal_default_instance() {
    return reinterpret_cast<const TextOrTextBox*>(
               &_TextOrTextBox_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(TextOrTextBox& a, TextOrTextBox& b) {
    a.Swap(&b);
  }
  inline void Swap(TextOrTextBox* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TextOrTextBox* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TextOrTextBox* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TextOrTextBox>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TextOrTextBox& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TextOrTextBox& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TextOrTextBox* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kiapi.common.commands.TextOrTextBox";
  }
  protected:
  explicit TextOrTextBox(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 1,
    kTextboxFieldNumber = 2,
  };
  // .kiapi.common.types.Text text = 1;
  bool has_text() const;
  private:
  bool _internal_has_text() const;
  public:
  void clear_text();
  const ::kiapi::common::types::Text& text() const;
  PROTOBUF_NODISCARD ::kiapi::common::types::Text* release_text();
  ::kiapi::common::types::Text* mutable_text();
  void set_allocated_text(::kiapi::common::types::Text* text);
  private:
  const ::kiapi::common::types::Text& _internal_text() const;
  ::kiapi::common::types::Text* _internal_mutable_text();
  public:
  void unsafe_arena_set_allocated_text(
      ::kiapi::common::types::Text* text);
  ::kiapi::common::types::Text* unsafe_arena_release_text();

  // .kiapi.common.types.TextBox textbox = 2;
  bool has_textbox() const;
  private:
  bool _internal_has_textbox() const;
  public:
  void clear_textbox();
  const ::kiapi::common::types::TextBox& textbox() const;
  PROTOBUF_NODISCARD ::kiapi::common::types::TextBox* release_textbox();
  ::kiapi::common::types::TextBox* mutable_textbox();
  void set_allocated_textbox(::kiapi::common::types::TextBox* textbox);
  private:
  const ::kiapi::common::types::TextBox& _internal_textbox() const;
  ::kiapi::common::types::TextBox* _internal_mutable_textbox();
  public:
  void unsafe_arena_set_allocated_textbox(
      ::kiapi::common::types::TextBox* textbox);
  ::kiapi::common::types::TextBox* unsafe_arena_release_textbox();

  void clear_inner();
  InnerCase inner_case() const;
  // @@protoc_insertion_point(class_scope:kiapi.common.commands.TextOrTextBox)
 private:
  class _Internal;
  void set_has_text();
  void set_has_textbox();

  inline bool has_inner() const;
  inline void clear_has_inner();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union InnerUnion {
    constexpr InnerUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::kiapi::common::types::Text* text_;
    ::kiapi::common::types::TextBox* textbox_;
  } inner_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_common_2fcommands_2fbase_5fcommands_2eproto;
};
// -------------------------------------------------------------------

class KIAPI_IMPORTEXPORT GetTextAsShapes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kiapi.common.commands.GetTextAsShapes) */ {
 public:
  inline GetTextAsShapes() : GetTextAsShapes(nullptr) {}
  ~GetTextAsShapes() override;
  explicit constexpr GetTextAsShapes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetTextAsShapes(const GetTextAsShapes& from);
  GetTextAsShapes(GetTextAsShapes&& from) noexcept
    : GetTextAsShapes() {
    *this = ::std::move(from);
  }

  inline GetTextAsShapes& operator=(const GetTextAsShapes& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTextAsShapes& operator=(GetTextAsShapes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTextAsShapes& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTextAsShapes* internal_default_instance() {
    return reinterpret_cast<const GetTextAsShapes*>(
               &_GetTextAsShapes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(GetTextAsShapes& a, GetTextAsShapes& b) {
    a.Swap(&b);
  }
  inline void Swap(GetTextAsShapes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTextAsShapes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetTextAsShapes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetTextAsShapes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetTextAsShapes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetTextAsShapes& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTextAsShapes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kiapi.common.commands.GetTextAsShapes";
  }
  protected:
  explicit GetTextAsShapes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 1,
  };
  // repeated .kiapi.common.commands.TextOrTextBox text = 1;
  int text_size() const;
  private:
  int _internal_text_size() const;
  public:
  void clear_text();
  ::kiapi::common::commands::TextOrTextBox* mutable_text(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::commands::TextOrTextBox >*
      mutable_text();
  private:
  const ::kiapi::common::commands::TextOrTextBox& _internal_text(int index) const;
  ::kiapi::common::commands::TextOrTextBox* _internal_add_text();
  public:
  const ::kiapi::common::commands::TextOrTextBox& text(int index) const;
  ::kiapi::common::commands::TextOrTextBox* add_text();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::commands::TextOrTextBox >&
      text() const;

  // @@protoc_insertion_point(class_scope:kiapi.common.commands.GetTextAsShapes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::commands::TextOrTextBox > text_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2fcommands_2fbase_5fcommands_2eproto;
};
// -------------------------------------------------------------------

class KIAPI_IMPORTEXPORT TextWithShapes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kiapi.common.commands.TextWithShapes) */ {
 public:
  inline TextWithShapes() : TextWithShapes(nullptr) {}
  ~TextWithShapes() override;
  explicit constexpr TextWithShapes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TextWithShapes(const TextWithShapes& from);
  TextWithShapes(TextWithShapes&& from) noexcept
    : TextWithShapes() {
    *this = ::std::move(from);
  }

  inline TextWithShapes& operator=(const TextWithShapes& from) {
    CopyFrom(from);
    return *this;
  }
  inline TextWithShapes& operator=(TextWithShapes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TextWithShapes& default_instance() {
    return *internal_default_instance();
  }
  static inline const TextWithShapes* internal_default_instance() {
    return reinterpret_cast<const TextWithShapes*>(
               &_TextWithShapes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(TextWithShapes& a, TextWithShapes& b) {
    a.Swap(&b);
  }
  inline void Swap(TextWithShapes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TextWithShapes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TextWithShapes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TextWithShapes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TextWithShapes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TextWithShapes& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TextWithShapes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kiapi.common.commands.TextWithShapes";
  }
  protected:
  explicit TextWithShapes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 1,
    kShapesFieldNumber = 2,
  };
  // .kiapi.common.commands.TextOrTextBox text = 1;
  bool has_text() const;
  private:
  bool _internal_has_text() const;
  public:
  void clear_text();
  const ::kiapi::common::commands::TextOrTextBox& text() const;
  PROTOBUF_NODISCARD ::kiapi::common::commands::TextOrTextBox* release_text();
  ::kiapi::common::commands::TextOrTextBox* mutable_text();
  void set_allocated_text(::kiapi::common::commands::TextOrTextBox* text);
  private:
  const ::kiapi::common::commands::TextOrTextBox& _internal_text() const;
  ::kiapi::common::commands::TextOrTextBox* _internal_mutable_text();
  public:
  void unsafe_arena_set_allocated_text(
      ::kiapi::common::commands::TextOrTextBox* text);
  ::kiapi::common::commands::TextOrTextBox* unsafe_arena_release_text();

  // .kiapi.common.types.CompoundShape shapes = 2;
  bool has_shapes() const;
  private:
  bool _internal_has_shapes() const;
  public:
  void clear_shapes();
  const ::kiapi::common::types::CompoundShape& shapes() const;
  PROTOBUF_NODISCARD ::kiapi::common::types::CompoundShape* release_shapes();
  ::kiapi::common::types::CompoundShape* mutable_shapes();
  void set_allocated_shapes(::kiapi::common::types::CompoundShape* shapes);
  private:
  const ::kiapi::common::types::CompoundShape& _internal_shapes() const;
  ::kiapi::common::types::CompoundShape* _internal_mutable_shapes();
  public:
  void unsafe_arena_set_allocated_shapes(
      ::kiapi::common::types::CompoundShape* shapes);
  ::kiapi::common::types::CompoundShape* unsafe_arena_release_shapes();

  // @@protoc_insertion_point(class_scope:kiapi.common.commands.TextWithShapes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::kiapi::common::commands::TextOrTextBox* text_;
  ::kiapi::common::types::CompoundShape* shapes_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2fcommands_2fbase_5fcommands_2eproto;
};
// -------------------------------------------------------------------

class KIAPI_IMPORTEXPORT GetTextAsShapesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kiapi.common.commands.GetTextAsShapesResponse) */ {
 public:
  inline GetTextAsShapesResponse() : GetTextAsShapesResponse(nullptr) {}
  ~GetTextAsShapesResponse() override;
  explicit constexpr GetTextAsShapesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetTextAsShapesResponse(const GetTextAsShapesResponse& from);
  GetTextAsShapesResponse(GetTextAsShapesResponse&& from) noexcept
    : GetTextAsShapesResponse() {
    *this = ::std::move(from);
  }

  inline GetTextAsShapesResponse& operator=(const GetTextAsShapesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTextAsShapesResponse& operator=(GetTextAsShapesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTextAsShapesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTextAsShapesResponse* internal_default_instance() {
    return reinterpret_cast<const GetTextAsShapesResponse*>(
               &_GetTextAsShapesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(GetTextAsShapesResponse& a, GetTextAsShapesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetTextAsShapesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTextAsShapesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetTextAsShapesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetTextAsShapesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetTextAsShapesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetTextAsShapesResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTextAsShapesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kiapi.common.commands.GetTextAsShapesResponse";
  }
  protected:
  explicit GetTextAsShapesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextWithShapesFieldNumber = 1,
  };
  // repeated .kiapi.common.commands.TextWithShapes text_with_shapes = 1;
  int text_with_shapes_size() const;
  private:
  int _internal_text_with_shapes_size() const;
  public:
  void clear_text_with_shapes();
  ::kiapi::common::commands::TextWithShapes* mutable_text_with_shapes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::commands::TextWithShapes >*
      mutable_text_with_shapes();
  private:
  const ::kiapi::common::commands::TextWithShapes& _internal_text_with_shapes(int index) const;
  ::kiapi::common::commands::TextWithShapes* _internal_add_text_with_shapes();
  public:
  const ::kiapi::common::commands::TextWithShapes& text_with_shapes(int index) const;
  ::kiapi::common::commands::TextWithShapes* add_text_with_shapes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::commands::TextWithShapes >&
      text_with_shapes() const;

  // @@protoc_insertion_point(class_scope:kiapi.common.commands.GetTextAsShapesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::commands::TextWithShapes > text_with_shapes_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2fcommands_2fbase_5fcommands_2eproto;
};
// -------------------------------------------------------------------

class KIAPI_IMPORTEXPORT GetPluginSettingsPath final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kiapi.common.commands.GetPluginSettingsPath) */ {
 public:
  inline GetPluginSettingsPath() : GetPluginSettingsPath(nullptr) {}
  ~GetPluginSettingsPath() override;
  explicit constexpr GetPluginSettingsPath(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetPluginSettingsPath(const GetPluginSettingsPath& from);
  GetPluginSettingsPath(GetPluginSettingsPath&& from) noexcept
    : GetPluginSettingsPath() {
    *this = ::std::move(from);
  }

  inline GetPluginSettingsPath& operator=(const GetPluginSettingsPath& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPluginSettingsPath& operator=(GetPluginSettingsPath&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetPluginSettingsPath& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetPluginSettingsPath* internal_default_instance() {
    return reinterpret_cast<const GetPluginSettingsPath*>(
               &_GetPluginSettingsPath_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(GetPluginSettingsPath& a, GetPluginSettingsPath& b) {
    a.Swap(&b);
  }
  inline void Swap(GetPluginSettingsPath* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPluginSettingsPath* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetPluginSettingsPath* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetPluginSettingsPath>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetPluginSettingsPath& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetPluginSettingsPath& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetPluginSettingsPath* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kiapi.common.commands.GetPluginSettingsPath";
  }
  protected:
  explicit GetPluginSettingsPath(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdentifierFieldNumber = 1,
  };
  // string identifier = 1;
  void clear_identifier();
  const std::string& identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_identifier();
  PROTOBUF_NODISCARD std::string* release_identifier();
  void set_allocated_identifier(std::string* identifier);
  private:
  const std::string& _internal_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_identifier(const std::string& value);
  std::string* _internal_mutable_identifier();
  public:

  // @@protoc_insertion_point(class_scope:kiapi.common.commands.GetPluginSettingsPath)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr identifier_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2fcommands_2fbase_5fcommands_2eproto;
};
// -------------------------------------------------------------------

class KIAPI_IMPORTEXPORT StringResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kiapi.common.commands.StringResponse) */ {
 public:
  inline StringResponse() : StringResponse(nullptr) {}
  ~StringResponse() override;
  explicit constexpr StringResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StringResponse(const StringResponse& from);
  StringResponse(StringResponse&& from) noexcept
    : StringResponse() {
    *this = ::std::move(from);
  }

  inline StringResponse& operator=(const StringResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StringResponse& operator=(StringResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StringResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StringResponse* internal_default_instance() {
    return reinterpret_cast<const StringResponse*>(
               &_StringResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(StringResponse& a, StringResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StringResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StringResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StringResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StringResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StringResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StringResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StringResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kiapi.common.commands.StringResponse";
  }
  protected:
  explicit StringResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 1,
  };
  // string response = 1;
  void clear_response();
  const std::string& response() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_response(ArgT0&& arg0, ArgT... args);
  std::string* mutable_response();
  PROTOBUF_NODISCARD std::string* release_response();
  void set_allocated_response(std::string* response);
  private:
  const std::string& _internal_response() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_response(const std::string& value);
  std::string* _internal_mutable_response();
  public:

  // @@protoc_insertion_point(class_scope:kiapi.common.commands.StringResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr response_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2fcommands_2fbase_5fcommands_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// GetVersion

// -------------------------------------------------------------------

// GetVersionResponse

// .kiapi.common.types.KiCadVersion version = 1;
inline bool GetVersionResponse::_internal_has_version() const {
  return this != internal_default_instance() && version_ != nullptr;
}
inline bool GetVersionResponse::has_version() const {
  return _internal_has_version();
}
inline const ::kiapi::common::types::KiCadVersion& GetVersionResponse::_internal_version() const {
  const ::kiapi::common::types::KiCadVersion* p = version_;
  return p != nullptr ? *p : reinterpret_cast<const ::kiapi::common::types::KiCadVersion&>(
      ::kiapi::common::types::_KiCadVersion_default_instance_);
}
inline const ::kiapi::common::types::KiCadVersion& GetVersionResponse::version() const {
  // @@protoc_insertion_point(field_get:kiapi.common.commands.GetVersionResponse.version)
  return _internal_version();
}
inline void GetVersionResponse::unsafe_arena_set_allocated_version(
    ::kiapi::common::types::KiCadVersion* version) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(version_);
  }
  version_ = version;
  if (version) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kiapi.common.commands.GetVersionResponse.version)
}
inline ::kiapi::common::types::KiCadVersion* GetVersionResponse::release_version() {
  
  ::kiapi::common::types::KiCadVersion* temp = version_;
  version_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kiapi::common::types::KiCadVersion* GetVersionResponse::unsafe_arena_release_version() {
  // @@protoc_insertion_point(field_release:kiapi.common.commands.GetVersionResponse.version)
  
  ::kiapi::common::types::KiCadVersion* temp = version_;
  version_ = nullptr;
  return temp;
}
inline ::kiapi::common::types::KiCadVersion* GetVersionResponse::_internal_mutable_version() {
  
  if (version_ == nullptr) {
    auto* p = CreateMaybeMessage<::kiapi::common::types::KiCadVersion>(GetArenaForAllocation());
    version_ = p;
  }
  return version_;
}
inline ::kiapi::common::types::KiCadVersion* GetVersionResponse::mutable_version() {
  ::kiapi::common::types::KiCadVersion* _msg = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:kiapi.common.commands.GetVersionResponse.version)
  return _msg;
}
inline void GetVersionResponse::set_allocated_version(::kiapi::common::types::KiCadVersion* version) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(version_);
  }
  if (version) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(version));
    if (message_arena != submessage_arena) {
      version = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, version, submessage_arena);
    }
    
  } else {
    
  }
  version_ = version;
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.commands.GetVersionResponse.version)
}

// -------------------------------------------------------------------

// Ping

// -------------------------------------------------------------------

// GetKiCadBinaryPath

// string binary_name = 1;
inline void GetKiCadBinaryPath::clear_binary_name() {
  binary_name_.ClearToEmpty();
}
inline const std::string& GetKiCadBinaryPath::binary_name() const {
  // @@protoc_insertion_point(field_get:kiapi.common.commands.GetKiCadBinaryPath.binary_name)
  return _internal_binary_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetKiCadBinaryPath::set_binary_name(ArgT0&& arg0, ArgT... args) {
 
 binary_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kiapi.common.commands.GetKiCadBinaryPath.binary_name)
}
inline std::string* GetKiCadBinaryPath::mutable_binary_name() {
  std::string* _s = _internal_mutable_binary_name();
  // @@protoc_insertion_point(field_mutable:kiapi.common.commands.GetKiCadBinaryPath.binary_name)
  return _s;
}
inline const std::string& GetKiCadBinaryPath::_internal_binary_name() const {
  return binary_name_.Get();
}
inline void GetKiCadBinaryPath::_internal_set_binary_name(const std::string& value) {
  
  binary_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetKiCadBinaryPath::_internal_mutable_binary_name() {
  
  return binary_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetKiCadBinaryPath::release_binary_name() {
  // @@protoc_insertion_point(field_release:kiapi.common.commands.GetKiCadBinaryPath.binary_name)
  return binary_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetKiCadBinaryPath::set_allocated_binary_name(std::string* binary_name) {
  if (binary_name != nullptr) {
    
  } else {
    
  }
  binary_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), binary_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (binary_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    binary_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.commands.GetKiCadBinaryPath.binary_name)
}

// -------------------------------------------------------------------

// PathResponse

// string path = 1;
inline void PathResponse::clear_path() {
  path_.ClearToEmpty();
}
inline const std::string& PathResponse::path() const {
  // @@protoc_insertion_point(field_get:kiapi.common.commands.PathResponse.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PathResponse::set_path(ArgT0&& arg0, ArgT... args) {
 
 path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kiapi.common.commands.PathResponse.path)
}
inline std::string* PathResponse::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:kiapi.common.commands.PathResponse.path)
  return _s;
}
inline const std::string& PathResponse::_internal_path() const {
  return path_.Get();
}
inline void PathResponse::_internal_set_path(const std::string& value) {
  
  path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PathResponse::_internal_mutable_path() {
  
  return path_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PathResponse::release_path() {
  // @@protoc_insertion_point(field_release:kiapi.common.commands.PathResponse.path)
  return path_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PathResponse::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), path,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (path_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.commands.PathResponse.path)
}

// -------------------------------------------------------------------

// GetTextExtents

// .kiapi.common.types.Text text = 1;
inline bool GetTextExtents::_internal_has_text() const {
  return this != internal_default_instance() && text_ != nullptr;
}
inline bool GetTextExtents::has_text() const {
  return _internal_has_text();
}
inline const ::kiapi::common::types::Text& GetTextExtents::_internal_text() const {
  const ::kiapi::common::types::Text* p = text_;
  return p != nullptr ? *p : reinterpret_cast<const ::kiapi::common::types::Text&>(
      ::kiapi::common::types::_Text_default_instance_);
}
inline const ::kiapi::common::types::Text& GetTextExtents::text() const {
  // @@protoc_insertion_point(field_get:kiapi.common.commands.GetTextExtents.text)
  return _internal_text();
}
inline void GetTextExtents::unsafe_arena_set_allocated_text(
    ::kiapi::common::types::Text* text) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(text_);
  }
  text_ = text;
  if (text) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kiapi.common.commands.GetTextExtents.text)
}
inline ::kiapi::common::types::Text* GetTextExtents::release_text() {
  
  ::kiapi::common::types::Text* temp = text_;
  text_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kiapi::common::types::Text* GetTextExtents::unsafe_arena_release_text() {
  // @@protoc_insertion_point(field_release:kiapi.common.commands.GetTextExtents.text)
  
  ::kiapi::common::types::Text* temp = text_;
  text_ = nullptr;
  return temp;
}
inline ::kiapi::common::types::Text* GetTextExtents::_internal_mutable_text() {
  
  if (text_ == nullptr) {
    auto* p = CreateMaybeMessage<::kiapi::common::types::Text>(GetArenaForAllocation());
    text_ = p;
  }
  return text_;
}
inline ::kiapi::common::types::Text* GetTextExtents::mutable_text() {
  ::kiapi::common::types::Text* _msg = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:kiapi.common.commands.GetTextExtents.text)
  return _msg;
}
inline void GetTextExtents::set_allocated_text(::kiapi::common::types::Text* text) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(text_);
  }
  if (text) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(text));
    if (message_arena != submessage_arena) {
      text = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, text, submessage_arena);
    }
    
  } else {
    
  }
  text_ = text;
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.commands.GetTextExtents.text)
}

// -------------------------------------------------------------------

// TextOrTextBox

// .kiapi.common.types.Text text = 1;
inline bool TextOrTextBox::_internal_has_text() const {
  return inner_case() == kText;
}
inline bool TextOrTextBox::has_text() const {
  return _internal_has_text();
}
inline void TextOrTextBox::set_has_text() {
  _oneof_case_[0] = kText;
}
inline ::kiapi::common::types::Text* TextOrTextBox::release_text() {
  // @@protoc_insertion_point(field_release:kiapi.common.commands.TextOrTextBox.text)
  if (_internal_has_text()) {
    clear_has_inner();
      ::kiapi::common::types::Text* temp = inner_.text_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    inner_.text_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kiapi::common::types::Text& TextOrTextBox::_internal_text() const {
  return _internal_has_text()
      ? *inner_.text_
      : reinterpret_cast< ::kiapi::common::types::Text&>(::kiapi::common::types::_Text_default_instance_);
}
inline const ::kiapi::common::types::Text& TextOrTextBox::text() const {
  // @@protoc_insertion_point(field_get:kiapi.common.commands.TextOrTextBox.text)
  return _internal_text();
}
inline ::kiapi::common::types::Text* TextOrTextBox::unsafe_arena_release_text() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kiapi.common.commands.TextOrTextBox.text)
  if (_internal_has_text()) {
    clear_has_inner();
    ::kiapi::common::types::Text* temp = inner_.text_;
    inner_.text_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TextOrTextBox::unsafe_arena_set_allocated_text(::kiapi::common::types::Text* text) {
  clear_inner();
  if (text) {
    set_has_text();
    inner_.text_ = text;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kiapi.common.commands.TextOrTextBox.text)
}
inline ::kiapi::common::types::Text* TextOrTextBox::_internal_mutable_text() {
  if (!_internal_has_text()) {
    clear_inner();
    set_has_text();
    inner_.text_ = CreateMaybeMessage< ::kiapi::common::types::Text >(GetArenaForAllocation());
  }
  return inner_.text_;
}
inline ::kiapi::common::types::Text* TextOrTextBox::mutable_text() {
  ::kiapi::common::types::Text* _msg = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:kiapi.common.commands.TextOrTextBox.text)
  return _msg;
}

// .kiapi.common.types.TextBox textbox = 2;
inline bool TextOrTextBox::_internal_has_textbox() const {
  return inner_case() == kTextbox;
}
inline bool TextOrTextBox::has_textbox() const {
  return _internal_has_textbox();
}
inline void TextOrTextBox::set_has_textbox() {
  _oneof_case_[0] = kTextbox;
}
inline ::kiapi::common::types::TextBox* TextOrTextBox::release_textbox() {
  // @@protoc_insertion_point(field_release:kiapi.common.commands.TextOrTextBox.textbox)
  if (_internal_has_textbox()) {
    clear_has_inner();
      ::kiapi::common::types::TextBox* temp = inner_.textbox_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    inner_.textbox_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kiapi::common::types::TextBox& TextOrTextBox::_internal_textbox() const {
  return _internal_has_textbox()
      ? *inner_.textbox_
      : reinterpret_cast< ::kiapi::common::types::TextBox&>(::kiapi::common::types::_TextBox_default_instance_);
}
inline const ::kiapi::common::types::TextBox& TextOrTextBox::textbox() const {
  // @@protoc_insertion_point(field_get:kiapi.common.commands.TextOrTextBox.textbox)
  return _internal_textbox();
}
inline ::kiapi::common::types::TextBox* TextOrTextBox::unsafe_arena_release_textbox() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kiapi.common.commands.TextOrTextBox.textbox)
  if (_internal_has_textbox()) {
    clear_has_inner();
    ::kiapi::common::types::TextBox* temp = inner_.textbox_;
    inner_.textbox_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TextOrTextBox::unsafe_arena_set_allocated_textbox(::kiapi::common::types::TextBox* textbox) {
  clear_inner();
  if (textbox) {
    set_has_textbox();
    inner_.textbox_ = textbox;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kiapi.common.commands.TextOrTextBox.textbox)
}
inline ::kiapi::common::types::TextBox* TextOrTextBox::_internal_mutable_textbox() {
  if (!_internal_has_textbox()) {
    clear_inner();
    set_has_textbox();
    inner_.textbox_ = CreateMaybeMessage< ::kiapi::common::types::TextBox >(GetArenaForAllocation());
  }
  return inner_.textbox_;
}
inline ::kiapi::common::types::TextBox* TextOrTextBox::mutable_textbox() {
  ::kiapi::common::types::TextBox* _msg = _internal_mutable_textbox();
  // @@protoc_insertion_point(field_mutable:kiapi.common.commands.TextOrTextBox.textbox)
  return _msg;
}

inline bool TextOrTextBox::has_inner() const {
  return inner_case() != INNER_NOT_SET;
}
inline void TextOrTextBox::clear_has_inner() {
  _oneof_case_[0] = INNER_NOT_SET;
}
inline TextOrTextBox::InnerCase TextOrTextBox::inner_case() const {
  return TextOrTextBox::InnerCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// GetTextAsShapes

// repeated .kiapi.common.commands.TextOrTextBox text = 1;
inline int GetTextAsShapes::_internal_text_size() const {
  return text_.size();
}
inline int GetTextAsShapes::text_size() const {
  return _internal_text_size();
}
inline void GetTextAsShapes::clear_text() {
  text_.Clear();
}
inline ::kiapi::common::commands::TextOrTextBox* GetTextAsShapes::mutable_text(int index) {
  // @@protoc_insertion_point(field_mutable:kiapi.common.commands.GetTextAsShapes.text)
  return text_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::commands::TextOrTextBox >*
GetTextAsShapes::mutable_text() {
  // @@protoc_insertion_point(field_mutable_list:kiapi.common.commands.GetTextAsShapes.text)
  return &text_;
}
inline const ::kiapi::common::commands::TextOrTextBox& GetTextAsShapes::_internal_text(int index) const {
  return text_.Get(index);
}
inline const ::kiapi::common::commands::TextOrTextBox& GetTextAsShapes::text(int index) const {
  // @@protoc_insertion_point(field_get:kiapi.common.commands.GetTextAsShapes.text)
  return _internal_text(index);
}
inline ::kiapi::common::commands::TextOrTextBox* GetTextAsShapes::_internal_add_text() {
  return text_.Add();
}
inline ::kiapi::common::commands::TextOrTextBox* GetTextAsShapes::add_text() {
  ::kiapi::common::commands::TextOrTextBox* _add = _internal_add_text();
  // @@protoc_insertion_point(field_add:kiapi.common.commands.GetTextAsShapes.text)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::commands::TextOrTextBox >&
GetTextAsShapes::text() const {
  // @@protoc_insertion_point(field_list:kiapi.common.commands.GetTextAsShapes.text)
  return text_;
}

// -------------------------------------------------------------------

// TextWithShapes

// .kiapi.common.commands.TextOrTextBox text = 1;
inline bool TextWithShapes::_internal_has_text() const {
  return this != internal_default_instance() && text_ != nullptr;
}
inline bool TextWithShapes::has_text() const {
  return _internal_has_text();
}
inline void TextWithShapes::clear_text() {
  if (GetArenaForAllocation() == nullptr && text_ != nullptr) {
    delete text_;
  }
  text_ = nullptr;
}
inline const ::kiapi::common::commands::TextOrTextBox& TextWithShapes::_internal_text() const {
  const ::kiapi::common::commands::TextOrTextBox* p = text_;
  return p != nullptr ? *p : reinterpret_cast<const ::kiapi::common::commands::TextOrTextBox&>(
      ::kiapi::common::commands::_TextOrTextBox_default_instance_);
}
inline const ::kiapi::common::commands::TextOrTextBox& TextWithShapes::text() const {
  // @@protoc_insertion_point(field_get:kiapi.common.commands.TextWithShapes.text)
  return _internal_text();
}
inline void TextWithShapes::unsafe_arena_set_allocated_text(
    ::kiapi::common::commands::TextOrTextBox* text) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(text_);
  }
  text_ = text;
  if (text) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kiapi.common.commands.TextWithShapes.text)
}
inline ::kiapi::common::commands::TextOrTextBox* TextWithShapes::release_text() {
  
  ::kiapi::common::commands::TextOrTextBox* temp = text_;
  text_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kiapi::common::commands::TextOrTextBox* TextWithShapes::unsafe_arena_release_text() {
  // @@protoc_insertion_point(field_release:kiapi.common.commands.TextWithShapes.text)
  
  ::kiapi::common::commands::TextOrTextBox* temp = text_;
  text_ = nullptr;
  return temp;
}
inline ::kiapi::common::commands::TextOrTextBox* TextWithShapes::_internal_mutable_text() {
  
  if (text_ == nullptr) {
    auto* p = CreateMaybeMessage<::kiapi::common::commands::TextOrTextBox>(GetArenaForAllocation());
    text_ = p;
  }
  return text_;
}
inline ::kiapi::common::commands::TextOrTextBox* TextWithShapes::mutable_text() {
  ::kiapi::common::commands::TextOrTextBox* _msg = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:kiapi.common.commands.TextWithShapes.text)
  return _msg;
}
inline void TextWithShapes::set_allocated_text(::kiapi::common::commands::TextOrTextBox* text) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete text_;
  }
  if (text) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::kiapi::common::commands::TextOrTextBox>::GetOwningArena(text);
    if (message_arena != submessage_arena) {
      text = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, text, submessage_arena);
    }
    
  } else {
    
  }
  text_ = text;
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.commands.TextWithShapes.text)
}

// .kiapi.common.types.CompoundShape shapes = 2;
inline bool TextWithShapes::_internal_has_shapes() const {
  return this != internal_default_instance() && shapes_ != nullptr;
}
inline bool TextWithShapes::has_shapes() const {
  return _internal_has_shapes();
}
inline const ::kiapi::common::types::CompoundShape& TextWithShapes::_internal_shapes() const {
  const ::kiapi::common::types::CompoundShape* p = shapes_;
  return p != nullptr ? *p : reinterpret_cast<const ::kiapi::common::types::CompoundShape&>(
      ::kiapi::common::types::_CompoundShape_default_instance_);
}
inline const ::kiapi::common::types::CompoundShape& TextWithShapes::shapes() const {
  // @@protoc_insertion_point(field_get:kiapi.common.commands.TextWithShapes.shapes)
  return _internal_shapes();
}
inline void TextWithShapes::unsafe_arena_set_allocated_shapes(
    ::kiapi::common::types::CompoundShape* shapes) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(shapes_);
  }
  shapes_ = shapes;
  if (shapes) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kiapi.common.commands.TextWithShapes.shapes)
}
inline ::kiapi::common::types::CompoundShape* TextWithShapes::release_shapes() {
  
  ::kiapi::common::types::CompoundShape* temp = shapes_;
  shapes_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kiapi::common::types::CompoundShape* TextWithShapes::unsafe_arena_release_shapes() {
  // @@protoc_insertion_point(field_release:kiapi.common.commands.TextWithShapes.shapes)
  
  ::kiapi::common::types::CompoundShape* temp = shapes_;
  shapes_ = nullptr;
  return temp;
}
inline ::kiapi::common::types::CompoundShape* TextWithShapes::_internal_mutable_shapes() {
  
  if (shapes_ == nullptr) {
    auto* p = CreateMaybeMessage<::kiapi::common::types::CompoundShape>(GetArenaForAllocation());
    shapes_ = p;
  }
  return shapes_;
}
inline ::kiapi::common::types::CompoundShape* TextWithShapes::mutable_shapes() {
  ::kiapi::common::types::CompoundShape* _msg = _internal_mutable_shapes();
  // @@protoc_insertion_point(field_mutable:kiapi.common.commands.TextWithShapes.shapes)
  return _msg;
}
inline void TextWithShapes::set_allocated_shapes(::kiapi::common::types::CompoundShape* shapes) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(shapes_);
  }
  if (shapes) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(shapes));
    if (message_arena != submessage_arena) {
      shapes = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, shapes, submessage_arena);
    }
    
  } else {
    
  }
  shapes_ = shapes;
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.commands.TextWithShapes.shapes)
}

// -------------------------------------------------------------------

// GetTextAsShapesResponse

// repeated .kiapi.common.commands.TextWithShapes text_with_shapes = 1;
inline int GetTextAsShapesResponse::_internal_text_with_shapes_size() const {
  return text_with_shapes_.size();
}
inline int GetTextAsShapesResponse::text_with_shapes_size() const {
  return _internal_text_with_shapes_size();
}
inline void GetTextAsShapesResponse::clear_text_with_shapes() {
  text_with_shapes_.Clear();
}
inline ::kiapi::common::commands::TextWithShapes* GetTextAsShapesResponse::mutable_text_with_shapes(int index) {
  // @@protoc_insertion_point(field_mutable:kiapi.common.commands.GetTextAsShapesResponse.text_with_shapes)
  return text_with_shapes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::commands::TextWithShapes >*
GetTextAsShapesResponse::mutable_text_with_shapes() {
  // @@protoc_insertion_point(field_mutable_list:kiapi.common.commands.GetTextAsShapesResponse.text_with_shapes)
  return &text_with_shapes_;
}
inline const ::kiapi::common::commands::TextWithShapes& GetTextAsShapesResponse::_internal_text_with_shapes(int index) const {
  return text_with_shapes_.Get(index);
}
inline const ::kiapi::common::commands::TextWithShapes& GetTextAsShapesResponse::text_with_shapes(int index) const {
  // @@protoc_insertion_point(field_get:kiapi.common.commands.GetTextAsShapesResponse.text_with_shapes)
  return _internal_text_with_shapes(index);
}
inline ::kiapi::common::commands::TextWithShapes* GetTextAsShapesResponse::_internal_add_text_with_shapes() {
  return text_with_shapes_.Add();
}
inline ::kiapi::common::commands::TextWithShapes* GetTextAsShapesResponse::add_text_with_shapes() {
  ::kiapi::common::commands::TextWithShapes* _add = _internal_add_text_with_shapes();
  // @@protoc_insertion_point(field_add:kiapi.common.commands.GetTextAsShapesResponse.text_with_shapes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::commands::TextWithShapes >&
GetTextAsShapesResponse::text_with_shapes() const {
  // @@protoc_insertion_point(field_list:kiapi.common.commands.GetTextAsShapesResponse.text_with_shapes)
  return text_with_shapes_;
}

// -------------------------------------------------------------------

// GetPluginSettingsPath

// string identifier = 1;
inline void GetPluginSettingsPath::clear_identifier() {
  identifier_.ClearToEmpty();
}
inline const std::string& GetPluginSettingsPath::identifier() const {
  // @@protoc_insertion_point(field_get:kiapi.common.commands.GetPluginSettingsPath.identifier)
  return _internal_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetPluginSettingsPath::set_identifier(ArgT0&& arg0, ArgT... args) {
 
 identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kiapi.common.commands.GetPluginSettingsPath.identifier)
}
inline std::string* GetPluginSettingsPath::mutable_identifier() {
  std::string* _s = _internal_mutable_identifier();
  // @@protoc_insertion_point(field_mutable:kiapi.common.commands.GetPluginSettingsPath.identifier)
  return _s;
}
inline const std::string& GetPluginSettingsPath::_internal_identifier() const {
  return identifier_.Get();
}
inline void GetPluginSettingsPath::_internal_set_identifier(const std::string& value) {
  
  identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetPluginSettingsPath::_internal_mutable_identifier() {
  
  return identifier_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetPluginSettingsPath::release_identifier() {
  // @@protoc_insertion_point(field_release:kiapi.common.commands.GetPluginSettingsPath.identifier)
  return identifier_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetPluginSettingsPath::set_allocated_identifier(std::string* identifier) {
  if (identifier != nullptr) {
    
  } else {
    
  }
  identifier_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), identifier,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.commands.GetPluginSettingsPath.identifier)
}

// -------------------------------------------------------------------

// StringResponse

// string response = 1;
inline void StringResponse::clear_response() {
  response_.ClearToEmpty();
}
inline const std::string& StringResponse::response() const {
  // @@protoc_insertion_point(field_get:kiapi.common.commands.StringResponse.response)
  return _internal_response();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StringResponse::set_response(ArgT0&& arg0, ArgT... args) {
 
 response_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kiapi.common.commands.StringResponse.response)
}
inline std::string* StringResponse::mutable_response() {
  std::string* _s = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:kiapi.common.commands.StringResponse.response)
  return _s;
}
inline const std::string& StringResponse::_internal_response() const {
  return response_.Get();
}
inline void StringResponse::_internal_set_response(const std::string& value) {
  
  response_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StringResponse::_internal_mutable_response() {
  
  return response_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StringResponse::release_response() {
  // @@protoc_insertion_point(field_release:kiapi.common.commands.StringResponse.response)
  return response_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void StringResponse::set_allocated_response(std::string* response) {
  if (response != nullptr) {
    
  } else {
    
  }
  response_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), response,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (response_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    response_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.commands.StringResponse.response)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace commands
}  // namespace common
}  // namespace kiapi

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_common_2fcommands_2fbase_5fcommands_2eproto

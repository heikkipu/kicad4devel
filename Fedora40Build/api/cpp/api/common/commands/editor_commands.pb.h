// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: common/commands/editor_commands.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_common_2fcommands_2feditor_5fcommands_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_common_2fcommands_2feditor_5fcommands_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/any.pb.h>
#include "common/types/base_types.pb.h"
#include "common/types/enums.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_common_2fcommands_2feditor_5fcommands_2eproto KIAPI_IMPORTEXPORT
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct KIAPI_IMPORTEXPORT TableStruct_common_2fcommands_2feditor_5fcommands_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[40]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
KIAPI_IMPORTEXPORT extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_common_2fcommands_2feditor_5fcommands_2eproto;
namespace kiapi {
namespace common {
namespace commands {
class AddToSelection;
struct AddToSelectionDefaultTypeInternal;
KIAPI_IMPORTEXPORT extern AddToSelectionDefaultTypeInternal _AddToSelection_default_instance_;
class BeginCommit;
struct BeginCommitDefaultTypeInternal;
KIAPI_IMPORTEXPORT extern BeginCommitDefaultTypeInternal _BeginCommit_default_instance_;
class BeginCommitResponse;
struct BeginCommitResponseDefaultTypeInternal;
KIAPI_IMPORTEXPORT extern BeginCommitResponseDefaultTypeInternal _BeginCommitResponse_default_instance_;
class ClearSelection;
struct ClearSelectionDefaultTypeInternal;
KIAPI_IMPORTEXPORT extern ClearSelectionDefaultTypeInternal _ClearSelection_default_instance_;
class CreateItems;
struct CreateItemsDefaultTypeInternal;
KIAPI_IMPORTEXPORT extern CreateItemsDefaultTypeInternal _CreateItems_default_instance_;
class CreateItemsResponse;
struct CreateItemsResponseDefaultTypeInternal;
KIAPI_IMPORTEXPORT extern CreateItemsResponseDefaultTypeInternal _CreateItemsResponse_default_instance_;
class DeleteItems;
struct DeleteItemsDefaultTypeInternal;
KIAPI_IMPORTEXPORT extern DeleteItemsDefaultTypeInternal _DeleteItems_default_instance_;
class DeleteItemsResponse;
struct DeleteItemsResponseDefaultTypeInternal;
KIAPI_IMPORTEXPORT extern DeleteItemsResponseDefaultTypeInternal _DeleteItemsResponse_default_instance_;
class EndCommit;
struct EndCommitDefaultTypeInternal;
KIAPI_IMPORTEXPORT extern EndCommitDefaultTypeInternal _EndCommit_default_instance_;
class EndCommitResponse;
struct EndCommitResponseDefaultTypeInternal;
KIAPI_IMPORTEXPORT extern EndCommitResponseDefaultTypeInternal _EndCommitResponse_default_instance_;
class GetBoundingBox;
struct GetBoundingBoxDefaultTypeInternal;
KIAPI_IMPORTEXPORT extern GetBoundingBoxDefaultTypeInternal _GetBoundingBox_default_instance_;
class GetBoundingBoxResponse;
struct GetBoundingBoxResponseDefaultTypeInternal;
KIAPI_IMPORTEXPORT extern GetBoundingBoxResponseDefaultTypeInternal _GetBoundingBoxResponse_default_instance_;
class GetItems;
struct GetItemsDefaultTypeInternal;
KIAPI_IMPORTEXPORT extern GetItemsDefaultTypeInternal _GetItems_default_instance_;
class GetItemsResponse;
struct GetItemsResponseDefaultTypeInternal;
KIAPI_IMPORTEXPORT extern GetItemsResponseDefaultTypeInternal _GetItemsResponse_default_instance_;
class GetOpenDocuments;
struct GetOpenDocumentsDefaultTypeInternal;
KIAPI_IMPORTEXPORT extern GetOpenDocumentsDefaultTypeInternal _GetOpenDocuments_default_instance_;
class GetOpenDocumentsResponse;
struct GetOpenDocumentsResponseDefaultTypeInternal;
KIAPI_IMPORTEXPORT extern GetOpenDocumentsResponseDefaultTypeInternal _GetOpenDocumentsResponse_default_instance_;
class GetSelection;
struct GetSelectionDefaultTypeInternal;
KIAPI_IMPORTEXPORT extern GetSelectionDefaultTypeInternal _GetSelection_default_instance_;
class GetTitleBlockInfo;
struct GetTitleBlockInfoDefaultTypeInternal;
KIAPI_IMPORTEXPORT extern GetTitleBlockInfoDefaultTypeInternal _GetTitleBlockInfo_default_instance_;
class HitTest;
struct HitTestDefaultTypeInternal;
KIAPI_IMPORTEXPORT extern HitTestDefaultTypeInternal _HitTest_default_instance_;
class HitTestResponse;
struct HitTestResponseDefaultTypeInternal;
KIAPI_IMPORTEXPORT extern HitTestResponseDefaultTypeInternal _HitTestResponse_default_instance_;
class ItemCreationResult;
struct ItemCreationResultDefaultTypeInternal;
KIAPI_IMPORTEXPORT extern ItemCreationResultDefaultTypeInternal _ItemCreationResult_default_instance_;
class ItemDeletionResult;
struct ItemDeletionResultDefaultTypeInternal;
KIAPI_IMPORTEXPORT extern ItemDeletionResultDefaultTypeInternal _ItemDeletionResult_default_instance_;
class ItemStatus;
struct ItemStatusDefaultTypeInternal;
KIAPI_IMPORTEXPORT extern ItemStatusDefaultTypeInternal _ItemStatus_default_instance_;
class ItemUpdateResult;
struct ItemUpdateResultDefaultTypeInternal;
KIAPI_IMPORTEXPORT extern ItemUpdateResultDefaultTypeInternal _ItemUpdateResult_default_instance_;
class ParseAndCreateItemsFromString;
struct ParseAndCreateItemsFromStringDefaultTypeInternal;
KIAPI_IMPORTEXPORT extern ParseAndCreateItemsFromStringDefaultTypeInternal _ParseAndCreateItemsFromString_default_instance_;
class RefreshEditor;
struct RefreshEditorDefaultTypeInternal;
KIAPI_IMPORTEXPORT extern RefreshEditorDefaultTypeInternal _RefreshEditor_default_instance_;
class RemoveFromSelection;
struct RemoveFromSelectionDefaultTypeInternal;
KIAPI_IMPORTEXPORT extern RemoveFromSelectionDefaultTypeInternal _RemoveFromSelection_default_instance_;
class RevertDocument;
struct RevertDocumentDefaultTypeInternal;
KIAPI_IMPORTEXPORT extern RevertDocumentDefaultTypeInternal _RevertDocument_default_instance_;
class RunAction;
struct RunActionDefaultTypeInternal;
KIAPI_IMPORTEXPORT extern RunActionDefaultTypeInternal _RunAction_default_instance_;
class RunActionResponse;
struct RunActionResponseDefaultTypeInternal;
KIAPI_IMPORTEXPORT extern RunActionResponseDefaultTypeInternal _RunActionResponse_default_instance_;
class SaveCopyOfDocument;
struct SaveCopyOfDocumentDefaultTypeInternal;
KIAPI_IMPORTEXPORT extern SaveCopyOfDocumentDefaultTypeInternal _SaveCopyOfDocument_default_instance_;
class SaveDocument;
struct SaveDocumentDefaultTypeInternal;
KIAPI_IMPORTEXPORT extern SaveDocumentDefaultTypeInternal _SaveDocument_default_instance_;
class SaveDocumentToString;
struct SaveDocumentToStringDefaultTypeInternal;
KIAPI_IMPORTEXPORT extern SaveDocumentToStringDefaultTypeInternal _SaveDocumentToString_default_instance_;
class SaveOptions;
struct SaveOptionsDefaultTypeInternal;
KIAPI_IMPORTEXPORT extern SaveOptionsDefaultTypeInternal _SaveOptions_default_instance_;
class SaveSelectionToString;
struct SaveSelectionToStringDefaultTypeInternal;
KIAPI_IMPORTEXPORT extern SaveSelectionToStringDefaultTypeInternal _SaveSelectionToString_default_instance_;
class SavedDocumentResponse;
struct SavedDocumentResponseDefaultTypeInternal;
KIAPI_IMPORTEXPORT extern SavedDocumentResponseDefaultTypeInternal _SavedDocumentResponse_default_instance_;
class SavedSelectionResponse;
struct SavedSelectionResponseDefaultTypeInternal;
KIAPI_IMPORTEXPORT extern SavedSelectionResponseDefaultTypeInternal _SavedSelectionResponse_default_instance_;
class SelectionResponse;
struct SelectionResponseDefaultTypeInternal;
KIAPI_IMPORTEXPORT extern SelectionResponseDefaultTypeInternal _SelectionResponse_default_instance_;
class UpdateItems;
struct UpdateItemsDefaultTypeInternal;
KIAPI_IMPORTEXPORT extern UpdateItemsDefaultTypeInternal _UpdateItems_default_instance_;
class UpdateItemsResponse;
struct UpdateItemsResponseDefaultTypeInternal;
KIAPI_IMPORTEXPORT extern UpdateItemsResponseDefaultTypeInternal _UpdateItemsResponse_default_instance_;
}  // namespace commands
}  // namespace common
}  // namespace kiapi
PROTOBUF_NAMESPACE_OPEN
template<> KIAPI_IMPORTEXPORT ::kiapi::common::commands::AddToSelection* Arena::CreateMaybeMessage<::kiapi::common::commands::AddToSelection>(Arena*);
template<> KIAPI_IMPORTEXPORT ::kiapi::common::commands::BeginCommit* Arena::CreateMaybeMessage<::kiapi::common::commands::BeginCommit>(Arena*);
template<> KIAPI_IMPORTEXPORT ::kiapi::common::commands::BeginCommitResponse* Arena::CreateMaybeMessage<::kiapi::common::commands::BeginCommitResponse>(Arena*);
template<> KIAPI_IMPORTEXPORT ::kiapi::common::commands::ClearSelection* Arena::CreateMaybeMessage<::kiapi::common::commands::ClearSelection>(Arena*);
template<> KIAPI_IMPORTEXPORT ::kiapi::common::commands::CreateItems* Arena::CreateMaybeMessage<::kiapi::common::commands::CreateItems>(Arena*);
template<> KIAPI_IMPORTEXPORT ::kiapi::common::commands::CreateItemsResponse* Arena::CreateMaybeMessage<::kiapi::common::commands::CreateItemsResponse>(Arena*);
template<> KIAPI_IMPORTEXPORT ::kiapi::common::commands::DeleteItems* Arena::CreateMaybeMessage<::kiapi::common::commands::DeleteItems>(Arena*);
template<> KIAPI_IMPORTEXPORT ::kiapi::common::commands::DeleteItemsResponse* Arena::CreateMaybeMessage<::kiapi::common::commands::DeleteItemsResponse>(Arena*);
template<> KIAPI_IMPORTEXPORT ::kiapi::common::commands::EndCommit* Arena::CreateMaybeMessage<::kiapi::common::commands::EndCommit>(Arena*);
template<> KIAPI_IMPORTEXPORT ::kiapi::common::commands::EndCommitResponse* Arena::CreateMaybeMessage<::kiapi::common::commands::EndCommitResponse>(Arena*);
template<> KIAPI_IMPORTEXPORT ::kiapi::common::commands::GetBoundingBox* Arena::CreateMaybeMessage<::kiapi::common::commands::GetBoundingBox>(Arena*);
template<> KIAPI_IMPORTEXPORT ::kiapi::common::commands::GetBoundingBoxResponse* Arena::CreateMaybeMessage<::kiapi::common::commands::GetBoundingBoxResponse>(Arena*);
template<> KIAPI_IMPORTEXPORT ::kiapi::common::commands::GetItems* Arena::CreateMaybeMessage<::kiapi::common::commands::GetItems>(Arena*);
template<> KIAPI_IMPORTEXPORT ::kiapi::common::commands::GetItemsResponse* Arena::CreateMaybeMessage<::kiapi::common::commands::GetItemsResponse>(Arena*);
template<> KIAPI_IMPORTEXPORT ::kiapi::common::commands::GetOpenDocuments* Arena::CreateMaybeMessage<::kiapi::common::commands::GetOpenDocuments>(Arena*);
template<> KIAPI_IMPORTEXPORT ::kiapi::common::commands::GetOpenDocumentsResponse* Arena::CreateMaybeMessage<::kiapi::common::commands::GetOpenDocumentsResponse>(Arena*);
template<> KIAPI_IMPORTEXPORT ::kiapi::common::commands::GetSelection* Arena::CreateMaybeMessage<::kiapi::common::commands::GetSelection>(Arena*);
template<> KIAPI_IMPORTEXPORT ::kiapi::common::commands::GetTitleBlockInfo* Arena::CreateMaybeMessage<::kiapi::common::commands::GetTitleBlockInfo>(Arena*);
template<> KIAPI_IMPORTEXPORT ::kiapi::common::commands::HitTest* Arena::CreateMaybeMessage<::kiapi::common::commands::HitTest>(Arena*);
template<> KIAPI_IMPORTEXPORT ::kiapi::common::commands::HitTestResponse* Arena::CreateMaybeMessage<::kiapi::common::commands::HitTestResponse>(Arena*);
template<> KIAPI_IMPORTEXPORT ::kiapi::common::commands::ItemCreationResult* Arena::CreateMaybeMessage<::kiapi::common::commands::ItemCreationResult>(Arena*);
template<> KIAPI_IMPORTEXPORT ::kiapi::common::commands::ItemDeletionResult* Arena::CreateMaybeMessage<::kiapi::common::commands::ItemDeletionResult>(Arena*);
template<> KIAPI_IMPORTEXPORT ::kiapi::common::commands::ItemStatus* Arena::CreateMaybeMessage<::kiapi::common::commands::ItemStatus>(Arena*);
template<> KIAPI_IMPORTEXPORT ::kiapi::common::commands::ItemUpdateResult* Arena::CreateMaybeMessage<::kiapi::common::commands::ItemUpdateResult>(Arena*);
template<> KIAPI_IMPORTEXPORT ::kiapi::common::commands::ParseAndCreateItemsFromString* Arena::CreateMaybeMessage<::kiapi::common::commands::ParseAndCreateItemsFromString>(Arena*);
template<> KIAPI_IMPORTEXPORT ::kiapi::common::commands::RefreshEditor* Arena::CreateMaybeMessage<::kiapi::common::commands::RefreshEditor>(Arena*);
template<> KIAPI_IMPORTEXPORT ::kiapi::common::commands::RemoveFromSelection* Arena::CreateMaybeMessage<::kiapi::common::commands::RemoveFromSelection>(Arena*);
template<> KIAPI_IMPORTEXPORT ::kiapi::common::commands::RevertDocument* Arena::CreateMaybeMessage<::kiapi::common::commands::RevertDocument>(Arena*);
template<> KIAPI_IMPORTEXPORT ::kiapi::common::commands::RunAction* Arena::CreateMaybeMessage<::kiapi::common::commands::RunAction>(Arena*);
template<> KIAPI_IMPORTEXPORT ::kiapi::common::commands::RunActionResponse* Arena::CreateMaybeMessage<::kiapi::common::commands::RunActionResponse>(Arena*);
template<> KIAPI_IMPORTEXPORT ::kiapi::common::commands::SaveCopyOfDocument* Arena::CreateMaybeMessage<::kiapi::common::commands::SaveCopyOfDocument>(Arena*);
template<> KIAPI_IMPORTEXPORT ::kiapi::common::commands::SaveDocument* Arena::CreateMaybeMessage<::kiapi::common::commands::SaveDocument>(Arena*);
template<> KIAPI_IMPORTEXPORT ::kiapi::common::commands::SaveDocumentToString* Arena::CreateMaybeMessage<::kiapi::common::commands::SaveDocumentToString>(Arena*);
template<> KIAPI_IMPORTEXPORT ::kiapi::common::commands::SaveOptions* Arena::CreateMaybeMessage<::kiapi::common::commands::SaveOptions>(Arena*);
template<> KIAPI_IMPORTEXPORT ::kiapi::common::commands::SaveSelectionToString* Arena::CreateMaybeMessage<::kiapi::common::commands::SaveSelectionToString>(Arena*);
template<> KIAPI_IMPORTEXPORT ::kiapi::common::commands::SavedDocumentResponse* Arena::CreateMaybeMessage<::kiapi::common::commands::SavedDocumentResponse>(Arena*);
template<> KIAPI_IMPORTEXPORT ::kiapi::common::commands::SavedSelectionResponse* Arena::CreateMaybeMessage<::kiapi::common::commands::SavedSelectionResponse>(Arena*);
template<> KIAPI_IMPORTEXPORT ::kiapi::common::commands::SelectionResponse* Arena::CreateMaybeMessage<::kiapi::common::commands::SelectionResponse>(Arena*);
template<> KIAPI_IMPORTEXPORT ::kiapi::common::commands::UpdateItems* Arena::CreateMaybeMessage<::kiapi::common::commands::UpdateItems>(Arena*);
template<> KIAPI_IMPORTEXPORT ::kiapi::common::commands::UpdateItemsResponse* Arena::CreateMaybeMessage<::kiapi::common::commands::UpdateItemsResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace kiapi {
namespace common {
namespace commands {

enum RunActionStatus : int {
  RAS_UNKNOWN = 0,
  RAS_OK = 1,
  RAS_INVALID = 2,
  RAS_FRAME_NOT_OPEN = 3,
  RunActionStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  RunActionStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
KIAPI_IMPORTEXPORT bool RunActionStatus_IsValid(int value);
constexpr RunActionStatus RunActionStatus_MIN = RAS_UNKNOWN;
constexpr RunActionStatus RunActionStatus_MAX = RAS_FRAME_NOT_OPEN;
constexpr int RunActionStatus_ARRAYSIZE = RunActionStatus_MAX + 1;

KIAPI_IMPORTEXPORT const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RunActionStatus_descriptor();
template<typename T>
inline const std::string& RunActionStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RunActionStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RunActionStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RunActionStatus_descriptor(), enum_t_value);
}
inline bool RunActionStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RunActionStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RunActionStatus>(
    RunActionStatus_descriptor(), name, value);
}
enum CommitAction : int {
  CMA_UNKNOWN = 0,
  CMA_COMMIT = 1,
  CMA_DROP = 2,
  CommitAction_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CommitAction_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
KIAPI_IMPORTEXPORT bool CommitAction_IsValid(int value);
constexpr CommitAction CommitAction_MIN = CMA_UNKNOWN;
constexpr CommitAction CommitAction_MAX = CMA_DROP;
constexpr int CommitAction_ARRAYSIZE = CommitAction_MAX + 1;

KIAPI_IMPORTEXPORT const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CommitAction_descriptor();
template<typename T>
inline const std::string& CommitAction_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CommitAction>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CommitAction_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CommitAction_descriptor(), enum_t_value);
}
inline bool CommitAction_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CommitAction* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CommitAction>(
    CommitAction_descriptor(), name, value);
}
enum ItemStatusCode : int {
  ISC_UNKNOWN = 0,
  ISC_OK = 1,
  ISC_INVALID_TYPE = 2,
  ISC_EXISTING = 3,
  ISC_NONEXISTENT = 4,
  ISC_IMMUTABLE = 5,
  ISC_INVALID_DATA = 7,
  ItemStatusCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ItemStatusCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
KIAPI_IMPORTEXPORT bool ItemStatusCode_IsValid(int value);
constexpr ItemStatusCode ItemStatusCode_MIN = ISC_UNKNOWN;
constexpr ItemStatusCode ItemStatusCode_MAX = ISC_INVALID_DATA;
constexpr int ItemStatusCode_ARRAYSIZE = ItemStatusCode_MAX + 1;

KIAPI_IMPORTEXPORT const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ItemStatusCode_descriptor();
template<typename T>
inline const std::string& ItemStatusCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ItemStatusCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ItemStatusCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ItemStatusCode_descriptor(), enum_t_value);
}
inline bool ItemStatusCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ItemStatusCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ItemStatusCode>(
    ItemStatusCode_descriptor(), name, value);
}
enum ItemDeletionStatus : int {
  IDS_UNKNOWN = 0,
  IDS_OK = 1,
  IDS_NONEXISTENT = 2,
  IDS_IMMUTABLE = 3,
  ItemDeletionStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ItemDeletionStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
KIAPI_IMPORTEXPORT bool ItemDeletionStatus_IsValid(int value);
constexpr ItemDeletionStatus ItemDeletionStatus_MIN = IDS_UNKNOWN;
constexpr ItemDeletionStatus ItemDeletionStatus_MAX = IDS_IMMUTABLE;
constexpr int ItemDeletionStatus_ARRAYSIZE = ItemDeletionStatus_MAX + 1;

KIAPI_IMPORTEXPORT const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ItemDeletionStatus_descriptor();
template<typename T>
inline const std::string& ItemDeletionStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ItemDeletionStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ItemDeletionStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ItemDeletionStatus_descriptor(), enum_t_value);
}
inline bool ItemDeletionStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ItemDeletionStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ItemDeletionStatus>(
    ItemDeletionStatus_descriptor(), name, value);
}
enum BoundingBoxMode : int {
  BBM_UNKNOWN = 0,
  BBM_ITEM_ONLY = 1,
  BBM_ITEM_AND_CHILD_TEXT = 2,
  BoundingBoxMode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  BoundingBoxMode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
KIAPI_IMPORTEXPORT bool BoundingBoxMode_IsValid(int value);
constexpr BoundingBoxMode BoundingBoxMode_MIN = BBM_UNKNOWN;
constexpr BoundingBoxMode BoundingBoxMode_MAX = BBM_ITEM_AND_CHILD_TEXT;
constexpr int BoundingBoxMode_ARRAYSIZE = BoundingBoxMode_MAX + 1;

KIAPI_IMPORTEXPORT const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BoundingBoxMode_descriptor();
template<typename T>
inline const std::string& BoundingBoxMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BoundingBoxMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BoundingBoxMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BoundingBoxMode_descriptor(), enum_t_value);
}
inline bool BoundingBoxMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BoundingBoxMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BoundingBoxMode>(
    BoundingBoxMode_descriptor(), name, value);
}
enum HitTestResult : int {
  HTR_UNKNOWN = 0,
  HTR_NO_HIT = 1,
  HTR_HIT = 2,
  HitTestResult_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  HitTestResult_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
KIAPI_IMPORTEXPORT bool HitTestResult_IsValid(int value);
constexpr HitTestResult HitTestResult_MIN = HTR_UNKNOWN;
constexpr HitTestResult HitTestResult_MAX = HTR_HIT;
constexpr int HitTestResult_ARRAYSIZE = HitTestResult_MAX + 1;

KIAPI_IMPORTEXPORT const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* HitTestResult_descriptor();
template<typename T>
inline const std::string& HitTestResult_Name(T enum_t_value) {
  static_assert(::std::is_same<T, HitTestResult>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function HitTestResult_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    HitTestResult_descriptor(), enum_t_value);
}
inline bool HitTestResult_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, HitTestResult* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<HitTestResult>(
    HitTestResult_descriptor(), name, value);
}
// ===================================================================

class KIAPI_IMPORTEXPORT RefreshEditor final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kiapi.common.commands.RefreshEditor) */ {
 public:
  inline RefreshEditor() : RefreshEditor(nullptr) {}
  ~RefreshEditor() override;
  explicit constexpr RefreshEditor(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RefreshEditor(const RefreshEditor& from);
  RefreshEditor(RefreshEditor&& from) noexcept
    : RefreshEditor() {
    *this = ::std::move(from);
  }

  inline RefreshEditor& operator=(const RefreshEditor& from) {
    CopyFrom(from);
    return *this;
  }
  inline RefreshEditor& operator=(RefreshEditor&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RefreshEditor& default_instance() {
    return *internal_default_instance();
  }
  static inline const RefreshEditor* internal_default_instance() {
    return reinterpret_cast<const RefreshEditor*>(
               &_RefreshEditor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(RefreshEditor& a, RefreshEditor& b) {
    a.Swap(&b);
  }
  inline void Swap(RefreshEditor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RefreshEditor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RefreshEditor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RefreshEditor>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RefreshEditor& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RefreshEditor& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RefreshEditor* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kiapi.common.commands.RefreshEditor";
  }
  protected:
  explicit RefreshEditor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFrameFieldNumber = 1,
  };
  // .kiapi.common.types.FrameType frame = 1;
  void clear_frame();
  ::kiapi::common::types::FrameType frame() const;
  void set_frame(::kiapi::common::types::FrameType value);
  private:
  ::kiapi::common::types::FrameType _internal_frame() const;
  void _internal_set_frame(::kiapi::common::types::FrameType value);
  public:

  // @@protoc_insertion_point(class_scope:kiapi.common.commands.RefreshEditor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int frame_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2fcommands_2feditor_5fcommands_2eproto;
};
// -------------------------------------------------------------------

class KIAPI_IMPORTEXPORT GetOpenDocuments final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kiapi.common.commands.GetOpenDocuments) */ {
 public:
  inline GetOpenDocuments() : GetOpenDocuments(nullptr) {}
  ~GetOpenDocuments() override;
  explicit constexpr GetOpenDocuments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetOpenDocuments(const GetOpenDocuments& from);
  GetOpenDocuments(GetOpenDocuments&& from) noexcept
    : GetOpenDocuments() {
    *this = ::std::move(from);
  }

  inline GetOpenDocuments& operator=(const GetOpenDocuments& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetOpenDocuments& operator=(GetOpenDocuments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetOpenDocuments& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetOpenDocuments* internal_default_instance() {
    return reinterpret_cast<const GetOpenDocuments*>(
               &_GetOpenDocuments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(GetOpenDocuments& a, GetOpenDocuments& b) {
    a.Swap(&b);
  }
  inline void Swap(GetOpenDocuments* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetOpenDocuments* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetOpenDocuments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetOpenDocuments>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetOpenDocuments& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetOpenDocuments& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetOpenDocuments* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kiapi.common.commands.GetOpenDocuments";
  }
  protected:
  explicit GetOpenDocuments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
  };
  // .kiapi.common.types.DocumentType type = 1;
  void clear_type();
  ::kiapi::common::types::DocumentType type() const;
  void set_type(::kiapi::common::types::DocumentType value);
  private:
  ::kiapi::common::types::DocumentType _internal_type() const;
  void _internal_set_type(::kiapi::common::types::DocumentType value);
  public:

  // @@protoc_insertion_point(class_scope:kiapi.common.commands.GetOpenDocuments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2fcommands_2feditor_5fcommands_2eproto;
};
// -------------------------------------------------------------------

class KIAPI_IMPORTEXPORT GetOpenDocumentsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kiapi.common.commands.GetOpenDocumentsResponse) */ {
 public:
  inline GetOpenDocumentsResponse() : GetOpenDocumentsResponse(nullptr) {}
  ~GetOpenDocumentsResponse() override;
  explicit constexpr GetOpenDocumentsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetOpenDocumentsResponse(const GetOpenDocumentsResponse& from);
  GetOpenDocumentsResponse(GetOpenDocumentsResponse&& from) noexcept
    : GetOpenDocumentsResponse() {
    *this = ::std::move(from);
  }

  inline GetOpenDocumentsResponse& operator=(const GetOpenDocumentsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetOpenDocumentsResponse& operator=(GetOpenDocumentsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetOpenDocumentsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetOpenDocumentsResponse* internal_default_instance() {
    return reinterpret_cast<const GetOpenDocumentsResponse*>(
               &_GetOpenDocumentsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(GetOpenDocumentsResponse& a, GetOpenDocumentsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetOpenDocumentsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetOpenDocumentsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetOpenDocumentsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetOpenDocumentsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetOpenDocumentsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetOpenDocumentsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetOpenDocumentsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kiapi.common.commands.GetOpenDocumentsResponse";
  }
  protected:
  explicit GetOpenDocumentsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDocumentsFieldNumber = 1,
  };
  // repeated .kiapi.common.types.DocumentSpecifier documents = 1;
  int documents_size() const;
  private:
  int _internal_documents_size() const;
  public:
  void clear_documents();
  ::kiapi::common::types::DocumentSpecifier* mutable_documents(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::types::DocumentSpecifier >*
      mutable_documents();
  private:
  const ::kiapi::common::types::DocumentSpecifier& _internal_documents(int index) const;
  ::kiapi::common::types::DocumentSpecifier* _internal_add_documents();
  public:
  const ::kiapi::common::types::DocumentSpecifier& documents(int index) const;
  ::kiapi::common::types::DocumentSpecifier* add_documents();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::types::DocumentSpecifier >&
      documents() const;

  // @@protoc_insertion_point(class_scope:kiapi.common.commands.GetOpenDocumentsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::types::DocumentSpecifier > documents_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2fcommands_2feditor_5fcommands_2eproto;
};
// -------------------------------------------------------------------

class KIAPI_IMPORTEXPORT SaveDocument final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kiapi.common.commands.SaveDocument) */ {
 public:
  inline SaveDocument() : SaveDocument(nullptr) {}
  ~SaveDocument() override;
  explicit constexpr SaveDocument(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SaveDocument(const SaveDocument& from);
  SaveDocument(SaveDocument&& from) noexcept
    : SaveDocument() {
    *this = ::std::move(from);
  }

  inline SaveDocument& operator=(const SaveDocument& from) {
    CopyFrom(from);
    return *this;
  }
  inline SaveDocument& operator=(SaveDocument&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SaveDocument& default_instance() {
    return *internal_default_instance();
  }
  static inline const SaveDocument* internal_default_instance() {
    return reinterpret_cast<const SaveDocument*>(
               &_SaveDocument_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SaveDocument& a, SaveDocument& b) {
    a.Swap(&b);
  }
  inline void Swap(SaveDocument* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SaveDocument* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SaveDocument* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SaveDocument>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SaveDocument& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SaveDocument& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SaveDocument* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kiapi.common.commands.SaveDocument";
  }
  protected:
  explicit SaveDocument(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDocumentFieldNumber = 1,
  };
  // .kiapi.common.types.DocumentSpecifier document = 1;
  bool has_document() const;
  private:
  bool _internal_has_document() const;
  public:
  void clear_document();
  const ::kiapi::common::types::DocumentSpecifier& document() const;
  PROTOBUF_NODISCARD ::kiapi::common::types::DocumentSpecifier* release_document();
  ::kiapi::common::types::DocumentSpecifier* mutable_document();
  void set_allocated_document(::kiapi::common::types::DocumentSpecifier* document);
  private:
  const ::kiapi::common::types::DocumentSpecifier& _internal_document() const;
  ::kiapi::common::types::DocumentSpecifier* _internal_mutable_document();
  public:
  void unsafe_arena_set_allocated_document(
      ::kiapi::common::types::DocumentSpecifier* document);
  ::kiapi::common::types::DocumentSpecifier* unsafe_arena_release_document();

  // @@protoc_insertion_point(class_scope:kiapi.common.commands.SaveDocument)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::kiapi::common::types::DocumentSpecifier* document_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2fcommands_2feditor_5fcommands_2eproto;
};
// -------------------------------------------------------------------

class KIAPI_IMPORTEXPORT SaveOptions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kiapi.common.commands.SaveOptions) */ {
 public:
  inline SaveOptions() : SaveOptions(nullptr) {}
  ~SaveOptions() override;
  explicit constexpr SaveOptions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SaveOptions(const SaveOptions& from);
  SaveOptions(SaveOptions&& from) noexcept
    : SaveOptions() {
    *this = ::std::move(from);
  }

  inline SaveOptions& operator=(const SaveOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline SaveOptions& operator=(SaveOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SaveOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const SaveOptions* internal_default_instance() {
    return reinterpret_cast<const SaveOptions*>(
               &_SaveOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SaveOptions& a, SaveOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(SaveOptions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SaveOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SaveOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SaveOptions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SaveOptions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SaveOptions& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SaveOptions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kiapi.common.commands.SaveOptions";
  }
  protected:
  explicit SaveOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOverwriteFieldNumber = 1,
    kIncludeProjectFieldNumber = 2,
  };
  // bool overwrite = 1;
  void clear_overwrite();
  bool overwrite() const;
  void set_overwrite(bool value);
  private:
  bool _internal_overwrite() const;
  void _internal_set_overwrite(bool value);
  public:

  // bool include_project = 2;
  void clear_include_project();
  bool include_project() const;
  void set_include_project(bool value);
  private:
  bool _internal_include_project() const;
  void _internal_set_include_project(bool value);
  public:

  // @@protoc_insertion_point(class_scope:kiapi.common.commands.SaveOptions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool overwrite_;
  bool include_project_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2fcommands_2feditor_5fcommands_2eproto;
};
// -------------------------------------------------------------------

class KIAPI_IMPORTEXPORT SaveCopyOfDocument final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kiapi.common.commands.SaveCopyOfDocument) */ {
 public:
  inline SaveCopyOfDocument() : SaveCopyOfDocument(nullptr) {}
  ~SaveCopyOfDocument() override;
  explicit constexpr SaveCopyOfDocument(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SaveCopyOfDocument(const SaveCopyOfDocument& from);
  SaveCopyOfDocument(SaveCopyOfDocument&& from) noexcept
    : SaveCopyOfDocument() {
    *this = ::std::move(from);
  }

  inline SaveCopyOfDocument& operator=(const SaveCopyOfDocument& from) {
    CopyFrom(from);
    return *this;
  }
  inline SaveCopyOfDocument& operator=(SaveCopyOfDocument&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SaveCopyOfDocument& default_instance() {
    return *internal_default_instance();
  }
  static inline const SaveCopyOfDocument* internal_default_instance() {
    return reinterpret_cast<const SaveCopyOfDocument*>(
               &_SaveCopyOfDocument_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SaveCopyOfDocument& a, SaveCopyOfDocument& b) {
    a.Swap(&b);
  }
  inline void Swap(SaveCopyOfDocument* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SaveCopyOfDocument* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SaveCopyOfDocument* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SaveCopyOfDocument>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SaveCopyOfDocument& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SaveCopyOfDocument& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SaveCopyOfDocument* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kiapi.common.commands.SaveCopyOfDocument";
  }
  protected:
  explicit SaveCopyOfDocument(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 2,
    kDocumentFieldNumber = 1,
    kOptionsFieldNumber = 3,
  };
  // string path = 2;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // .kiapi.common.types.DocumentSpecifier document = 1;
  bool has_document() const;
  private:
  bool _internal_has_document() const;
  public:
  void clear_document();
  const ::kiapi::common::types::DocumentSpecifier& document() const;
  PROTOBUF_NODISCARD ::kiapi::common::types::DocumentSpecifier* release_document();
  ::kiapi::common::types::DocumentSpecifier* mutable_document();
  void set_allocated_document(::kiapi::common::types::DocumentSpecifier* document);
  private:
  const ::kiapi::common::types::DocumentSpecifier& _internal_document() const;
  ::kiapi::common::types::DocumentSpecifier* _internal_mutable_document();
  public:
  void unsafe_arena_set_allocated_document(
      ::kiapi::common::types::DocumentSpecifier* document);
  ::kiapi::common::types::DocumentSpecifier* unsafe_arena_release_document();

  // .kiapi.common.commands.SaveOptions options = 3;
  bool has_options() const;
  private:
  bool _internal_has_options() const;
  public:
  void clear_options();
  const ::kiapi::common::commands::SaveOptions& options() const;
  PROTOBUF_NODISCARD ::kiapi::common::commands::SaveOptions* release_options();
  ::kiapi::common::commands::SaveOptions* mutable_options();
  void set_allocated_options(::kiapi::common::commands::SaveOptions* options);
  private:
  const ::kiapi::common::commands::SaveOptions& _internal_options() const;
  ::kiapi::common::commands::SaveOptions* _internal_mutable_options();
  public:
  void unsafe_arena_set_allocated_options(
      ::kiapi::common::commands::SaveOptions* options);
  ::kiapi::common::commands::SaveOptions* unsafe_arena_release_options();

  // @@protoc_insertion_point(class_scope:kiapi.common.commands.SaveCopyOfDocument)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  ::kiapi::common::types::DocumentSpecifier* document_;
  ::kiapi::common::commands::SaveOptions* options_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2fcommands_2feditor_5fcommands_2eproto;
};
// -------------------------------------------------------------------

class KIAPI_IMPORTEXPORT RevertDocument final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kiapi.common.commands.RevertDocument) */ {
 public:
  inline RevertDocument() : RevertDocument(nullptr) {}
  ~RevertDocument() override;
  explicit constexpr RevertDocument(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RevertDocument(const RevertDocument& from);
  RevertDocument(RevertDocument&& from) noexcept
    : RevertDocument() {
    *this = ::std::move(from);
  }

  inline RevertDocument& operator=(const RevertDocument& from) {
    CopyFrom(from);
    return *this;
  }
  inline RevertDocument& operator=(RevertDocument&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RevertDocument& default_instance() {
    return *internal_default_instance();
  }
  static inline const RevertDocument* internal_default_instance() {
    return reinterpret_cast<const RevertDocument*>(
               &_RevertDocument_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(RevertDocument& a, RevertDocument& b) {
    a.Swap(&b);
  }
  inline void Swap(RevertDocument* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RevertDocument* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RevertDocument* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RevertDocument>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RevertDocument& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RevertDocument& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RevertDocument* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kiapi.common.commands.RevertDocument";
  }
  protected:
  explicit RevertDocument(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDocumentFieldNumber = 1,
  };
  // .kiapi.common.types.DocumentSpecifier document = 1;
  bool has_document() const;
  private:
  bool _internal_has_document() const;
  public:
  void clear_document();
  const ::kiapi::common::types::DocumentSpecifier& document() const;
  PROTOBUF_NODISCARD ::kiapi::common::types::DocumentSpecifier* release_document();
  ::kiapi::common::types::DocumentSpecifier* mutable_document();
  void set_allocated_document(::kiapi::common::types::DocumentSpecifier* document);
  private:
  const ::kiapi::common::types::DocumentSpecifier& _internal_document() const;
  ::kiapi::common::types::DocumentSpecifier* _internal_mutable_document();
  public:
  void unsafe_arena_set_allocated_document(
      ::kiapi::common::types::DocumentSpecifier* document);
  ::kiapi::common::types::DocumentSpecifier* unsafe_arena_release_document();

  // @@protoc_insertion_point(class_scope:kiapi.common.commands.RevertDocument)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::kiapi::common::types::DocumentSpecifier* document_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2fcommands_2feditor_5fcommands_2eproto;
};
// -------------------------------------------------------------------

class KIAPI_IMPORTEXPORT RunAction final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kiapi.common.commands.RunAction) */ {
 public:
  inline RunAction() : RunAction(nullptr) {}
  ~RunAction() override;
  explicit constexpr RunAction(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RunAction(const RunAction& from);
  RunAction(RunAction&& from) noexcept
    : RunAction() {
    *this = ::std::move(from);
  }

  inline RunAction& operator=(const RunAction& from) {
    CopyFrom(from);
    return *this;
  }
  inline RunAction& operator=(RunAction&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RunAction& default_instance() {
    return *internal_default_instance();
  }
  static inline const RunAction* internal_default_instance() {
    return reinterpret_cast<const RunAction*>(
               &_RunAction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(RunAction& a, RunAction& b) {
    a.Swap(&b);
  }
  inline void Swap(RunAction* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RunAction* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RunAction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RunAction>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RunAction& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RunAction& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RunAction* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kiapi.common.commands.RunAction";
  }
  protected:
  explicit RunAction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActionFieldNumber = 1,
  };
  // string action = 1;
  void clear_action();
  const std::string& action() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_action(ArgT0&& arg0, ArgT... args);
  std::string* mutable_action();
  PROTOBUF_NODISCARD std::string* release_action();
  void set_allocated_action(std::string* action);
  private:
  const std::string& _internal_action() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_action(const std::string& value);
  std::string* _internal_mutable_action();
  public:

  // @@protoc_insertion_point(class_scope:kiapi.common.commands.RunAction)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr action_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2fcommands_2feditor_5fcommands_2eproto;
};
// -------------------------------------------------------------------

class KIAPI_IMPORTEXPORT RunActionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kiapi.common.commands.RunActionResponse) */ {
 public:
  inline RunActionResponse() : RunActionResponse(nullptr) {}
  ~RunActionResponse() override;
  explicit constexpr RunActionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RunActionResponse(const RunActionResponse& from);
  RunActionResponse(RunActionResponse&& from) noexcept
    : RunActionResponse() {
    *this = ::std::move(from);
  }

  inline RunActionResponse& operator=(const RunActionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RunActionResponse& operator=(RunActionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RunActionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RunActionResponse* internal_default_instance() {
    return reinterpret_cast<const RunActionResponse*>(
               &_RunActionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(RunActionResponse& a, RunActionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RunActionResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RunActionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RunActionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RunActionResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RunActionResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RunActionResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RunActionResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kiapi.common.commands.RunActionResponse";
  }
  protected:
  explicit RunActionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // .kiapi.common.commands.RunActionStatus status = 1;
  void clear_status();
  ::kiapi::common::commands::RunActionStatus status() const;
  void set_status(::kiapi::common::commands::RunActionStatus value);
  private:
  ::kiapi::common::commands::RunActionStatus _internal_status() const;
  void _internal_set_status(::kiapi::common::commands::RunActionStatus value);
  public:

  // @@protoc_insertion_point(class_scope:kiapi.common.commands.RunActionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2fcommands_2feditor_5fcommands_2eproto;
};
// -------------------------------------------------------------------

class KIAPI_IMPORTEXPORT BeginCommit final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:kiapi.common.commands.BeginCommit) */ {
 public:
  inline BeginCommit() : BeginCommit(nullptr) {}
  explicit constexpr BeginCommit(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BeginCommit(const BeginCommit& from);
  BeginCommit(BeginCommit&& from) noexcept
    : BeginCommit() {
    *this = ::std::move(from);
  }

  inline BeginCommit& operator=(const BeginCommit& from) {
    CopyFrom(from);
    return *this;
  }
  inline BeginCommit& operator=(BeginCommit&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BeginCommit& default_instance() {
    return *internal_default_instance();
  }
  static inline const BeginCommit* internal_default_instance() {
    return reinterpret_cast<const BeginCommit*>(
               &_BeginCommit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(BeginCommit& a, BeginCommit& b) {
    a.Swap(&b);
  }
  inline void Swap(BeginCommit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BeginCommit* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BeginCommit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BeginCommit>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const BeginCommit& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const BeginCommit& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kiapi.common.commands.BeginCommit";
  }
  protected:
  explicit BeginCommit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:kiapi.common.commands.BeginCommit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2fcommands_2feditor_5fcommands_2eproto;
};
// -------------------------------------------------------------------

class KIAPI_IMPORTEXPORT BeginCommitResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kiapi.common.commands.BeginCommitResponse) */ {
 public:
  inline BeginCommitResponse() : BeginCommitResponse(nullptr) {}
  ~BeginCommitResponse() override;
  explicit constexpr BeginCommitResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BeginCommitResponse(const BeginCommitResponse& from);
  BeginCommitResponse(BeginCommitResponse&& from) noexcept
    : BeginCommitResponse() {
    *this = ::std::move(from);
  }

  inline BeginCommitResponse& operator=(const BeginCommitResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline BeginCommitResponse& operator=(BeginCommitResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BeginCommitResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const BeginCommitResponse* internal_default_instance() {
    return reinterpret_cast<const BeginCommitResponse*>(
               &_BeginCommitResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(BeginCommitResponse& a, BeginCommitResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(BeginCommitResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BeginCommitResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BeginCommitResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BeginCommitResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BeginCommitResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BeginCommitResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BeginCommitResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kiapi.common.commands.BeginCommitResponse";
  }
  protected:
  explicit BeginCommitResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // .kiapi.common.types.KIID id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const ::kiapi::common::types::KIID& id() const;
  PROTOBUF_NODISCARD ::kiapi::common::types::KIID* release_id();
  ::kiapi::common::types::KIID* mutable_id();
  void set_allocated_id(::kiapi::common::types::KIID* id);
  private:
  const ::kiapi::common::types::KIID& _internal_id() const;
  ::kiapi::common::types::KIID* _internal_mutable_id();
  public:
  void unsafe_arena_set_allocated_id(
      ::kiapi::common::types::KIID* id);
  ::kiapi::common::types::KIID* unsafe_arena_release_id();

  // @@protoc_insertion_point(class_scope:kiapi.common.commands.BeginCommitResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::kiapi::common::types::KIID* id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2fcommands_2feditor_5fcommands_2eproto;
};
// -------------------------------------------------------------------

class KIAPI_IMPORTEXPORT EndCommit final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kiapi.common.commands.EndCommit) */ {
 public:
  inline EndCommit() : EndCommit(nullptr) {}
  ~EndCommit() override;
  explicit constexpr EndCommit(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EndCommit(const EndCommit& from);
  EndCommit(EndCommit&& from) noexcept
    : EndCommit() {
    *this = ::std::move(from);
  }

  inline EndCommit& operator=(const EndCommit& from) {
    CopyFrom(from);
    return *this;
  }
  inline EndCommit& operator=(EndCommit&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EndCommit& default_instance() {
    return *internal_default_instance();
  }
  static inline const EndCommit* internal_default_instance() {
    return reinterpret_cast<const EndCommit*>(
               &_EndCommit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(EndCommit& a, EndCommit& b) {
    a.Swap(&b);
  }
  inline void Swap(EndCommit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EndCommit* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EndCommit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EndCommit>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EndCommit& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const EndCommit& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EndCommit* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kiapi.common.commands.EndCommit";
  }
  protected:
  explicit EndCommit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 3,
    kIdFieldNumber = 1,
    kActionFieldNumber = 2,
  };
  // string message = 3;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .kiapi.common.types.KIID id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const ::kiapi::common::types::KIID& id() const;
  PROTOBUF_NODISCARD ::kiapi::common::types::KIID* release_id();
  ::kiapi::common::types::KIID* mutable_id();
  void set_allocated_id(::kiapi::common::types::KIID* id);
  private:
  const ::kiapi::common::types::KIID& _internal_id() const;
  ::kiapi::common::types::KIID* _internal_mutable_id();
  public:
  void unsafe_arena_set_allocated_id(
      ::kiapi::common::types::KIID* id);
  ::kiapi::common::types::KIID* unsafe_arena_release_id();

  // .kiapi.common.commands.CommitAction action = 2;
  void clear_action();
  ::kiapi::common::commands::CommitAction action() const;
  void set_action(::kiapi::common::commands::CommitAction value);
  private:
  ::kiapi::common::commands::CommitAction _internal_action() const;
  void _internal_set_action(::kiapi::common::commands::CommitAction value);
  public:

  // @@protoc_insertion_point(class_scope:kiapi.common.commands.EndCommit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  ::kiapi::common::types::KIID* id_;
  int action_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2fcommands_2feditor_5fcommands_2eproto;
};
// -------------------------------------------------------------------

class KIAPI_IMPORTEXPORT EndCommitResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:kiapi.common.commands.EndCommitResponse) */ {
 public:
  inline EndCommitResponse() : EndCommitResponse(nullptr) {}
  explicit constexpr EndCommitResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EndCommitResponse(const EndCommitResponse& from);
  EndCommitResponse(EndCommitResponse&& from) noexcept
    : EndCommitResponse() {
    *this = ::std::move(from);
  }

  inline EndCommitResponse& operator=(const EndCommitResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline EndCommitResponse& operator=(EndCommitResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EndCommitResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const EndCommitResponse* internal_default_instance() {
    return reinterpret_cast<const EndCommitResponse*>(
               &_EndCommitResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(EndCommitResponse& a, EndCommitResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(EndCommitResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EndCommitResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EndCommitResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EndCommitResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const EndCommitResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const EndCommitResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kiapi.common.commands.EndCommitResponse";
  }
  protected:
  explicit EndCommitResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:kiapi.common.commands.EndCommitResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2fcommands_2feditor_5fcommands_2eproto;
};
// -------------------------------------------------------------------

class KIAPI_IMPORTEXPORT CreateItems final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kiapi.common.commands.CreateItems) */ {
 public:
  inline CreateItems() : CreateItems(nullptr) {}
  ~CreateItems() override;
  explicit constexpr CreateItems(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateItems(const CreateItems& from);
  CreateItems(CreateItems&& from) noexcept
    : CreateItems() {
    *this = ::std::move(from);
  }

  inline CreateItems& operator=(const CreateItems& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateItems& operator=(CreateItems&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateItems& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateItems* internal_default_instance() {
    return reinterpret_cast<const CreateItems*>(
               &_CreateItems_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(CreateItems& a, CreateItems& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateItems* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateItems* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateItems* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateItems>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateItems& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateItems& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateItems* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kiapi.common.commands.CreateItems";
  }
  protected:
  explicit CreateItems(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 2,
    kHeaderFieldNumber = 1,
    kContainerFieldNumber = 3,
  };
  // repeated .google.protobuf.Any items = 2;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::PROTOBUF_NAMESPACE_ID::Any* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Any >*
      mutable_items();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Any& _internal_items(int index) const;
  ::PROTOBUF_NAMESPACE_ID::Any* _internal_add_items();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Any& items(int index) const;
  ::PROTOBUF_NAMESPACE_ID::Any* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Any >&
      items() const;

  // .kiapi.common.types.ItemHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::kiapi::common::types::ItemHeader& header() const;
  PROTOBUF_NODISCARD ::kiapi::common::types::ItemHeader* release_header();
  ::kiapi::common::types::ItemHeader* mutable_header();
  void set_allocated_header(::kiapi::common::types::ItemHeader* header);
  private:
  const ::kiapi::common::types::ItemHeader& _internal_header() const;
  ::kiapi::common::types::ItemHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::kiapi::common::types::ItemHeader* header);
  ::kiapi::common::types::ItemHeader* unsafe_arena_release_header();

  // .kiapi.common.types.KIID container = 3;
  bool has_container() const;
  private:
  bool _internal_has_container() const;
  public:
  void clear_container();
  const ::kiapi::common::types::KIID& container() const;
  PROTOBUF_NODISCARD ::kiapi::common::types::KIID* release_container();
  ::kiapi::common::types::KIID* mutable_container();
  void set_allocated_container(::kiapi::common::types::KIID* container);
  private:
  const ::kiapi::common::types::KIID& _internal_container() const;
  ::kiapi::common::types::KIID* _internal_mutable_container();
  public:
  void unsafe_arena_set_allocated_container(
      ::kiapi::common::types::KIID* container);
  ::kiapi::common::types::KIID* unsafe_arena_release_container();

  // @@protoc_insertion_point(class_scope:kiapi.common.commands.CreateItems)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Any > items_;
  ::kiapi::common::types::ItemHeader* header_;
  ::kiapi::common::types::KIID* container_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2fcommands_2feditor_5fcommands_2eproto;
};
// -------------------------------------------------------------------

class KIAPI_IMPORTEXPORT ItemStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kiapi.common.commands.ItemStatus) */ {
 public:
  inline ItemStatus() : ItemStatus(nullptr) {}
  ~ItemStatus() override;
  explicit constexpr ItemStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ItemStatus(const ItemStatus& from);
  ItemStatus(ItemStatus&& from) noexcept
    : ItemStatus() {
    *this = ::std::move(from);
  }

  inline ItemStatus& operator=(const ItemStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline ItemStatus& operator=(ItemStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ItemStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const ItemStatus* internal_default_instance() {
    return reinterpret_cast<const ItemStatus*>(
               &_ItemStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ItemStatus& a, ItemStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(ItemStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ItemStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ItemStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ItemStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ItemStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ItemStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ItemStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kiapi.common.commands.ItemStatus";
  }
  protected:
  explicit ItemStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorMessageFieldNumber = 2,
    kCodeFieldNumber = 1,
  };
  // string error_message = 2;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // .kiapi.common.commands.ItemStatusCode code = 1;
  void clear_code();
  ::kiapi::common::commands::ItemStatusCode code() const;
  void set_code(::kiapi::common::commands::ItemStatusCode value);
  private:
  ::kiapi::common::commands::ItemStatusCode _internal_code() const;
  void _internal_set_code(::kiapi::common::commands::ItemStatusCode value);
  public:

  // @@protoc_insertion_point(class_scope:kiapi.common.commands.ItemStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
  int code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2fcommands_2feditor_5fcommands_2eproto;
};
// -------------------------------------------------------------------

class KIAPI_IMPORTEXPORT ItemCreationResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kiapi.common.commands.ItemCreationResult) */ {
 public:
  inline ItemCreationResult() : ItemCreationResult(nullptr) {}
  ~ItemCreationResult() override;
  explicit constexpr ItemCreationResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ItemCreationResult(const ItemCreationResult& from);
  ItemCreationResult(ItemCreationResult&& from) noexcept
    : ItemCreationResult() {
    *this = ::std::move(from);
  }

  inline ItemCreationResult& operator=(const ItemCreationResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline ItemCreationResult& operator=(ItemCreationResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ItemCreationResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const ItemCreationResult* internal_default_instance() {
    return reinterpret_cast<const ItemCreationResult*>(
               &_ItemCreationResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ItemCreationResult& a, ItemCreationResult& b) {
    a.Swap(&b);
  }
  inline void Swap(ItemCreationResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ItemCreationResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ItemCreationResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ItemCreationResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ItemCreationResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ItemCreationResult& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ItemCreationResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kiapi.common.commands.ItemCreationResult";
  }
  protected:
  explicit ItemCreationResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
    kItemFieldNumber = 2,
  };
  // .kiapi.common.commands.ItemStatus status = 1;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::kiapi::common::commands::ItemStatus& status() const;
  PROTOBUF_NODISCARD ::kiapi::common::commands::ItemStatus* release_status();
  ::kiapi::common::commands::ItemStatus* mutable_status();
  void set_allocated_status(::kiapi::common::commands::ItemStatus* status);
  private:
  const ::kiapi::common::commands::ItemStatus& _internal_status() const;
  ::kiapi::common::commands::ItemStatus* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::kiapi::common::commands::ItemStatus* status);
  ::kiapi::common::commands::ItemStatus* unsafe_arena_release_status();

  // .google.protobuf.Any item = 2;
  bool has_item() const;
  private:
  bool _internal_has_item() const;
  public:
  void clear_item();
  const ::PROTOBUF_NAMESPACE_ID::Any& item() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Any* release_item();
  ::PROTOBUF_NAMESPACE_ID::Any* mutable_item();
  void set_allocated_item(::PROTOBUF_NAMESPACE_ID::Any* item);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Any& _internal_item() const;
  ::PROTOBUF_NAMESPACE_ID::Any* _internal_mutable_item();
  public:
  void unsafe_arena_set_allocated_item(
      ::PROTOBUF_NAMESPACE_ID::Any* item);
  ::PROTOBUF_NAMESPACE_ID::Any* unsafe_arena_release_item();

  // @@protoc_insertion_point(class_scope:kiapi.common.commands.ItemCreationResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::kiapi::common::commands::ItemStatus* status_;
  ::PROTOBUF_NAMESPACE_ID::Any* item_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2fcommands_2feditor_5fcommands_2eproto;
};
// -------------------------------------------------------------------

class KIAPI_IMPORTEXPORT CreateItemsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kiapi.common.commands.CreateItemsResponse) */ {
 public:
  inline CreateItemsResponse() : CreateItemsResponse(nullptr) {}
  ~CreateItemsResponse() override;
  explicit constexpr CreateItemsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateItemsResponse(const CreateItemsResponse& from);
  CreateItemsResponse(CreateItemsResponse&& from) noexcept
    : CreateItemsResponse() {
    *this = ::std::move(from);
  }

  inline CreateItemsResponse& operator=(const CreateItemsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateItemsResponse& operator=(CreateItemsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateItemsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateItemsResponse* internal_default_instance() {
    return reinterpret_cast<const CreateItemsResponse*>(
               &_CreateItemsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(CreateItemsResponse& a, CreateItemsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateItemsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateItemsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateItemsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateItemsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateItemsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateItemsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateItemsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kiapi.common.commands.CreateItemsResponse";
  }
  protected:
  explicit CreateItemsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCreatedItemsFieldNumber = 3,
    kHeaderFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // repeated .kiapi.common.commands.ItemCreationResult created_items = 3;
  int created_items_size() const;
  private:
  int _internal_created_items_size() const;
  public:
  void clear_created_items();
  ::kiapi::common::commands::ItemCreationResult* mutable_created_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::commands::ItemCreationResult >*
      mutable_created_items();
  private:
  const ::kiapi::common::commands::ItemCreationResult& _internal_created_items(int index) const;
  ::kiapi::common::commands::ItemCreationResult* _internal_add_created_items();
  public:
  const ::kiapi::common::commands::ItemCreationResult& created_items(int index) const;
  ::kiapi::common::commands::ItemCreationResult* add_created_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::commands::ItemCreationResult >&
      created_items() const;

  // .kiapi.common.types.ItemHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::kiapi::common::types::ItemHeader& header() const;
  PROTOBUF_NODISCARD ::kiapi::common::types::ItemHeader* release_header();
  ::kiapi::common::types::ItemHeader* mutable_header();
  void set_allocated_header(::kiapi::common::types::ItemHeader* header);
  private:
  const ::kiapi::common::types::ItemHeader& _internal_header() const;
  ::kiapi::common::types::ItemHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::kiapi::common::types::ItemHeader* header);
  ::kiapi::common::types::ItemHeader* unsafe_arena_release_header();

  // .kiapi.common.types.ItemRequestStatus status = 2;
  void clear_status();
  ::kiapi::common::types::ItemRequestStatus status() const;
  void set_status(::kiapi::common::types::ItemRequestStatus value);
  private:
  ::kiapi::common::types::ItemRequestStatus _internal_status() const;
  void _internal_set_status(::kiapi::common::types::ItemRequestStatus value);
  public:

  // @@protoc_insertion_point(class_scope:kiapi.common.commands.CreateItemsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::commands::ItemCreationResult > created_items_;
  ::kiapi::common::types::ItemHeader* header_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2fcommands_2feditor_5fcommands_2eproto;
};
// -------------------------------------------------------------------

class KIAPI_IMPORTEXPORT GetItems final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kiapi.common.commands.GetItems) */ {
 public:
  inline GetItems() : GetItems(nullptr) {}
  ~GetItems() override;
  explicit constexpr GetItems(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetItems(const GetItems& from);
  GetItems(GetItems&& from) noexcept
    : GetItems() {
    *this = ::std::move(from);
  }

  inline GetItems& operator=(const GetItems& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetItems& operator=(GetItems&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetItems& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetItems* internal_default_instance() {
    return reinterpret_cast<const GetItems*>(
               &_GetItems_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(GetItems& a, GetItems& b) {
    a.Swap(&b);
  }
  inline void Swap(GetItems* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetItems* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetItems* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetItems>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetItems& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetItems& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetItems* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kiapi.common.commands.GetItems";
  }
  protected:
  explicit GetItems(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypesFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // repeated .kiapi.common.types.KiCadObjectType types = 2;
  int types_size() const;
  private:
  int _internal_types_size() const;
  public:
  void clear_types();
  private:
  ::kiapi::common::types::KiCadObjectType _internal_types(int index) const;
  void _internal_add_types(::kiapi::common::types::KiCadObjectType value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_types();
  public:
  ::kiapi::common::types::KiCadObjectType types(int index) const;
  void set_types(int index, ::kiapi::common::types::KiCadObjectType value);
  void add_types(::kiapi::common::types::KiCadObjectType value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& types() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_types();

  // .kiapi.common.types.ItemHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::kiapi::common::types::ItemHeader& header() const;
  PROTOBUF_NODISCARD ::kiapi::common::types::ItemHeader* release_header();
  ::kiapi::common::types::ItemHeader* mutable_header();
  void set_allocated_header(::kiapi::common::types::ItemHeader* header);
  private:
  const ::kiapi::common::types::ItemHeader& _internal_header() const;
  ::kiapi::common::types::ItemHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::kiapi::common::types::ItemHeader* header);
  ::kiapi::common::types::ItemHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:kiapi.common.commands.GetItems)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> types_;
  mutable std::atomic<int> _types_cached_byte_size_;
  ::kiapi::common::types::ItemHeader* header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2fcommands_2feditor_5fcommands_2eproto;
};
// -------------------------------------------------------------------

class KIAPI_IMPORTEXPORT GetItemsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kiapi.common.commands.GetItemsResponse) */ {
 public:
  inline GetItemsResponse() : GetItemsResponse(nullptr) {}
  ~GetItemsResponse() override;
  explicit constexpr GetItemsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetItemsResponse(const GetItemsResponse& from);
  GetItemsResponse(GetItemsResponse&& from) noexcept
    : GetItemsResponse() {
    *this = ::std::move(from);
  }

  inline GetItemsResponse& operator=(const GetItemsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetItemsResponse& operator=(GetItemsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetItemsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetItemsResponse* internal_default_instance() {
    return reinterpret_cast<const GetItemsResponse*>(
               &_GetItemsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(GetItemsResponse& a, GetItemsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetItemsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetItemsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetItemsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetItemsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetItemsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetItemsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetItemsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kiapi.common.commands.GetItemsResponse";
  }
  protected:
  explicit GetItemsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 3,
    kHeaderFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // repeated .google.protobuf.Any items = 3;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::PROTOBUF_NAMESPACE_ID::Any* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Any >*
      mutable_items();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Any& _internal_items(int index) const;
  ::PROTOBUF_NAMESPACE_ID::Any* _internal_add_items();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Any& items(int index) const;
  ::PROTOBUF_NAMESPACE_ID::Any* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Any >&
      items() const;

  // .kiapi.common.types.ItemHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::kiapi::common::types::ItemHeader& header() const;
  PROTOBUF_NODISCARD ::kiapi::common::types::ItemHeader* release_header();
  ::kiapi::common::types::ItemHeader* mutable_header();
  void set_allocated_header(::kiapi::common::types::ItemHeader* header);
  private:
  const ::kiapi::common::types::ItemHeader& _internal_header() const;
  ::kiapi::common::types::ItemHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::kiapi::common::types::ItemHeader* header);
  ::kiapi::common::types::ItemHeader* unsafe_arena_release_header();

  // .kiapi.common.types.ItemRequestStatus status = 2;
  void clear_status();
  ::kiapi::common::types::ItemRequestStatus status() const;
  void set_status(::kiapi::common::types::ItemRequestStatus value);
  private:
  ::kiapi::common::types::ItemRequestStatus _internal_status() const;
  void _internal_set_status(::kiapi::common::types::ItemRequestStatus value);
  public:

  // @@protoc_insertion_point(class_scope:kiapi.common.commands.GetItemsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Any > items_;
  ::kiapi::common::types::ItemHeader* header_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2fcommands_2feditor_5fcommands_2eproto;
};
// -------------------------------------------------------------------

class KIAPI_IMPORTEXPORT UpdateItems final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kiapi.common.commands.UpdateItems) */ {
 public:
  inline UpdateItems() : UpdateItems(nullptr) {}
  ~UpdateItems() override;
  explicit constexpr UpdateItems(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateItems(const UpdateItems& from);
  UpdateItems(UpdateItems&& from) noexcept
    : UpdateItems() {
    *this = ::std::move(from);
  }

  inline UpdateItems& operator=(const UpdateItems& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateItems& operator=(UpdateItems&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateItems& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateItems* internal_default_instance() {
    return reinterpret_cast<const UpdateItems*>(
               &_UpdateItems_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(UpdateItems& a, UpdateItems& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateItems* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateItems* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateItems* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateItems>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateItems& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateItems& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateItems* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kiapi.common.commands.UpdateItems";
  }
  protected:
  explicit UpdateItems(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // repeated .google.protobuf.Any items = 2;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::PROTOBUF_NAMESPACE_ID::Any* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Any >*
      mutable_items();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Any& _internal_items(int index) const;
  ::PROTOBUF_NAMESPACE_ID::Any* _internal_add_items();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Any& items(int index) const;
  ::PROTOBUF_NAMESPACE_ID::Any* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Any >&
      items() const;

  // .kiapi.common.types.ItemHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::kiapi::common::types::ItemHeader& header() const;
  PROTOBUF_NODISCARD ::kiapi::common::types::ItemHeader* release_header();
  ::kiapi::common::types::ItemHeader* mutable_header();
  void set_allocated_header(::kiapi::common::types::ItemHeader* header);
  private:
  const ::kiapi::common::types::ItemHeader& _internal_header() const;
  ::kiapi::common::types::ItemHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::kiapi::common::types::ItemHeader* header);
  ::kiapi::common::types::ItemHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:kiapi.common.commands.UpdateItems)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Any > items_;
  ::kiapi::common::types::ItemHeader* header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2fcommands_2feditor_5fcommands_2eproto;
};
// -------------------------------------------------------------------

class KIAPI_IMPORTEXPORT ItemUpdateResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kiapi.common.commands.ItemUpdateResult) */ {
 public:
  inline ItemUpdateResult() : ItemUpdateResult(nullptr) {}
  ~ItemUpdateResult() override;
  explicit constexpr ItemUpdateResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ItemUpdateResult(const ItemUpdateResult& from);
  ItemUpdateResult(ItemUpdateResult&& from) noexcept
    : ItemUpdateResult() {
    *this = ::std::move(from);
  }

  inline ItemUpdateResult& operator=(const ItemUpdateResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline ItemUpdateResult& operator=(ItemUpdateResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ItemUpdateResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const ItemUpdateResult* internal_default_instance() {
    return reinterpret_cast<const ItemUpdateResult*>(
               &_ItemUpdateResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(ItemUpdateResult& a, ItemUpdateResult& b) {
    a.Swap(&b);
  }
  inline void Swap(ItemUpdateResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ItemUpdateResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ItemUpdateResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ItemUpdateResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ItemUpdateResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ItemUpdateResult& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ItemUpdateResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kiapi.common.commands.ItemUpdateResult";
  }
  protected:
  explicit ItemUpdateResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
    kItemFieldNumber = 2,
  };
  // .kiapi.common.commands.ItemStatus status = 1;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::kiapi::common::commands::ItemStatus& status() const;
  PROTOBUF_NODISCARD ::kiapi::common::commands::ItemStatus* release_status();
  ::kiapi::common::commands::ItemStatus* mutable_status();
  void set_allocated_status(::kiapi::common::commands::ItemStatus* status);
  private:
  const ::kiapi::common::commands::ItemStatus& _internal_status() const;
  ::kiapi::common::commands::ItemStatus* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::kiapi::common::commands::ItemStatus* status);
  ::kiapi::common::commands::ItemStatus* unsafe_arena_release_status();

  // .google.protobuf.Any item = 2;
  bool has_item() const;
  private:
  bool _internal_has_item() const;
  public:
  void clear_item();
  const ::PROTOBUF_NAMESPACE_ID::Any& item() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Any* release_item();
  ::PROTOBUF_NAMESPACE_ID::Any* mutable_item();
  void set_allocated_item(::PROTOBUF_NAMESPACE_ID::Any* item);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Any& _internal_item() const;
  ::PROTOBUF_NAMESPACE_ID::Any* _internal_mutable_item();
  public:
  void unsafe_arena_set_allocated_item(
      ::PROTOBUF_NAMESPACE_ID::Any* item);
  ::PROTOBUF_NAMESPACE_ID::Any* unsafe_arena_release_item();

  // @@protoc_insertion_point(class_scope:kiapi.common.commands.ItemUpdateResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::kiapi::common::commands::ItemStatus* status_;
  ::PROTOBUF_NAMESPACE_ID::Any* item_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2fcommands_2feditor_5fcommands_2eproto;
};
// -------------------------------------------------------------------

class KIAPI_IMPORTEXPORT UpdateItemsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kiapi.common.commands.UpdateItemsResponse) */ {
 public:
  inline UpdateItemsResponse() : UpdateItemsResponse(nullptr) {}
  ~UpdateItemsResponse() override;
  explicit constexpr UpdateItemsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateItemsResponse(const UpdateItemsResponse& from);
  UpdateItemsResponse(UpdateItemsResponse&& from) noexcept
    : UpdateItemsResponse() {
    *this = ::std::move(from);
  }

  inline UpdateItemsResponse& operator=(const UpdateItemsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateItemsResponse& operator=(UpdateItemsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateItemsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateItemsResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateItemsResponse*>(
               &_UpdateItemsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(UpdateItemsResponse& a, UpdateItemsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateItemsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateItemsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateItemsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateItemsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateItemsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateItemsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateItemsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kiapi.common.commands.UpdateItemsResponse";
  }
  protected:
  explicit UpdateItemsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUpdatedItemsFieldNumber = 3,
    kHeaderFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // repeated .kiapi.common.commands.ItemUpdateResult updated_items = 3;
  int updated_items_size() const;
  private:
  int _internal_updated_items_size() const;
  public:
  void clear_updated_items();
  ::kiapi::common::commands::ItemUpdateResult* mutable_updated_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::commands::ItemUpdateResult >*
      mutable_updated_items();
  private:
  const ::kiapi::common::commands::ItemUpdateResult& _internal_updated_items(int index) const;
  ::kiapi::common::commands::ItemUpdateResult* _internal_add_updated_items();
  public:
  const ::kiapi::common::commands::ItemUpdateResult& updated_items(int index) const;
  ::kiapi::common::commands::ItemUpdateResult* add_updated_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::commands::ItemUpdateResult >&
      updated_items() const;

  // .kiapi.common.types.ItemHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::kiapi::common::types::ItemHeader& header() const;
  PROTOBUF_NODISCARD ::kiapi::common::types::ItemHeader* release_header();
  ::kiapi::common::types::ItemHeader* mutable_header();
  void set_allocated_header(::kiapi::common::types::ItemHeader* header);
  private:
  const ::kiapi::common::types::ItemHeader& _internal_header() const;
  ::kiapi::common::types::ItemHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::kiapi::common::types::ItemHeader* header);
  ::kiapi::common::types::ItemHeader* unsafe_arena_release_header();

  // .kiapi.common.types.ItemRequestStatus status = 2;
  void clear_status();
  ::kiapi::common::types::ItemRequestStatus status() const;
  void set_status(::kiapi::common::types::ItemRequestStatus value);
  private:
  ::kiapi::common::types::ItemRequestStatus _internal_status() const;
  void _internal_set_status(::kiapi::common::types::ItemRequestStatus value);
  public:

  // @@protoc_insertion_point(class_scope:kiapi.common.commands.UpdateItemsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::commands::ItemUpdateResult > updated_items_;
  ::kiapi::common::types::ItemHeader* header_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2fcommands_2feditor_5fcommands_2eproto;
};
// -------------------------------------------------------------------

class KIAPI_IMPORTEXPORT DeleteItems final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kiapi.common.commands.DeleteItems) */ {
 public:
  inline DeleteItems() : DeleteItems(nullptr) {}
  ~DeleteItems() override;
  explicit constexpr DeleteItems(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteItems(const DeleteItems& from);
  DeleteItems(DeleteItems&& from) noexcept
    : DeleteItems() {
    *this = ::std::move(from);
  }

  inline DeleteItems& operator=(const DeleteItems& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteItems& operator=(DeleteItems&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteItems& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteItems* internal_default_instance() {
    return reinterpret_cast<const DeleteItems*>(
               &_DeleteItems_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(DeleteItems& a, DeleteItems& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteItems* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteItems* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteItems* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteItems>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteItems& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteItems& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteItems* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kiapi.common.commands.DeleteItems";
  }
  protected:
  explicit DeleteItems(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemIdsFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // repeated .kiapi.common.types.KIID item_ids = 2;
  int item_ids_size() const;
  private:
  int _internal_item_ids_size() const;
  public:
  void clear_item_ids();
  ::kiapi::common::types::KIID* mutable_item_ids(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::types::KIID >*
      mutable_item_ids();
  private:
  const ::kiapi::common::types::KIID& _internal_item_ids(int index) const;
  ::kiapi::common::types::KIID* _internal_add_item_ids();
  public:
  const ::kiapi::common::types::KIID& item_ids(int index) const;
  ::kiapi::common::types::KIID* add_item_ids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::types::KIID >&
      item_ids() const;

  // .kiapi.common.types.ItemHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::kiapi::common::types::ItemHeader& header() const;
  PROTOBUF_NODISCARD ::kiapi::common::types::ItemHeader* release_header();
  ::kiapi::common::types::ItemHeader* mutable_header();
  void set_allocated_header(::kiapi::common::types::ItemHeader* header);
  private:
  const ::kiapi::common::types::ItemHeader& _internal_header() const;
  ::kiapi::common::types::ItemHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::kiapi::common::types::ItemHeader* header);
  ::kiapi::common::types::ItemHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:kiapi.common.commands.DeleteItems)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::types::KIID > item_ids_;
  ::kiapi::common::types::ItemHeader* header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2fcommands_2feditor_5fcommands_2eproto;
};
// -------------------------------------------------------------------

class KIAPI_IMPORTEXPORT ItemDeletionResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kiapi.common.commands.ItemDeletionResult) */ {
 public:
  inline ItemDeletionResult() : ItemDeletionResult(nullptr) {}
  ~ItemDeletionResult() override;
  explicit constexpr ItemDeletionResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ItemDeletionResult(const ItemDeletionResult& from);
  ItemDeletionResult(ItemDeletionResult&& from) noexcept
    : ItemDeletionResult() {
    *this = ::std::move(from);
  }

  inline ItemDeletionResult& operator=(const ItemDeletionResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline ItemDeletionResult& operator=(ItemDeletionResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ItemDeletionResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const ItemDeletionResult* internal_default_instance() {
    return reinterpret_cast<const ItemDeletionResult*>(
               &_ItemDeletionResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(ItemDeletionResult& a, ItemDeletionResult& b) {
    a.Swap(&b);
  }
  inline void Swap(ItemDeletionResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ItemDeletionResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ItemDeletionResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ItemDeletionResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ItemDeletionResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ItemDeletionResult& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ItemDeletionResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kiapi.common.commands.ItemDeletionResult";
  }
  protected:
  explicit ItemDeletionResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // .kiapi.common.types.KIID id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const ::kiapi::common::types::KIID& id() const;
  PROTOBUF_NODISCARD ::kiapi::common::types::KIID* release_id();
  ::kiapi::common::types::KIID* mutable_id();
  void set_allocated_id(::kiapi::common::types::KIID* id);
  private:
  const ::kiapi::common::types::KIID& _internal_id() const;
  ::kiapi::common::types::KIID* _internal_mutable_id();
  public:
  void unsafe_arena_set_allocated_id(
      ::kiapi::common::types::KIID* id);
  ::kiapi::common::types::KIID* unsafe_arena_release_id();

  // .kiapi.common.commands.ItemDeletionStatus status = 2;
  void clear_status();
  ::kiapi::common::commands::ItemDeletionStatus status() const;
  void set_status(::kiapi::common::commands::ItemDeletionStatus value);
  private:
  ::kiapi::common::commands::ItemDeletionStatus _internal_status() const;
  void _internal_set_status(::kiapi::common::commands::ItemDeletionStatus value);
  public:

  // @@protoc_insertion_point(class_scope:kiapi.common.commands.ItemDeletionResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::kiapi::common::types::KIID* id_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2fcommands_2feditor_5fcommands_2eproto;
};
// -------------------------------------------------------------------

class KIAPI_IMPORTEXPORT DeleteItemsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kiapi.common.commands.DeleteItemsResponse) */ {
 public:
  inline DeleteItemsResponse() : DeleteItemsResponse(nullptr) {}
  ~DeleteItemsResponse() override;
  explicit constexpr DeleteItemsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteItemsResponse(const DeleteItemsResponse& from);
  DeleteItemsResponse(DeleteItemsResponse&& from) noexcept
    : DeleteItemsResponse() {
    *this = ::std::move(from);
  }

  inline DeleteItemsResponse& operator=(const DeleteItemsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteItemsResponse& operator=(DeleteItemsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteItemsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteItemsResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteItemsResponse*>(
               &_DeleteItemsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(DeleteItemsResponse& a, DeleteItemsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteItemsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteItemsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteItemsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteItemsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteItemsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteItemsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteItemsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kiapi.common.commands.DeleteItemsResponse";
  }
  protected:
  explicit DeleteItemsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeletedItemsFieldNumber = 3,
    kHeaderFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // repeated .kiapi.common.commands.ItemDeletionResult deleted_items = 3;
  int deleted_items_size() const;
  private:
  int _internal_deleted_items_size() const;
  public:
  void clear_deleted_items();
  ::kiapi::common::commands::ItemDeletionResult* mutable_deleted_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::commands::ItemDeletionResult >*
      mutable_deleted_items();
  private:
  const ::kiapi::common::commands::ItemDeletionResult& _internal_deleted_items(int index) const;
  ::kiapi::common::commands::ItemDeletionResult* _internal_add_deleted_items();
  public:
  const ::kiapi::common::commands::ItemDeletionResult& deleted_items(int index) const;
  ::kiapi::common::commands::ItemDeletionResult* add_deleted_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::commands::ItemDeletionResult >&
      deleted_items() const;

  // .kiapi.common.types.ItemHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::kiapi::common::types::ItemHeader& header() const;
  PROTOBUF_NODISCARD ::kiapi::common::types::ItemHeader* release_header();
  ::kiapi::common::types::ItemHeader* mutable_header();
  void set_allocated_header(::kiapi::common::types::ItemHeader* header);
  private:
  const ::kiapi::common::types::ItemHeader& _internal_header() const;
  ::kiapi::common::types::ItemHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::kiapi::common::types::ItemHeader* header);
  ::kiapi::common::types::ItemHeader* unsafe_arena_release_header();

  // .kiapi.common.types.ItemRequestStatus status = 2;
  void clear_status();
  ::kiapi::common::types::ItemRequestStatus status() const;
  void set_status(::kiapi::common::types::ItemRequestStatus value);
  private:
  ::kiapi::common::types::ItemRequestStatus _internal_status() const;
  void _internal_set_status(::kiapi::common::types::ItemRequestStatus value);
  public:

  // @@protoc_insertion_point(class_scope:kiapi.common.commands.DeleteItemsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::commands::ItemDeletionResult > deleted_items_;
  ::kiapi::common::types::ItemHeader* header_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2fcommands_2feditor_5fcommands_2eproto;
};
// -------------------------------------------------------------------

class KIAPI_IMPORTEXPORT GetBoundingBox final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kiapi.common.commands.GetBoundingBox) */ {
 public:
  inline GetBoundingBox() : GetBoundingBox(nullptr) {}
  ~GetBoundingBox() override;
  explicit constexpr GetBoundingBox(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetBoundingBox(const GetBoundingBox& from);
  GetBoundingBox(GetBoundingBox&& from) noexcept
    : GetBoundingBox() {
    *this = ::std::move(from);
  }

  inline GetBoundingBox& operator=(const GetBoundingBox& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetBoundingBox& operator=(GetBoundingBox&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetBoundingBox& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetBoundingBox* internal_default_instance() {
    return reinterpret_cast<const GetBoundingBox*>(
               &_GetBoundingBox_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(GetBoundingBox& a, GetBoundingBox& b) {
    a.Swap(&b);
  }
  inline void Swap(GetBoundingBox* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetBoundingBox* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetBoundingBox* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetBoundingBox>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetBoundingBox& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetBoundingBox& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetBoundingBox* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kiapi.common.commands.GetBoundingBox";
  }
  protected:
  explicit GetBoundingBox(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 2,
    kHeaderFieldNumber = 1,
    kModeFieldNumber = 3,
  };
  // repeated .kiapi.common.types.KIID items = 2;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::kiapi::common::types::KIID* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::types::KIID >*
      mutable_items();
  private:
  const ::kiapi::common::types::KIID& _internal_items(int index) const;
  ::kiapi::common::types::KIID* _internal_add_items();
  public:
  const ::kiapi::common::types::KIID& items(int index) const;
  ::kiapi::common::types::KIID* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::types::KIID >&
      items() const;

  // .kiapi.common.types.ItemHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::kiapi::common::types::ItemHeader& header() const;
  PROTOBUF_NODISCARD ::kiapi::common::types::ItemHeader* release_header();
  ::kiapi::common::types::ItemHeader* mutable_header();
  void set_allocated_header(::kiapi::common::types::ItemHeader* header);
  private:
  const ::kiapi::common::types::ItemHeader& _internal_header() const;
  ::kiapi::common::types::ItemHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::kiapi::common::types::ItemHeader* header);
  ::kiapi::common::types::ItemHeader* unsafe_arena_release_header();

  // .kiapi.common.commands.BoundingBoxMode mode = 3;
  void clear_mode();
  ::kiapi::common::commands::BoundingBoxMode mode() const;
  void set_mode(::kiapi::common::commands::BoundingBoxMode value);
  private:
  ::kiapi::common::commands::BoundingBoxMode _internal_mode() const;
  void _internal_set_mode(::kiapi::common::commands::BoundingBoxMode value);
  public:

  // @@protoc_insertion_point(class_scope:kiapi.common.commands.GetBoundingBox)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::types::KIID > items_;
  ::kiapi::common::types::ItemHeader* header_;
  int mode_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2fcommands_2feditor_5fcommands_2eproto;
};
// -------------------------------------------------------------------

class KIAPI_IMPORTEXPORT GetBoundingBoxResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kiapi.common.commands.GetBoundingBoxResponse) */ {
 public:
  inline GetBoundingBoxResponse() : GetBoundingBoxResponse(nullptr) {}
  ~GetBoundingBoxResponse() override;
  explicit constexpr GetBoundingBoxResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetBoundingBoxResponse(const GetBoundingBoxResponse& from);
  GetBoundingBoxResponse(GetBoundingBoxResponse&& from) noexcept
    : GetBoundingBoxResponse() {
    *this = ::std::move(from);
  }

  inline GetBoundingBoxResponse& operator=(const GetBoundingBoxResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetBoundingBoxResponse& operator=(GetBoundingBoxResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetBoundingBoxResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetBoundingBoxResponse* internal_default_instance() {
    return reinterpret_cast<const GetBoundingBoxResponse*>(
               &_GetBoundingBoxResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(GetBoundingBoxResponse& a, GetBoundingBoxResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetBoundingBoxResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetBoundingBoxResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetBoundingBoxResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetBoundingBoxResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetBoundingBoxResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetBoundingBoxResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetBoundingBoxResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kiapi.common.commands.GetBoundingBoxResponse";
  }
  protected:
  explicit GetBoundingBoxResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
    kBoxesFieldNumber = 2,
  };
  // repeated .kiapi.common.types.KIID items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::kiapi::common::types::KIID* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::types::KIID >*
      mutable_items();
  private:
  const ::kiapi::common::types::KIID& _internal_items(int index) const;
  ::kiapi::common::types::KIID* _internal_add_items();
  public:
  const ::kiapi::common::types::KIID& items(int index) const;
  ::kiapi::common::types::KIID* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::types::KIID >&
      items() const;

  // repeated .kiapi.common.types.Box2 boxes = 2;
  int boxes_size() const;
  private:
  int _internal_boxes_size() const;
  public:
  void clear_boxes();
  ::kiapi::common::types::Box2* mutable_boxes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::types::Box2 >*
      mutable_boxes();
  private:
  const ::kiapi::common::types::Box2& _internal_boxes(int index) const;
  ::kiapi::common::types::Box2* _internal_add_boxes();
  public:
  const ::kiapi::common::types::Box2& boxes(int index) const;
  ::kiapi::common::types::Box2* add_boxes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::types::Box2 >&
      boxes() const;

  // @@protoc_insertion_point(class_scope:kiapi.common.commands.GetBoundingBoxResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::types::KIID > items_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::types::Box2 > boxes_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2fcommands_2feditor_5fcommands_2eproto;
};
// -------------------------------------------------------------------

class KIAPI_IMPORTEXPORT GetSelection final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kiapi.common.commands.GetSelection) */ {
 public:
  inline GetSelection() : GetSelection(nullptr) {}
  ~GetSelection() override;
  explicit constexpr GetSelection(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetSelection(const GetSelection& from);
  GetSelection(GetSelection&& from) noexcept
    : GetSelection() {
    *this = ::std::move(from);
  }

  inline GetSelection& operator=(const GetSelection& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSelection& operator=(GetSelection&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetSelection& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetSelection* internal_default_instance() {
    return reinterpret_cast<const GetSelection*>(
               &_GetSelection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(GetSelection& a, GetSelection& b) {
    a.Swap(&b);
  }
  inline void Swap(GetSelection* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetSelection* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetSelection* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetSelection>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetSelection& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetSelection& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetSelection* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kiapi.common.commands.GetSelection";
  }
  protected:
  explicit GetSelection(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypesFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // repeated .kiapi.common.types.KiCadObjectType types = 2;
  int types_size() const;
  private:
  int _internal_types_size() const;
  public:
  void clear_types();
  private:
  ::kiapi::common::types::KiCadObjectType _internal_types(int index) const;
  void _internal_add_types(::kiapi::common::types::KiCadObjectType value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_types();
  public:
  ::kiapi::common::types::KiCadObjectType types(int index) const;
  void set_types(int index, ::kiapi::common::types::KiCadObjectType value);
  void add_types(::kiapi::common::types::KiCadObjectType value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& types() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_types();

  // .kiapi.common.types.ItemHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::kiapi::common::types::ItemHeader& header() const;
  PROTOBUF_NODISCARD ::kiapi::common::types::ItemHeader* release_header();
  ::kiapi::common::types::ItemHeader* mutable_header();
  void set_allocated_header(::kiapi::common::types::ItemHeader* header);
  private:
  const ::kiapi::common::types::ItemHeader& _internal_header() const;
  ::kiapi::common::types::ItemHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::kiapi::common::types::ItemHeader* header);
  ::kiapi::common::types::ItemHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:kiapi.common.commands.GetSelection)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> types_;
  mutable std::atomic<int> _types_cached_byte_size_;
  ::kiapi::common::types::ItemHeader* header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2fcommands_2feditor_5fcommands_2eproto;
};
// -------------------------------------------------------------------

class KIAPI_IMPORTEXPORT SelectionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kiapi.common.commands.SelectionResponse) */ {
 public:
  inline SelectionResponse() : SelectionResponse(nullptr) {}
  ~SelectionResponse() override;
  explicit constexpr SelectionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SelectionResponse(const SelectionResponse& from);
  SelectionResponse(SelectionResponse&& from) noexcept
    : SelectionResponse() {
    *this = ::std::move(from);
  }

  inline SelectionResponse& operator=(const SelectionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SelectionResponse& operator=(SelectionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SelectionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SelectionResponse* internal_default_instance() {
    return reinterpret_cast<const SelectionResponse*>(
               &_SelectionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(SelectionResponse& a, SelectionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SelectionResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SelectionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SelectionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SelectionResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SelectionResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SelectionResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SelectionResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kiapi.common.commands.SelectionResponse";
  }
  protected:
  explicit SelectionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated .google.protobuf.Any items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::PROTOBUF_NAMESPACE_ID::Any* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Any >*
      mutable_items();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Any& _internal_items(int index) const;
  ::PROTOBUF_NAMESPACE_ID::Any* _internal_add_items();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Any& items(int index) const;
  ::PROTOBUF_NAMESPACE_ID::Any* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Any >&
      items() const;

  // @@protoc_insertion_point(class_scope:kiapi.common.commands.SelectionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Any > items_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2fcommands_2feditor_5fcommands_2eproto;
};
// -------------------------------------------------------------------

class KIAPI_IMPORTEXPORT AddToSelection final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kiapi.common.commands.AddToSelection) */ {
 public:
  inline AddToSelection() : AddToSelection(nullptr) {}
  ~AddToSelection() override;
  explicit constexpr AddToSelection(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddToSelection(const AddToSelection& from);
  AddToSelection(AddToSelection&& from) noexcept
    : AddToSelection() {
    *this = ::std::move(from);
  }

  inline AddToSelection& operator=(const AddToSelection& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddToSelection& operator=(AddToSelection&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddToSelection& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddToSelection* internal_default_instance() {
    return reinterpret_cast<const AddToSelection*>(
               &_AddToSelection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(AddToSelection& a, AddToSelection& b) {
    a.Swap(&b);
  }
  inline void Swap(AddToSelection* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddToSelection* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddToSelection* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddToSelection>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddToSelection& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AddToSelection& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddToSelection* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kiapi.common.commands.AddToSelection";
  }
  protected:
  explicit AddToSelection(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // repeated .kiapi.common.types.KIID items = 2;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::kiapi::common::types::KIID* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::types::KIID >*
      mutable_items();
  private:
  const ::kiapi::common::types::KIID& _internal_items(int index) const;
  ::kiapi::common::types::KIID* _internal_add_items();
  public:
  const ::kiapi::common::types::KIID& items(int index) const;
  ::kiapi::common::types::KIID* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::types::KIID >&
      items() const;

  // .kiapi.common.types.ItemHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::kiapi::common::types::ItemHeader& header() const;
  PROTOBUF_NODISCARD ::kiapi::common::types::ItemHeader* release_header();
  ::kiapi::common::types::ItemHeader* mutable_header();
  void set_allocated_header(::kiapi::common::types::ItemHeader* header);
  private:
  const ::kiapi::common::types::ItemHeader& _internal_header() const;
  ::kiapi::common::types::ItemHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::kiapi::common::types::ItemHeader* header);
  ::kiapi::common::types::ItemHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:kiapi.common.commands.AddToSelection)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::types::KIID > items_;
  ::kiapi::common::types::ItemHeader* header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2fcommands_2feditor_5fcommands_2eproto;
};
// -------------------------------------------------------------------

class KIAPI_IMPORTEXPORT RemoveFromSelection final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kiapi.common.commands.RemoveFromSelection) */ {
 public:
  inline RemoveFromSelection() : RemoveFromSelection(nullptr) {}
  ~RemoveFromSelection() override;
  explicit constexpr RemoveFromSelection(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RemoveFromSelection(const RemoveFromSelection& from);
  RemoveFromSelection(RemoveFromSelection&& from) noexcept
    : RemoveFromSelection() {
    *this = ::std::move(from);
  }

  inline RemoveFromSelection& operator=(const RemoveFromSelection& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoveFromSelection& operator=(RemoveFromSelection&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RemoveFromSelection& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemoveFromSelection* internal_default_instance() {
    return reinterpret_cast<const RemoveFromSelection*>(
               &_RemoveFromSelection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(RemoveFromSelection& a, RemoveFromSelection& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoveFromSelection* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoveFromSelection* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RemoveFromSelection* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RemoveFromSelection>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RemoveFromSelection& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RemoveFromSelection& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemoveFromSelection* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kiapi.common.commands.RemoveFromSelection";
  }
  protected:
  explicit RemoveFromSelection(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // repeated .kiapi.common.types.KIID items = 2;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::kiapi::common::types::KIID* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::types::KIID >*
      mutable_items();
  private:
  const ::kiapi::common::types::KIID& _internal_items(int index) const;
  ::kiapi::common::types::KIID* _internal_add_items();
  public:
  const ::kiapi::common::types::KIID& items(int index) const;
  ::kiapi::common::types::KIID* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::types::KIID >&
      items() const;

  // .kiapi.common.types.ItemHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::kiapi::common::types::ItemHeader& header() const;
  PROTOBUF_NODISCARD ::kiapi::common::types::ItemHeader* release_header();
  ::kiapi::common::types::ItemHeader* mutable_header();
  void set_allocated_header(::kiapi::common::types::ItemHeader* header);
  private:
  const ::kiapi::common::types::ItemHeader& _internal_header() const;
  ::kiapi::common::types::ItemHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::kiapi::common::types::ItemHeader* header);
  ::kiapi::common::types::ItemHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:kiapi.common.commands.RemoveFromSelection)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::types::KIID > items_;
  ::kiapi::common::types::ItemHeader* header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2fcommands_2feditor_5fcommands_2eproto;
};
// -------------------------------------------------------------------

class KIAPI_IMPORTEXPORT ClearSelection final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kiapi.common.commands.ClearSelection) */ {
 public:
  inline ClearSelection() : ClearSelection(nullptr) {}
  ~ClearSelection() override;
  explicit constexpr ClearSelection(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClearSelection(const ClearSelection& from);
  ClearSelection(ClearSelection&& from) noexcept
    : ClearSelection() {
    *this = ::std::move(from);
  }

  inline ClearSelection& operator=(const ClearSelection& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClearSelection& operator=(ClearSelection&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClearSelection& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClearSelection* internal_default_instance() {
    return reinterpret_cast<const ClearSelection*>(
               &_ClearSelection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(ClearSelection& a, ClearSelection& b) {
    a.Swap(&b);
  }
  inline void Swap(ClearSelection* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClearSelection* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClearSelection* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClearSelection>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClearSelection& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ClearSelection& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClearSelection* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kiapi.common.commands.ClearSelection";
  }
  protected:
  explicit ClearSelection(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
  };
  // .kiapi.common.types.ItemHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::kiapi::common::types::ItemHeader& header() const;
  PROTOBUF_NODISCARD ::kiapi::common::types::ItemHeader* release_header();
  ::kiapi::common::types::ItemHeader* mutable_header();
  void set_allocated_header(::kiapi::common::types::ItemHeader* header);
  private:
  const ::kiapi::common::types::ItemHeader& _internal_header() const;
  ::kiapi::common::types::ItemHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::kiapi::common::types::ItemHeader* header);
  ::kiapi::common::types::ItemHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:kiapi.common.commands.ClearSelection)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::kiapi::common::types::ItemHeader* header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2fcommands_2feditor_5fcommands_2eproto;
};
// -------------------------------------------------------------------

class KIAPI_IMPORTEXPORT HitTest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kiapi.common.commands.HitTest) */ {
 public:
  inline HitTest() : HitTest(nullptr) {}
  ~HitTest() override;
  explicit constexpr HitTest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HitTest(const HitTest& from);
  HitTest(HitTest&& from) noexcept
    : HitTest() {
    *this = ::std::move(from);
  }

  inline HitTest& operator=(const HitTest& from) {
    CopyFrom(from);
    return *this;
  }
  inline HitTest& operator=(HitTest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HitTest& default_instance() {
    return *internal_default_instance();
  }
  static inline const HitTest* internal_default_instance() {
    return reinterpret_cast<const HitTest*>(
               &_HitTest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(HitTest& a, HitTest& b) {
    a.Swap(&b);
  }
  inline void Swap(HitTest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HitTest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HitTest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HitTest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HitTest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const HitTest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HitTest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kiapi.common.commands.HitTest";
  }
  protected:
  explicit HitTest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kIdFieldNumber = 2,
    kPositionFieldNumber = 3,
    kToleranceFieldNumber = 4,
  };
  // .kiapi.common.types.ItemHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::kiapi::common::types::ItemHeader& header() const;
  PROTOBUF_NODISCARD ::kiapi::common::types::ItemHeader* release_header();
  ::kiapi::common::types::ItemHeader* mutable_header();
  void set_allocated_header(::kiapi::common::types::ItemHeader* header);
  private:
  const ::kiapi::common::types::ItemHeader& _internal_header() const;
  ::kiapi::common::types::ItemHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::kiapi::common::types::ItemHeader* header);
  ::kiapi::common::types::ItemHeader* unsafe_arena_release_header();

  // .kiapi.common.types.KIID id = 2;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const ::kiapi::common::types::KIID& id() const;
  PROTOBUF_NODISCARD ::kiapi::common::types::KIID* release_id();
  ::kiapi::common::types::KIID* mutable_id();
  void set_allocated_id(::kiapi::common::types::KIID* id);
  private:
  const ::kiapi::common::types::KIID& _internal_id() const;
  ::kiapi::common::types::KIID* _internal_mutable_id();
  public:
  void unsafe_arena_set_allocated_id(
      ::kiapi::common::types::KIID* id);
  ::kiapi::common::types::KIID* unsafe_arena_release_id();

  // .kiapi.common.types.Vector2 position = 3;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::kiapi::common::types::Vector2& position() const;
  PROTOBUF_NODISCARD ::kiapi::common::types::Vector2* release_position();
  ::kiapi::common::types::Vector2* mutable_position();
  void set_allocated_position(::kiapi::common::types::Vector2* position);
  private:
  const ::kiapi::common::types::Vector2& _internal_position() const;
  ::kiapi::common::types::Vector2* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::kiapi::common::types::Vector2* position);
  ::kiapi::common::types::Vector2* unsafe_arena_release_position();

  // int32 tolerance = 4;
  void clear_tolerance();
  int32_t tolerance() const;
  void set_tolerance(int32_t value);
  private:
  int32_t _internal_tolerance() const;
  void _internal_set_tolerance(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:kiapi.common.commands.HitTest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::kiapi::common::types::ItemHeader* header_;
  ::kiapi::common::types::KIID* id_;
  ::kiapi::common::types::Vector2* position_;
  int32_t tolerance_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2fcommands_2feditor_5fcommands_2eproto;
};
// -------------------------------------------------------------------

class KIAPI_IMPORTEXPORT HitTestResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kiapi.common.commands.HitTestResponse) */ {
 public:
  inline HitTestResponse() : HitTestResponse(nullptr) {}
  ~HitTestResponse() override;
  explicit constexpr HitTestResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HitTestResponse(const HitTestResponse& from);
  HitTestResponse(HitTestResponse&& from) noexcept
    : HitTestResponse() {
    *this = ::std::move(from);
  }

  inline HitTestResponse& operator=(const HitTestResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline HitTestResponse& operator=(HitTestResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HitTestResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const HitTestResponse* internal_default_instance() {
    return reinterpret_cast<const HitTestResponse*>(
               &_HitTestResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(HitTestResponse& a, HitTestResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(HitTestResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HitTestResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HitTestResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HitTestResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HitTestResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const HitTestResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HitTestResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kiapi.common.commands.HitTestResponse";
  }
  protected:
  explicit HitTestResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // .kiapi.common.commands.HitTestResult result = 1;
  void clear_result();
  ::kiapi::common::commands::HitTestResult result() const;
  void set_result(::kiapi::common::commands::HitTestResult value);
  private:
  ::kiapi::common::commands::HitTestResult _internal_result() const;
  void _internal_set_result(::kiapi::common::commands::HitTestResult value);
  public:

  // @@protoc_insertion_point(class_scope:kiapi.common.commands.HitTestResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2fcommands_2feditor_5fcommands_2eproto;
};
// -------------------------------------------------------------------

class KIAPI_IMPORTEXPORT GetTitleBlockInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kiapi.common.commands.GetTitleBlockInfo) */ {
 public:
  inline GetTitleBlockInfo() : GetTitleBlockInfo(nullptr) {}
  ~GetTitleBlockInfo() override;
  explicit constexpr GetTitleBlockInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetTitleBlockInfo(const GetTitleBlockInfo& from);
  GetTitleBlockInfo(GetTitleBlockInfo&& from) noexcept
    : GetTitleBlockInfo() {
    *this = ::std::move(from);
  }

  inline GetTitleBlockInfo& operator=(const GetTitleBlockInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTitleBlockInfo& operator=(GetTitleBlockInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTitleBlockInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTitleBlockInfo* internal_default_instance() {
    return reinterpret_cast<const GetTitleBlockInfo*>(
               &_GetTitleBlockInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(GetTitleBlockInfo& a, GetTitleBlockInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(GetTitleBlockInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTitleBlockInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetTitleBlockInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetTitleBlockInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetTitleBlockInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetTitleBlockInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTitleBlockInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kiapi.common.commands.GetTitleBlockInfo";
  }
  protected:
  explicit GetTitleBlockInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDocumentFieldNumber = 1,
  };
  // .kiapi.common.types.DocumentSpecifier document = 1;
  bool has_document() const;
  private:
  bool _internal_has_document() const;
  public:
  void clear_document();
  const ::kiapi::common::types::DocumentSpecifier& document() const;
  PROTOBUF_NODISCARD ::kiapi::common::types::DocumentSpecifier* release_document();
  ::kiapi::common::types::DocumentSpecifier* mutable_document();
  void set_allocated_document(::kiapi::common::types::DocumentSpecifier* document);
  private:
  const ::kiapi::common::types::DocumentSpecifier& _internal_document() const;
  ::kiapi::common::types::DocumentSpecifier* _internal_mutable_document();
  public:
  void unsafe_arena_set_allocated_document(
      ::kiapi::common::types::DocumentSpecifier* document);
  ::kiapi::common::types::DocumentSpecifier* unsafe_arena_release_document();

  // @@protoc_insertion_point(class_scope:kiapi.common.commands.GetTitleBlockInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::kiapi::common::types::DocumentSpecifier* document_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2fcommands_2feditor_5fcommands_2eproto;
};
// -------------------------------------------------------------------

class KIAPI_IMPORTEXPORT SaveDocumentToString final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kiapi.common.commands.SaveDocumentToString) */ {
 public:
  inline SaveDocumentToString() : SaveDocumentToString(nullptr) {}
  ~SaveDocumentToString() override;
  explicit constexpr SaveDocumentToString(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SaveDocumentToString(const SaveDocumentToString& from);
  SaveDocumentToString(SaveDocumentToString&& from) noexcept
    : SaveDocumentToString() {
    *this = ::std::move(from);
  }

  inline SaveDocumentToString& operator=(const SaveDocumentToString& from) {
    CopyFrom(from);
    return *this;
  }
  inline SaveDocumentToString& operator=(SaveDocumentToString&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SaveDocumentToString& default_instance() {
    return *internal_default_instance();
  }
  static inline const SaveDocumentToString* internal_default_instance() {
    return reinterpret_cast<const SaveDocumentToString*>(
               &_SaveDocumentToString_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(SaveDocumentToString& a, SaveDocumentToString& b) {
    a.Swap(&b);
  }
  inline void Swap(SaveDocumentToString* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SaveDocumentToString* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SaveDocumentToString* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SaveDocumentToString>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SaveDocumentToString& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SaveDocumentToString& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SaveDocumentToString* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kiapi.common.commands.SaveDocumentToString";
  }
  protected:
  explicit SaveDocumentToString(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDocumentFieldNumber = 1,
  };
  // .kiapi.common.types.DocumentSpecifier document = 1;
  bool has_document() const;
  private:
  bool _internal_has_document() const;
  public:
  void clear_document();
  const ::kiapi::common::types::DocumentSpecifier& document() const;
  PROTOBUF_NODISCARD ::kiapi::common::types::DocumentSpecifier* release_document();
  ::kiapi::common::types::DocumentSpecifier* mutable_document();
  void set_allocated_document(::kiapi::common::types::DocumentSpecifier* document);
  private:
  const ::kiapi::common::types::DocumentSpecifier& _internal_document() const;
  ::kiapi::common::types::DocumentSpecifier* _internal_mutable_document();
  public:
  void unsafe_arena_set_allocated_document(
      ::kiapi::common::types::DocumentSpecifier* document);
  ::kiapi::common::types::DocumentSpecifier* unsafe_arena_release_document();

  // @@protoc_insertion_point(class_scope:kiapi.common.commands.SaveDocumentToString)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::kiapi::common::types::DocumentSpecifier* document_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2fcommands_2feditor_5fcommands_2eproto;
};
// -------------------------------------------------------------------

class KIAPI_IMPORTEXPORT SavedDocumentResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kiapi.common.commands.SavedDocumentResponse) */ {
 public:
  inline SavedDocumentResponse() : SavedDocumentResponse(nullptr) {}
  ~SavedDocumentResponse() override;
  explicit constexpr SavedDocumentResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SavedDocumentResponse(const SavedDocumentResponse& from);
  SavedDocumentResponse(SavedDocumentResponse&& from) noexcept
    : SavedDocumentResponse() {
    *this = ::std::move(from);
  }

  inline SavedDocumentResponse& operator=(const SavedDocumentResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SavedDocumentResponse& operator=(SavedDocumentResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SavedDocumentResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SavedDocumentResponse* internal_default_instance() {
    return reinterpret_cast<const SavedDocumentResponse*>(
               &_SavedDocumentResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(SavedDocumentResponse& a, SavedDocumentResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SavedDocumentResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SavedDocumentResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SavedDocumentResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SavedDocumentResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SavedDocumentResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SavedDocumentResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SavedDocumentResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kiapi.common.commands.SavedDocumentResponse";
  }
  protected:
  explicit SavedDocumentResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContentsFieldNumber = 2,
    kDocumentFieldNumber = 1,
  };
  // string contents = 2;
  void clear_contents();
  const std::string& contents() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contents(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contents();
  PROTOBUF_NODISCARD std::string* release_contents();
  void set_allocated_contents(std::string* contents);
  private:
  const std::string& _internal_contents() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contents(const std::string& value);
  std::string* _internal_mutable_contents();
  public:

  // .kiapi.common.types.DocumentSpecifier document = 1;
  bool has_document() const;
  private:
  bool _internal_has_document() const;
  public:
  void clear_document();
  const ::kiapi::common::types::DocumentSpecifier& document() const;
  PROTOBUF_NODISCARD ::kiapi::common::types::DocumentSpecifier* release_document();
  ::kiapi::common::types::DocumentSpecifier* mutable_document();
  void set_allocated_document(::kiapi::common::types::DocumentSpecifier* document);
  private:
  const ::kiapi::common::types::DocumentSpecifier& _internal_document() const;
  ::kiapi::common::types::DocumentSpecifier* _internal_mutable_document();
  public:
  void unsafe_arena_set_allocated_document(
      ::kiapi::common::types::DocumentSpecifier* document);
  ::kiapi::common::types::DocumentSpecifier* unsafe_arena_release_document();

  // @@protoc_insertion_point(class_scope:kiapi.common.commands.SavedDocumentResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contents_;
  ::kiapi::common::types::DocumentSpecifier* document_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2fcommands_2feditor_5fcommands_2eproto;
};
// -------------------------------------------------------------------

class KIAPI_IMPORTEXPORT SaveSelectionToString final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:kiapi.common.commands.SaveSelectionToString) */ {
 public:
  inline SaveSelectionToString() : SaveSelectionToString(nullptr) {}
  explicit constexpr SaveSelectionToString(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SaveSelectionToString(const SaveSelectionToString& from);
  SaveSelectionToString(SaveSelectionToString&& from) noexcept
    : SaveSelectionToString() {
    *this = ::std::move(from);
  }

  inline SaveSelectionToString& operator=(const SaveSelectionToString& from) {
    CopyFrom(from);
    return *this;
  }
  inline SaveSelectionToString& operator=(SaveSelectionToString&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SaveSelectionToString& default_instance() {
    return *internal_default_instance();
  }
  static inline const SaveSelectionToString* internal_default_instance() {
    return reinterpret_cast<const SaveSelectionToString*>(
               &_SaveSelectionToString_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(SaveSelectionToString& a, SaveSelectionToString& b) {
    a.Swap(&b);
  }
  inline void Swap(SaveSelectionToString* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SaveSelectionToString* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SaveSelectionToString* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SaveSelectionToString>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SaveSelectionToString& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SaveSelectionToString& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kiapi.common.commands.SaveSelectionToString";
  }
  protected:
  explicit SaveSelectionToString(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:kiapi.common.commands.SaveSelectionToString)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2fcommands_2feditor_5fcommands_2eproto;
};
// -------------------------------------------------------------------

class KIAPI_IMPORTEXPORT SavedSelectionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kiapi.common.commands.SavedSelectionResponse) */ {
 public:
  inline SavedSelectionResponse() : SavedSelectionResponse(nullptr) {}
  ~SavedSelectionResponse() override;
  explicit constexpr SavedSelectionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SavedSelectionResponse(const SavedSelectionResponse& from);
  SavedSelectionResponse(SavedSelectionResponse&& from) noexcept
    : SavedSelectionResponse() {
    *this = ::std::move(from);
  }

  inline SavedSelectionResponse& operator=(const SavedSelectionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SavedSelectionResponse& operator=(SavedSelectionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SavedSelectionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SavedSelectionResponse* internal_default_instance() {
    return reinterpret_cast<const SavedSelectionResponse*>(
               &_SavedSelectionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(SavedSelectionResponse& a, SavedSelectionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SavedSelectionResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SavedSelectionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SavedSelectionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SavedSelectionResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SavedSelectionResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SavedSelectionResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SavedSelectionResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kiapi.common.commands.SavedSelectionResponse";
  }
  protected:
  explicit SavedSelectionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdsFieldNumber = 1,
    kContentsFieldNumber = 2,
  };
  // repeated .kiapi.common.types.KIID ids = 1;
  int ids_size() const;
  private:
  int _internal_ids_size() const;
  public:
  void clear_ids();
  ::kiapi::common::types::KIID* mutable_ids(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::types::KIID >*
      mutable_ids();
  private:
  const ::kiapi::common::types::KIID& _internal_ids(int index) const;
  ::kiapi::common::types::KIID* _internal_add_ids();
  public:
  const ::kiapi::common::types::KIID& ids(int index) const;
  ::kiapi::common::types::KIID* add_ids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::types::KIID >&
      ids() const;

  // string contents = 2;
  void clear_contents();
  const std::string& contents() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contents(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contents();
  PROTOBUF_NODISCARD std::string* release_contents();
  void set_allocated_contents(std::string* contents);
  private:
  const std::string& _internal_contents() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contents(const std::string& value);
  std::string* _internal_mutable_contents();
  public:

  // @@protoc_insertion_point(class_scope:kiapi.common.commands.SavedSelectionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::types::KIID > ids_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contents_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2fcommands_2feditor_5fcommands_2eproto;
};
// -------------------------------------------------------------------

class KIAPI_IMPORTEXPORT ParseAndCreateItemsFromString final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kiapi.common.commands.ParseAndCreateItemsFromString) */ {
 public:
  inline ParseAndCreateItemsFromString() : ParseAndCreateItemsFromString(nullptr) {}
  ~ParseAndCreateItemsFromString() override;
  explicit constexpr ParseAndCreateItemsFromString(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ParseAndCreateItemsFromString(const ParseAndCreateItemsFromString& from);
  ParseAndCreateItemsFromString(ParseAndCreateItemsFromString&& from) noexcept
    : ParseAndCreateItemsFromString() {
    *this = ::std::move(from);
  }

  inline ParseAndCreateItemsFromString& operator=(const ParseAndCreateItemsFromString& from) {
    CopyFrom(from);
    return *this;
  }
  inline ParseAndCreateItemsFromString& operator=(ParseAndCreateItemsFromString&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ParseAndCreateItemsFromString& default_instance() {
    return *internal_default_instance();
  }
  static inline const ParseAndCreateItemsFromString* internal_default_instance() {
    return reinterpret_cast<const ParseAndCreateItemsFromString*>(
               &_ParseAndCreateItemsFromString_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(ParseAndCreateItemsFromString& a, ParseAndCreateItemsFromString& b) {
    a.Swap(&b);
  }
  inline void Swap(ParseAndCreateItemsFromString* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ParseAndCreateItemsFromString* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ParseAndCreateItemsFromString* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ParseAndCreateItemsFromString>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ParseAndCreateItemsFromString& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ParseAndCreateItemsFromString& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ParseAndCreateItemsFromString* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kiapi.common.commands.ParseAndCreateItemsFromString";
  }
  protected:
  explicit ParseAndCreateItemsFromString(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContentsFieldNumber = 2,
    kDocumentFieldNumber = 1,
  };
  // string contents = 2;
  void clear_contents();
  const std::string& contents() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contents(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contents();
  PROTOBUF_NODISCARD std::string* release_contents();
  void set_allocated_contents(std::string* contents);
  private:
  const std::string& _internal_contents() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contents(const std::string& value);
  std::string* _internal_mutable_contents();
  public:

  // .kiapi.common.types.DocumentSpecifier document = 1;
  bool has_document() const;
  private:
  bool _internal_has_document() const;
  public:
  void clear_document();
  const ::kiapi::common::types::DocumentSpecifier& document() const;
  PROTOBUF_NODISCARD ::kiapi::common::types::DocumentSpecifier* release_document();
  ::kiapi::common::types::DocumentSpecifier* mutable_document();
  void set_allocated_document(::kiapi::common::types::DocumentSpecifier* document);
  private:
  const ::kiapi::common::types::DocumentSpecifier& _internal_document() const;
  ::kiapi::common::types::DocumentSpecifier* _internal_mutable_document();
  public:
  void unsafe_arena_set_allocated_document(
      ::kiapi::common::types::DocumentSpecifier* document);
  ::kiapi::common::types::DocumentSpecifier* unsafe_arena_release_document();

  // @@protoc_insertion_point(class_scope:kiapi.common.commands.ParseAndCreateItemsFromString)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contents_;
  ::kiapi::common::types::DocumentSpecifier* document_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2fcommands_2feditor_5fcommands_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RefreshEditor

// .kiapi.common.types.FrameType frame = 1;
inline void RefreshEditor::clear_frame() {
  frame_ = 0;
}
inline ::kiapi::common::types::FrameType RefreshEditor::_internal_frame() const {
  return static_cast< ::kiapi::common::types::FrameType >(frame_);
}
inline ::kiapi::common::types::FrameType RefreshEditor::frame() const {
  // @@protoc_insertion_point(field_get:kiapi.common.commands.RefreshEditor.frame)
  return _internal_frame();
}
inline void RefreshEditor::_internal_set_frame(::kiapi::common::types::FrameType value) {
  
  frame_ = value;
}
inline void RefreshEditor::set_frame(::kiapi::common::types::FrameType value) {
  _internal_set_frame(value);
  // @@protoc_insertion_point(field_set:kiapi.common.commands.RefreshEditor.frame)
}

// -------------------------------------------------------------------

// GetOpenDocuments

// .kiapi.common.types.DocumentType type = 1;
inline void GetOpenDocuments::clear_type() {
  type_ = 0;
}
inline ::kiapi::common::types::DocumentType GetOpenDocuments::_internal_type() const {
  return static_cast< ::kiapi::common::types::DocumentType >(type_);
}
inline ::kiapi::common::types::DocumentType GetOpenDocuments::type() const {
  // @@protoc_insertion_point(field_get:kiapi.common.commands.GetOpenDocuments.type)
  return _internal_type();
}
inline void GetOpenDocuments::_internal_set_type(::kiapi::common::types::DocumentType value) {
  
  type_ = value;
}
inline void GetOpenDocuments::set_type(::kiapi::common::types::DocumentType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:kiapi.common.commands.GetOpenDocuments.type)
}

// -------------------------------------------------------------------

// GetOpenDocumentsResponse

// repeated .kiapi.common.types.DocumentSpecifier documents = 1;
inline int GetOpenDocumentsResponse::_internal_documents_size() const {
  return documents_.size();
}
inline int GetOpenDocumentsResponse::documents_size() const {
  return _internal_documents_size();
}
inline ::kiapi::common::types::DocumentSpecifier* GetOpenDocumentsResponse::mutable_documents(int index) {
  // @@protoc_insertion_point(field_mutable:kiapi.common.commands.GetOpenDocumentsResponse.documents)
  return documents_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::types::DocumentSpecifier >*
GetOpenDocumentsResponse::mutable_documents() {
  // @@protoc_insertion_point(field_mutable_list:kiapi.common.commands.GetOpenDocumentsResponse.documents)
  return &documents_;
}
inline const ::kiapi::common::types::DocumentSpecifier& GetOpenDocumentsResponse::_internal_documents(int index) const {
  return documents_.Get(index);
}
inline const ::kiapi::common::types::DocumentSpecifier& GetOpenDocumentsResponse::documents(int index) const {
  // @@protoc_insertion_point(field_get:kiapi.common.commands.GetOpenDocumentsResponse.documents)
  return _internal_documents(index);
}
inline ::kiapi::common::types::DocumentSpecifier* GetOpenDocumentsResponse::_internal_add_documents() {
  return documents_.Add();
}
inline ::kiapi::common::types::DocumentSpecifier* GetOpenDocumentsResponse::add_documents() {
  ::kiapi::common::types::DocumentSpecifier* _add = _internal_add_documents();
  // @@protoc_insertion_point(field_add:kiapi.common.commands.GetOpenDocumentsResponse.documents)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::types::DocumentSpecifier >&
GetOpenDocumentsResponse::documents() const {
  // @@protoc_insertion_point(field_list:kiapi.common.commands.GetOpenDocumentsResponse.documents)
  return documents_;
}

// -------------------------------------------------------------------

// SaveDocument

// .kiapi.common.types.DocumentSpecifier document = 1;
inline bool SaveDocument::_internal_has_document() const {
  return this != internal_default_instance() && document_ != nullptr;
}
inline bool SaveDocument::has_document() const {
  return _internal_has_document();
}
inline const ::kiapi::common::types::DocumentSpecifier& SaveDocument::_internal_document() const {
  const ::kiapi::common::types::DocumentSpecifier* p = document_;
  return p != nullptr ? *p : reinterpret_cast<const ::kiapi::common::types::DocumentSpecifier&>(
      ::kiapi::common::types::_DocumentSpecifier_default_instance_);
}
inline const ::kiapi::common::types::DocumentSpecifier& SaveDocument::document() const {
  // @@protoc_insertion_point(field_get:kiapi.common.commands.SaveDocument.document)
  return _internal_document();
}
inline void SaveDocument::unsafe_arena_set_allocated_document(
    ::kiapi::common::types::DocumentSpecifier* document) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(document_);
  }
  document_ = document;
  if (document) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kiapi.common.commands.SaveDocument.document)
}
inline ::kiapi::common::types::DocumentSpecifier* SaveDocument::release_document() {
  
  ::kiapi::common::types::DocumentSpecifier* temp = document_;
  document_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kiapi::common::types::DocumentSpecifier* SaveDocument::unsafe_arena_release_document() {
  // @@protoc_insertion_point(field_release:kiapi.common.commands.SaveDocument.document)
  
  ::kiapi::common::types::DocumentSpecifier* temp = document_;
  document_ = nullptr;
  return temp;
}
inline ::kiapi::common::types::DocumentSpecifier* SaveDocument::_internal_mutable_document() {
  
  if (document_ == nullptr) {
    auto* p = CreateMaybeMessage<::kiapi::common::types::DocumentSpecifier>(GetArenaForAllocation());
    document_ = p;
  }
  return document_;
}
inline ::kiapi::common::types::DocumentSpecifier* SaveDocument::mutable_document() {
  ::kiapi::common::types::DocumentSpecifier* _msg = _internal_mutable_document();
  // @@protoc_insertion_point(field_mutable:kiapi.common.commands.SaveDocument.document)
  return _msg;
}
inline void SaveDocument::set_allocated_document(::kiapi::common::types::DocumentSpecifier* document) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(document_);
  }
  if (document) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(document));
    if (message_arena != submessage_arena) {
      document = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, document, submessage_arena);
    }
    
  } else {
    
  }
  document_ = document;
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.commands.SaveDocument.document)
}

// -------------------------------------------------------------------

// SaveOptions

// bool overwrite = 1;
inline void SaveOptions::clear_overwrite() {
  overwrite_ = false;
}
inline bool SaveOptions::_internal_overwrite() const {
  return overwrite_;
}
inline bool SaveOptions::overwrite() const {
  // @@protoc_insertion_point(field_get:kiapi.common.commands.SaveOptions.overwrite)
  return _internal_overwrite();
}
inline void SaveOptions::_internal_set_overwrite(bool value) {
  
  overwrite_ = value;
}
inline void SaveOptions::set_overwrite(bool value) {
  _internal_set_overwrite(value);
  // @@protoc_insertion_point(field_set:kiapi.common.commands.SaveOptions.overwrite)
}

// bool include_project = 2;
inline void SaveOptions::clear_include_project() {
  include_project_ = false;
}
inline bool SaveOptions::_internal_include_project() const {
  return include_project_;
}
inline bool SaveOptions::include_project() const {
  // @@protoc_insertion_point(field_get:kiapi.common.commands.SaveOptions.include_project)
  return _internal_include_project();
}
inline void SaveOptions::_internal_set_include_project(bool value) {
  
  include_project_ = value;
}
inline void SaveOptions::set_include_project(bool value) {
  _internal_set_include_project(value);
  // @@protoc_insertion_point(field_set:kiapi.common.commands.SaveOptions.include_project)
}

// -------------------------------------------------------------------

// SaveCopyOfDocument

// .kiapi.common.types.DocumentSpecifier document = 1;
inline bool SaveCopyOfDocument::_internal_has_document() const {
  return this != internal_default_instance() && document_ != nullptr;
}
inline bool SaveCopyOfDocument::has_document() const {
  return _internal_has_document();
}
inline const ::kiapi::common::types::DocumentSpecifier& SaveCopyOfDocument::_internal_document() const {
  const ::kiapi::common::types::DocumentSpecifier* p = document_;
  return p != nullptr ? *p : reinterpret_cast<const ::kiapi::common::types::DocumentSpecifier&>(
      ::kiapi::common::types::_DocumentSpecifier_default_instance_);
}
inline const ::kiapi::common::types::DocumentSpecifier& SaveCopyOfDocument::document() const {
  // @@protoc_insertion_point(field_get:kiapi.common.commands.SaveCopyOfDocument.document)
  return _internal_document();
}
inline void SaveCopyOfDocument::unsafe_arena_set_allocated_document(
    ::kiapi::common::types::DocumentSpecifier* document) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(document_);
  }
  document_ = document;
  if (document) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kiapi.common.commands.SaveCopyOfDocument.document)
}
inline ::kiapi::common::types::DocumentSpecifier* SaveCopyOfDocument::release_document() {
  
  ::kiapi::common::types::DocumentSpecifier* temp = document_;
  document_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kiapi::common::types::DocumentSpecifier* SaveCopyOfDocument::unsafe_arena_release_document() {
  // @@protoc_insertion_point(field_release:kiapi.common.commands.SaveCopyOfDocument.document)
  
  ::kiapi::common::types::DocumentSpecifier* temp = document_;
  document_ = nullptr;
  return temp;
}
inline ::kiapi::common::types::DocumentSpecifier* SaveCopyOfDocument::_internal_mutable_document() {
  
  if (document_ == nullptr) {
    auto* p = CreateMaybeMessage<::kiapi::common::types::DocumentSpecifier>(GetArenaForAllocation());
    document_ = p;
  }
  return document_;
}
inline ::kiapi::common::types::DocumentSpecifier* SaveCopyOfDocument::mutable_document() {
  ::kiapi::common::types::DocumentSpecifier* _msg = _internal_mutable_document();
  // @@protoc_insertion_point(field_mutable:kiapi.common.commands.SaveCopyOfDocument.document)
  return _msg;
}
inline void SaveCopyOfDocument::set_allocated_document(::kiapi::common::types::DocumentSpecifier* document) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(document_);
  }
  if (document) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(document));
    if (message_arena != submessage_arena) {
      document = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, document, submessage_arena);
    }
    
  } else {
    
  }
  document_ = document;
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.commands.SaveCopyOfDocument.document)
}

// string path = 2;
inline void SaveCopyOfDocument::clear_path() {
  path_.ClearToEmpty();
}
inline const std::string& SaveCopyOfDocument::path() const {
  // @@protoc_insertion_point(field_get:kiapi.common.commands.SaveCopyOfDocument.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SaveCopyOfDocument::set_path(ArgT0&& arg0, ArgT... args) {
 
 path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kiapi.common.commands.SaveCopyOfDocument.path)
}
inline std::string* SaveCopyOfDocument::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:kiapi.common.commands.SaveCopyOfDocument.path)
  return _s;
}
inline const std::string& SaveCopyOfDocument::_internal_path() const {
  return path_.Get();
}
inline void SaveCopyOfDocument::_internal_set_path(const std::string& value) {
  
  path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SaveCopyOfDocument::_internal_mutable_path() {
  
  return path_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SaveCopyOfDocument::release_path() {
  // @@protoc_insertion_point(field_release:kiapi.common.commands.SaveCopyOfDocument.path)
  return path_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SaveCopyOfDocument::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), path,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (path_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.commands.SaveCopyOfDocument.path)
}

// .kiapi.common.commands.SaveOptions options = 3;
inline bool SaveCopyOfDocument::_internal_has_options() const {
  return this != internal_default_instance() && options_ != nullptr;
}
inline bool SaveCopyOfDocument::has_options() const {
  return _internal_has_options();
}
inline void SaveCopyOfDocument::clear_options() {
  if (GetArenaForAllocation() == nullptr && options_ != nullptr) {
    delete options_;
  }
  options_ = nullptr;
}
inline const ::kiapi::common::commands::SaveOptions& SaveCopyOfDocument::_internal_options() const {
  const ::kiapi::common::commands::SaveOptions* p = options_;
  return p != nullptr ? *p : reinterpret_cast<const ::kiapi::common::commands::SaveOptions&>(
      ::kiapi::common::commands::_SaveOptions_default_instance_);
}
inline const ::kiapi::common::commands::SaveOptions& SaveCopyOfDocument::options() const {
  // @@protoc_insertion_point(field_get:kiapi.common.commands.SaveCopyOfDocument.options)
  return _internal_options();
}
inline void SaveCopyOfDocument::unsafe_arena_set_allocated_options(
    ::kiapi::common::commands::SaveOptions* options) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(options_);
  }
  options_ = options;
  if (options) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kiapi.common.commands.SaveCopyOfDocument.options)
}
inline ::kiapi::common::commands::SaveOptions* SaveCopyOfDocument::release_options() {
  
  ::kiapi::common::commands::SaveOptions* temp = options_;
  options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kiapi::common::commands::SaveOptions* SaveCopyOfDocument::unsafe_arena_release_options() {
  // @@protoc_insertion_point(field_release:kiapi.common.commands.SaveCopyOfDocument.options)
  
  ::kiapi::common::commands::SaveOptions* temp = options_;
  options_ = nullptr;
  return temp;
}
inline ::kiapi::common::commands::SaveOptions* SaveCopyOfDocument::_internal_mutable_options() {
  
  if (options_ == nullptr) {
    auto* p = CreateMaybeMessage<::kiapi::common::commands::SaveOptions>(GetArenaForAllocation());
    options_ = p;
  }
  return options_;
}
inline ::kiapi::common::commands::SaveOptions* SaveCopyOfDocument::mutable_options() {
  ::kiapi::common::commands::SaveOptions* _msg = _internal_mutable_options();
  // @@protoc_insertion_point(field_mutable:kiapi.common.commands.SaveCopyOfDocument.options)
  return _msg;
}
inline void SaveCopyOfDocument::set_allocated_options(::kiapi::common::commands::SaveOptions* options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete options_;
  }
  if (options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::kiapi::common::commands::SaveOptions>::GetOwningArena(options);
    if (message_arena != submessage_arena) {
      options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, options, submessage_arena);
    }
    
  } else {
    
  }
  options_ = options;
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.commands.SaveCopyOfDocument.options)
}

// -------------------------------------------------------------------

// RevertDocument

// .kiapi.common.types.DocumentSpecifier document = 1;
inline bool RevertDocument::_internal_has_document() const {
  return this != internal_default_instance() && document_ != nullptr;
}
inline bool RevertDocument::has_document() const {
  return _internal_has_document();
}
inline const ::kiapi::common::types::DocumentSpecifier& RevertDocument::_internal_document() const {
  const ::kiapi::common::types::DocumentSpecifier* p = document_;
  return p != nullptr ? *p : reinterpret_cast<const ::kiapi::common::types::DocumentSpecifier&>(
      ::kiapi::common::types::_DocumentSpecifier_default_instance_);
}
inline const ::kiapi::common::types::DocumentSpecifier& RevertDocument::document() const {
  // @@protoc_insertion_point(field_get:kiapi.common.commands.RevertDocument.document)
  return _internal_document();
}
inline void RevertDocument::unsafe_arena_set_allocated_document(
    ::kiapi::common::types::DocumentSpecifier* document) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(document_);
  }
  document_ = document;
  if (document) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kiapi.common.commands.RevertDocument.document)
}
inline ::kiapi::common::types::DocumentSpecifier* RevertDocument::release_document() {
  
  ::kiapi::common::types::DocumentSpecifier* temp = document_;
  document_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kiapi::common::types::DocumentSpecifier* RevertDocument::unsafe_arena_release_document() {
  // @@protoc_insertion_point(field_release:kiapi.common.commands.RevertDocument.document)
  
  ::kiapi::common::types::DocumentSpecifier* temp = document_;
  document_ = nullptr;
  return temp;
}
inline ::kiapi::common::types::DocumentSpecifier* RevertDocument::_internal_mutable_document() {
  
  if (document_ == nullptr) {
    auto* p = CreateMaybeMessage<::kiapi::common::types::DocumentSpecifier>(GetArenaForAllocation());
    document_ = p;
  }
  return document_;
}
inline ::kiapi::common::types::DocumentSpecifier* RevertDocument::mutable_document() {
  ::kiapi::common::types::DocumentSpecifier* _msg = _internal_mutable_document();
  // @@protoc_insertion_point(field_mutable:kiapi.common.commands.RevertDocument.document)
  return _msg;
}
inline void RevertDocument::set_allocated_document(::kiapi::common::types::DocumentSpecifier* document) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(document_);
  }
  if (document) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(document));
    if (message_arena != submessage_arena) {
      document = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, document, submessage_arena);
    }
    
  } else {
    
  }
  document_ = document;
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.commands.RevertDocument.document)
}

// -------------------------------------------------------------------

// RunAction

// string action = 1;
inline void RunAction::clear_action() {
  action_.ClearToEmpty();
}
inline const std::string& RunAction::action() const {
  // @@protoc_insertion_point(field_get:kiapi.common.commands.RunAction.action)
  return _internal_action();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RunAction::set_action(ArgT0&& arg0, ArgT... args) {
 
 action_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kiapi.common.commands.RunAction.action)
}
inline std::string* RunAction::mutable_action() {
  std::string* _s = _internal_mutable_action();
  // @@protoc_insertion_point(field_mutable:kiapi.common.commands.RunAction.action)
  return _s;
}
inline const std::string& RunAction::_internal_action() const {
  return action_.Get();
}
inline void RunAction::_internal_set_action(const std::string& value) {
  
  action_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RunAction::_internal_mutable_action() {
  
  return action_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RunAction::release_action() {
  // @@protoc_insertion_point(field_release:kiapi.common.commands.RunAction.action)
  return action_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RunAction::set_allocated_action(std::string* action) {
  if (action != nullptr) {
    
  } else {
    
  }
  action_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), action,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (action_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    action_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.commands.RunAction.action)
}

// -------------------------------------------------------------------

// RunActionResponse

// .kiapi.common.commands.RunActionStatus status = 1;
inline void RunActionResponse::clear_status() {
  status_ = 0;
}
inline ::kiapi::common::commands::RunActionStatus RunActionResponse::_internal_status() const {
  return static_cast< ::kiapi::common::commands::RunActionStatus >(status_);
}
inline ::kiapi::common::commands::RunActionStatus RunActionResponse::status() const {
  // @@protoc_insertion_point(field_get:kiapi.common.commands.RunActionResponse.status)
  return _internal_status();
}
inline void RunActionResponse::_internal_set_status(::kiapi::common::commands::RunActionStatus value) {
  
  status_ = value;
}
inline void RunActionResponse::set_status(::kiapi::common::commands::RunActionStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:kiapi.common.commands.RunActionResponse.status)
}

// -------------------------------------------------------------------

// BeginCommit

// -------------------------------------------------------------------

// BeginCommitResponse

// .kiapi.common.types.KIID id = 1;
inline bool BeginCommitResponse::_internal_has_id() const {
  return this != internal_default_instance() && id_ != nullptr;
}
inline bool BeginCommitResponse::has_id() const {
  return _internal_has_id();
}
inline const ::kiapi::common::types::KIID& BeginCommitResponse::_internal_id() const {
  const ::kiapi::common::types::KIID* p = id_;
  return p != nullptr ? *p : reinterpret_cast<const ::kiapi::common::types::KIID&>(
      ::kiapi::common::types::_KIID_default_instance_);
}
inline const ::kiapi::common::types::KIID& BeginCommitResponse::id() const {
  // @@protoc_insertion_point(field_get:kiapi.common.commands.BeginCommitResponse.id)
  return _internal_id();
}
inline void BeginCommitResponse::unsafe_arena_set_allocated_id(
    ::kiapi::common::types::KIID* id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  id_ = id;
  if (id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kiapi.common.commands.BeginCommitResponse.id)
}
inline ::kiapi::common::types::KIID* BeginCommitResponse::release_id() {
  
  ::kiapi::common::types::KIID* temp = id_;
  id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kiapi::common::types::KIID* BeginCommitResponse::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_release:kiapi.common.commands.BeginCommitResponse.id)
  
  ::kiapi::common::types::KIID* temp = id_;
  id_ = nullptr;
  return temp;
}
inline ::kiapi::common::types::KIID* BeginCommitResponse::_internal_mutable_id() {
  
  if (id_ == nullptr) {
    auto* p = CreateMaybeMessage<::kiapi::common::types::KIID>(GetArenaForAllocation());
    id_ = p;
  }
  return id_;
}
inline ::kiapi::common::types::KIID* BeginCommitResponse::mutable_id() {
  ::kiapi::common::types::KIID* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:kiapi.common.commands.BeginCommitResponse.id)
  return _msg;
}
inline void BeginCommitResponse::set_allocated_id(::kiapi::common::types::KIID* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id));
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.commands.BeginCommitResponse.id)
}

// -------------------------------------------------------------------

// EndCommit

// .kiapi.common.types.KIID id = 1;
inline bool EndCommit::_internal_has_id() const {
  return this != internal_default_instance() && id_ != nullptr;
}
inline bool EndCommit::has_id() const {
  return _internal_has_id();
}
inline const ::kiapi::common::types::KIID& EndCommit::_internal_id() const {
  const ::kiapi::common::types::KIID* p = id_;
  return p != nullptr ? *p : reinterpret_cast<const ::kiapi::common::types::KIID&>(
      ::kiapi::common::types::_KIID_default_instance_);
}
inline const ::kiapi::common::types::KIID& EndCommit::id() const {
  // @@protoc_insertion_point(field_get:kiapi.common.commands.EndCommit.id)
  return _internal_id();
}
inline void EndCommit::unsafe_arena_set_allocated_id(
    ::kiapi::common::types::KIID* id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  id_ = id;
  if (id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kiapi.common.commands.EndCommit.id)
}
inline ::kiapi::common::types::KIID* EndCommit::release_id() {
  
  ::kiapi::common::types::KIID* temp = id_;
  id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kiapi::common::types::KIID* EndCommit::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_release:kiapi.common.commands.EndCommit.id)
  
  ::kiapi::common::types::KIID* temp = id_;
  id_ = nullptr;
  return temp;
}
inline ::kiapi::common::types::KIID* EndCommit::_internal_mutable_id() {
  
  if (id_ == nullptr) {
    auto* p = CreateMaybeMessage<::kiapi::common::types::KIID>(GetArenaForAllocation());
    id_ = p;
  }
  return id_;
}
inline ::kiapi::common::types::KIID* EndCommit::mutable_id() {
  ::kiapi::common::types::KIID* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:kiapi.common.commands.EndCommit.id)
  return _msg;
}
inline void EndCommit::set_allocated_id(::kiapi::common::types::KIID* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id));
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.commands.EndCommit.id)
}

// .kiapi.common.commands.CommitAction action = 2;
inline void EndCommit::clear_action() {
  action_ = 0;
}
inline ::kiapi::common::commands::CommitAction EndCommit::_internal_action() const {
  return static_cast< ::kiapi::common::commands::CommitAction >(action_);
}
inline ::kiapi::common::commands::CommitAction EndCommit::action() const {
  // @@protoc_insertion_point(field_get:kiapi.common.commands.EndCommit.action)
  return _internal_action();
}
inline void EndCommit::_internal_set_action(::kiapi::common::commands::CommitAction value) {
  
  action_ = value;
}
inline void EndCommit::set_action(::kiapi::common::commands::CommitAction value) {
  _internal_set_action(value);
  // @@protoc_insertion_point(field_set:kiapi.common.commands.EndCommit.action)
}

// string message = 3;
inline void EndCommit::clear_message() {
  message_.ClearToEmpty();
}
inline const std::string& EndCommit::message() const {
  // @@protoc_insertion_point(field_get:kiapi.common.commands.EndCommit.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EndCommit::set_message(ArgT0&& arg0, ArgT... args) {
 
 message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kiapi.common.commands.EndCommit.message)
}
inline std::string* EndCommit::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:kiapi.common.commands.EndCommit.message)
  return _s;
}
inline const std::string& EndCommit::_internal_message() const {
  return message_.Get();
}
inline void EndCommit::_internal_set_message(const std::string& value) {
  
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* EndCommit::_internal_mutable_message() {
  
  return message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* EndCommit::release_message() {
  // @@protoc_insertion_point(field_release:kiapi.common.commands.EndCommit.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void EndCommit::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.commands.EndCommit.message)
}

// -------------------------------------------------------------------

// EndCommitResponse

// -------------------------------------------------------------------

// CreateItems

// .kiapi.common.types.ItemHeader header = 1;
inline bool CreateItems::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool CreateItems::has_header() const {
  return _internal_has_header();
}
inline const ::kiapi::common::types::ItemHeader& CreateItems::_internal_header() const {
  const ::kiapi::common::types::ItemHeader* p = header_;
  return p != nullptr ? *p : reinterpret_cast<const ::kiapi::common::types::ItemHeader&>(
      ::kiapi::common::types::_ItemHeader_default_instance_);
}
inline const ::kiapi::common::types::ItemHeader& CreateItems::header() const {
  // @@protoc_insertion_point(field_get:kiapi.common.commands.CreateItems.header)
  return _internal_header();
}
inline void CreateItems::unsafe_arena_set_allocated_header(
    ::kiapi::common::types::ItemHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kiapi.common.commands.CreateItems.header)
}
inline ::kiapi::common::types::ItemHeader* CreateItems::release_header() {
  
  ::kiapi::common::types::ItemHeader* temp = header_;
  header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kiapi::common::types::ItemHeader* CreateItems::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:kiapi.common.commands.CreateItems.header)
  
  ::kiapi::common::types::ItemHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::kiapi::common::types::ItemHeader* CreateItems::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::kiapi::common::types::ItemHeader>(GetArenaForAllocation());
    header_ = p;
  }
  return header_;
}
inline ::kiapi::common::types::ItemHeader* CreateItems::mutable_header() {
  ::kiapi::common::types::ItemHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:kiapi.common.commands.CreateItems.header)
  return _msg;
}
inline void CreateItems::set_allocated_header(::kiapi::common::types::ItemHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.commands.CreateItems.header)
}

// repeated .google.protobuf.Any items = 2;
inline int CreateItems::_internal_items_size() const {
  return items_.size();
}
inline int CreateItems::items_size() const {
  return _internal_items_size();
}
inline ::PROTOBUF_NAMESPACE_ID::Any* CreateItems::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:kiapi.common.commands.CreateItems.items)
  return items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Any >*
CreateItems::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:kiapi.common.commands.CreateItems.items)
  return &items_;
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& CreateItems::_internal_items(int index) const {
  return items_.Get(index);
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& CreateItems::items(int index) const {
  // @@protoc_insertion_point(field_get:kiapi.common.commands.CreateItems.items)
  return _internal_items(index);
}
inline ::PROTOBUF_NAMESPACE_ID::Any* CreateItems::_internal_add_items() {
  return items_.Add();
}
inline ::PROTOBUF_NAMESPACE_ID::Any* CreateItems::add_items() {
  ::PROTOBUF_NAMESPACE_ID::Any* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:kiapi.common.commands.CreateItems.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Any >&
CreateItems::items() const {
  // @@protoc_insertion_point(field_list:kiapi.common.commands.CreateItems.items)
  return items_;
}

// .kiapi.common.types.KIID container = 3;
inline bool CreateItems::_internal_has_container() const {
  return this != internal_default_instance() && container_ != nullptr;
}
inline bool CreateItems::has_container() const {
  return _internal_has_container();
}
inline const ::kiapi::common::types::KIID& CreateItems::_internal_container() const {
  const ::kiapi::common::types::KIID* p = container_;
  return p != nullptr ? *p : reinterpret_cast<const ::kiapi::common::types::KIID&>(
      ::kiapi::common::types::_KIID_default_instance_);
}
inline const ::kiapi::common::types::KIID& CreateItems::container() const {
  // @@protoc_insertion_point(field_get:kiapi.common.commands.CreateItems.container)
  return _internal_container();
}
inline void CreateItems::unsafe_arena_set_allocated_container(
    ::kiapi::common::types::KIID* container) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(container_);
  }
  container_ = container;
  if (container) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kiapi.common.commands.CreateItems.container)
}
inline ::kiapi::common::types::KIID* CreateItems::release_container() {
  
  ::kiapi::common::types::KIID* temp = container_;
  container_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kiapi::common::types::KIID* CreateItems::unsafe_arena_release_container() {
  // @@protoc_insertion_point(field_release:kiapi.common.commands.CreateItems.container)
  
  ::kiapi::common::types::KIID* temp = container_;
  container_ = nullptr;
  return temp;
}
inline ::kiapi::common::types::KIID* CreateItems::_internal_mutable_container() {
  
  if (container_ == nullptr) {
    auto* p = CreateMaybeMessage<::kiapi::common::types::KIID>(GetArenaForAllocation());
    container_ = p;
  }
  return container_;
}
inline ::kiapi::common::types::KIID* CreateItems::mutable_container() {
  ::kiapi::common::types::KIID* _msg = _internal_mutable_container();
  // @@protoc_insertion_point(field_mutable:kiapi.common.commands.CreateItems.container)
  return _msg;
}
inline void CreateItems::set_allocated_container(::kiapi::common::types::KIID* container) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(container_);
  }
  if (container) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(container));
    if (message_arena != submessage_arena) {
      container = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, container, submessage_arena);
    }
    
  } else {
    
  }
  container_ = container;
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.commands.CreateItems.container)
}

// -------------------------------------------------------------------

// ItemStatus

// .kiapi.common.commands.ItemStatusCode code = 1;
inline void ItemStatus::clear_code() {
  code_ = 0;
}
inline ::kiapi::common::commands::ItemStatusCode ItemStatus::_internal_code() const {
  return static_cast< ::kiapi::common::commands::ItemStatusCode >(code_);
}
inline ::kiapi::common::commands::ItemStatusCode ItemStatus::code() const {
  // @@protoc_insertion_point(field_get:kiapi.common.commands.ItemStatus.code)
  return _internal_code();
}
inline void ItemStatus::_internal_set_code(::kiapi::common::commands::ItemStatusCode value) {
  
  code_ = value;
}
inline void ItemStatus::set_code(::kiapi::common::commands::ItemStatusCode value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:kiapi.common.commands.ItemStatus.code)
}

// string error_message = 2;
inline void ItemStatus::clear_error_message() {
  error_message_.ClearToEmpty();
}
inline const std::string& ItemStatus::error_message() const {
  // @@protoc_insertion_point(field_get:kiapi.common.commands.ItemStatus.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ItemStatus::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kiapi.common.commands.ItemStatus.error_message)
}
inline std::string* ItemStatus::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:kiapi.common.commands.ItemStatus.error_message)
  return _s;
}
inline const std::string& ItemStatus::_internal_error_message() const {
  return error_message_.Get();
}
inline void ItemStatus::_internal_set_error_message(const std::string& value) {
  
  error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ItemStatus::_internal_mutable_error_message() {
  
  return error_message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ItemStatus::release_error_message() {
  // @@protoc_insertion_point(field_release:kiapi.common.commands.ItemStatus.error_message)
  return error_message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ItemStatus::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  error_message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error_message,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (error_message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    error_message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.commands.ItemStatus.error_message)
}

// -------------------------------------------------------------------

// ItemCreationResult

// .kiapi.common.commands.ItemStatus status = 1;
inline bool ItemCreationResult::_internal_has_status() const {
  return this != internal_default_instance() && status_ != nullptr;
}
inline bool ItemCreationResult::has_status() const {
  return _internal_has_status();
}
inline void ItemCreationResult::clear_status() {
  if (GetArenaForAllocation() == nullptr && status_ != nullptr) {
    delete status_;
  }
  status_ = nullptr;
}
inline const ::kiapi::common::commands::ItemStatus& ItemCreationResult::_internal_status() const {
  const ::kiapi::common::commands::ItemStatus* p = status_;
  return p != nullptr ? *p : reinterpret_cast<const ::kiapi::common::commands::ItemStatus&>(
      ::kiapi::common::commands::_ItemStatus_default_instance_);
}
inline const ::kiapi::common::commands::ItemStatus& ItemCreationResult::status() const {
  // @@protoc_insertion_point(field_get:kiapi.common.commands.ItemCreationResult.status)
  return _internal_status();
}
inline void ItemCreationResult::unsafe_arena_set_allocated_status(
    ::kiapi::common::commands::ItemStatus* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kiapi.common.commands.ItemCreationResult.status)
}
inline ::kiapi::common::commands::ItemStatus* ItemCreationResult::release_status() {
  
  ::kiapi::common::commands::ItemStatus* temp = status_;
  status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kiapi::common::commands::ItemStatus* ItemCreationResult::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:kiapi.common.commands.ItemCreationResult.status)
  
  ::kiapi::common::commands::ItemStatus* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::kiapi::common::commands::ItemStatus* ItemCreationResult::_internal_mutable_status() {
  
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::kiapi::common::commands::ItemStatus>(GetArenaForAllocation());
    status_ = p;
  }
  return status_;
}
inline ::kiapi::common::commands::ItemStatus* ItemCreationResult::mutable_status() {
  ::kiapi::common::commands::ItemStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:kiapi.common.commands.ItemCreationResult.status)
  return _msg;
}
inline void ItemCreationResult::set_allocated_status(::kiapi::common::commands::ItemStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::kiapi::common::commands::ItemStatus>::GetOwningArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.commands.ItemCreationResult.status)
}

// .google.protobuf.Any item = 2;
inline bool ItemCreationResult::_internal_has_item() const {
  return this != internal_default_instance() && item_ != nullptr;
}
inline bool ItemCreationResult::has_item() const {
  return _internal_has_item();
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& ItemCreationResult::_internal_item() const {
  const ::PROTOBUF_NAMESPACE_ID::Any* p = item_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Any&>(
      ::PROTOBUF_NAMESPACE_ID::_Any_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& ItemCreationResult::item() const {
  // @@protoc_insertion_point(field_get:kiapi.common.commands.ItemCreationResult.item)
  return _internal_item();
}
inline void ItemCreationResult::unsafe_arena_set_allocated_item(
    ::PROTOBUF_NAMESPACE_ID::Any* item) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(item_);
  }
  item_ = item;
  if (item) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kiapi.common.commands.ItemCreationResult.item)
}
inline ::PROTOBUF_NAMESPACE_ID::Any* ItemCreationResult::release_item() {
  
  ::PROTOBUF_NAMESPACE_ID::Any* temp = item_;
  item_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* ItemCreationResult::unsafe_arena_release_item() {
  // @@protoc_insertion_point(field_release:kiapi.common.commands.ItemCreationResult.item)
  
  ::PROTOBUF_NAMESPACE_ID::Any* temp = item_;
  item_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* ItemCreationResult::_internal_mutable_item() {
  
  if (item_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Any>(GetArenaForAllocation());
    item_ = p;
  }
  return item_;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* ItemCreationResult::mutable_item() {
  ::PROTOBUF_NAMESPACE_ID::Any* _msg = _internal_mutable_item();
  // @@protoc_insertion_point(field_mutable:kiapi.common.commands.ItemCreationResult.item)
  return _msg;
}
inline void ItemCreationResult::set_allocated_item(::PROTOBUF_NAMESPACE_ID::Any* item) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(item_);
  }
  if (item) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(item));
    if (message_arena != submessage_arena) {
      item = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, item, submessage_arena);
    }
    
  } else {
    
  }
  item_ = item;
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.commands.ItemCreationResult.item)
}

// -------------------------------------------------------------------

// CreateItemsResponse

// .kiapi.common.types.ItemHeader header = 1;
inline bool CreateItemsResponse::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool CreateItemsResponse::has_header() const {
  return _internal_has_header();
}
inline const ::kiapi::common::types::ItemHeader& CreateItemsResponse::_internal_header() const {
  const ::kiapi::common::types::ItemHeader* p = header_;
  return p != nullptr ? *p : reinterpret_cast<const ::kiapi::common::types::ItemHeader&>(
      ::kiapi::common::types::_ItemHeader_default_instance_);
}
inline const ::kiapi::common::types::ItemHeader& CreateItemsResponse::header() const {
  // @@protoc_insertion_point(field_get:kiapi.common.commands.CreateItemsResponse.header)
  return _internal_header();
}
inline void CreateItemsResponse::unsafe_arena_set_allocated_header(
    ::kiapi::common::types::ItemHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kiapi.common.commands.CreateItemsResponse.header)
}
inline ::kiapi::common::types::ItemHeader* CreateItemsResponse::release_header() {
  
  ::kiapi::common::types::ItemHeader* temp = header_;
  header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kiapi::common::types::ItemHeader* CreateItemsResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:kiapi.common.commands.CreateItemsResponse.header)
  
  ::kiapi::common::types::ItemHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::kiapi::common::types::ItemHeader* CreateItemsResponse::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::kiapi::common::types::ItemHeader>(GetArenaForAllocation());
    header_ = p;
  }
  return header_;
}
inline ::kiapi::common::types::ItemHeader* CreateItemsResponse::mutable_header() {
  ::kiapi::common::types::ItemHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:kiapi.common.commands.CreateItemsResponse.header)
  return _msg;
}
inline void CreateItemsResponse::set_allocated_header(::kiapi::common::types::ItemHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.commands.CreateItemsResponse.header)
}

// .kiapi.common.types.ItemRequestStatus status = 2;
inline void CreateItemsResponse::clear_status() {
  status_ = 0;
}
inline ::kiapi::common::types::ItemRequestStatus CreateItemsResponse::_internal_status() const {
  return static_cast< ::kiapi::common::types::ItemRequestStatus >(status_);
}
inline ::kiapi::common::types::ItemRequestStatus CreateItemsResponse::status() const {
  // @@protoc_insertion_point(field_get:kiapi.common.commands.CreateItemsResponse.status)
  return _internal_status();
}
inline void CreateItemsResponse::_internal_set_status(::kiapi::common::types::ItemRequestStatus value) {
  
  status_ = value;
}
inline void CreateItemsResponse::set_status(::kiapi::common::types::ItemRequestStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:kiapi.common.commands.CreateItemsResponse.status)
}

// repeated .kiapi.common.commands.ItemCreationResult created_items = 3;
inline int CreateItemsResponse::_internal_created_items_size() const {
  return created_items_.size();
}
inline int CreateItemsResponse::created_items_size() const {
  return _internal_created_items_size();
}
inline void CreateItemsResponse::clear_created_items() {
  created_items_.Clear();
}
inline ::kiapi::common::commands::ItemCreationResult* CreateItemsResponse::mutable_created_items(int index) {
  // @@protoc_insertion_point(field_mutable:kiapi.common.commands.CreateItemsResponse.created_items)
  return created_items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::commands::ItemCreationResult >*
CreateItemsResponse::mutable_created_items() {
  // @@protoc_insertion_point(field_mutable_list:kiapi.common.commands.CreateItemsResponse.created_items)
  return &created_items_;
}
inline const ::kiapi::common::commands::ItemCreationResult& CreateItemsResponse::_internal_created_items(int index) const {
  return created_items_.Get(index);
}
inline const ::kiapi::common::commands::ItemCreationResult& CreateItemsResponse::created_items(int index) const {
  // @@protoc_insertion_point(field_get:kiapi.common.commands.CreateItemsResponse.created_items)
  return _internal_created_items(index);
}
inline ::kiapi::common::commands::ItemCreationResult* CreateItemsResponse::_internal_add_created_items() {
  return created_items_.Add();
}
inline ::kiapi::common::commands::ItemCreationResult* CreateItemsResponse::add_created_items() {
  ::kiapi::common::commands::ItemCreationResult* _add = _internal_add_created_items();
  // @@protoc_insertion_point(field_add:kiapi.common.commands.CreateItemsResponse.created_items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::commands::ItemCreationResult >&
CreateItemsResponse::created_items() const {
  // @@protoc_insertion_point(field_list:kiapi.common.commands.CreateItemsResponse.created_items)
  return created_items_;
}

// -------------------------------------------------------------------

// GetItems

// .kiapi.common.types.ItemHeader header = 1;
inline bool GetItems::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool GetItems::has_header() const {
  return _internal_has_header();
}
inline const ::kiapi::common::types::ItemHeader& GetItems::_internal_header() const {
  const ::kiapi::common::types::ItemHeader* p = header_;
  return p != nullptr ? *p : reinterpret_cast<const ::kiapi::common::types::ItemHeader&>(
      ::kiapi::common::types::_ItemHeader_default_instance_);
}
inline const ::kiapi::common::types::ItemHeader& GetItems::header() const {
  // @@protoc_insertion_point(field_get:kiapi.common.commands.GetItems.header)
  return _internal_header();
}
inline void GetItems::unsafe_arena_set_allocated_header(
    ::kiapi::common::types::ItemHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kiapi.common.commands.GetItems.header)
}
inline ::kiapi::common::types::ItemHeader* GetItems::release_header() {
  
  ::kiapi::common::types::ItemHeader* temp = header_;
  header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kiapi::common::types::ItemHeader* GetItems::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:kiapi.common.commands.GetItems.header)
  
  ::kiapi::common::types::ItemHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::kiapi::common::types::ItemHeader* GetItems::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::kiapi::common::types::ItemHeader>(GetArenaForAllocation());
    header_ = p;
  }
  return header_;
}
inline ::kiapi::common::types::ItemHeader* GetItems::mutable_header() {
  ::kiapi::common::types::ItemHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:kiapi.common.commands.GetItems.header)
  return _msg;
}
inline void GetItems::set_allocated_header(::kiapi::common::types::ItemHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.commands.GetItems.header)
}

// repeated .kiapi.common.types.KiCadObjectType types = 2;
inline int GetItems::_internal_types_size() const {
  return types_.size();
}
inline int GetItems::types_size() const {
  return _internal_types_size();
}
inline void GetItems::clear_types() {
  types_.Clear();
}
inline ::kiapi::common::types::KiCadObjectType GetItems::_internal_types(int index) const {
  return static_cast< ::kiapi::common::types::KiCadObjectType >(types_.Get(index));
}
inline ::kiapi::common::types::KiCadObjectType GetItems::types(int index) const {
  // @@protoc_insertion_point(field_get:kiapi.common.commands.GetItems.types)
  return _internal_types(index);
}
inline void GetItems::set_types(int index, ::kiapi::common::types::KiCadObjectType value) {
  types_.Set(index, value);
  // @@protoc_insertion_point(field_set:kiapi.common.commands.GetItems.types)
}
inline void GetItems::_internal_add_types(::kiapi::common::types::KiCadObjectType value) {
  types_.Add(value);
}
inline void GetItems::add_types(::kiapi::common::types::KiCadObjectType value) {
  _internal_add_types(value);
  // @@protoc_insertion_point(field_add:kiapi.common.commands.GetItems.types)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
GetItems::types() const {
  // @@protoc_insertion_point(field_list:kiapi.common.commands.GetItems.types)
  return types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
GetItems::_internal_mutable_types() {
  return &types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
GetItems::mutable_types() {
  // @@protoc_insertion_point(field_mutable_list:kiapi.common.commands.GetItems.types)
  return _internal_mutable_types();
}

// -------------------------------------------------------------------

// GetItemsResponse

// .kiapi.common.types.ItemHeader header = 1;
inline bool GetItemsResponse::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool GetItemsResponse::has_header() const {
  return _internal_has_header();
}
inline const ::kiapi::common::types::ItemHeader& GetItemsResponse::_internal_header() const {
  const ::kiapi::common::types::ItemHeader* p = header_;
  return p != nullptr ? *p : reinterpret_cast<const ::kiapi::common::types::ItemHeader&>(
      ::kiapi::common::types::_ItemHeader_default_instance_);
}
inline const ::kiapi::common::types::ItemHeader& GetItemsResponse::header() const {
  // @@protoc_insertion_point(field_get:kiapi.common.commands.GetItemsResponse.header)
  return _internal_header();
}
inline void GetItemsResponse::unsafe_arena_set_allocated_header(
    ::kiapi::common::types::ItemHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kiapi.common.commands.GetItemsResponse.header)
}
inline ::kiapi::common::types::ItemHeader* GetItemsResponse::release_header() {
  
  ::kiapi::common::types::ItemHeader* temp = header_;
  header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kiapi::common::types::ItemHeader* GetItemsResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:kiapi.common.commands.GetItemsResponse.header)
  
  ::kiapi::common::types::ItemHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::kiapi::common::types::ItemHeader* GetItemsResponse::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::kiapi::common::types::ItemHeader>(GetArenaForAllocation());
    header_ = p;
  }
  return header_;
}
inline ::kiapi::common::types::ItemHeader* GetItemsResponse::mutable_header() {
  ::kiapi::common::types::ItemHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:kiapi.common.commands.GetItemsResponse.header)
  return _msg;
}
inline void GetItemsResponse::set_allocated_header(::kiapi::common::types::ItemHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.commands.GetItemsResponse.header)
}

// .kiapi.common.types.ItemRequestStatus status = 2;
inline void GetItemsResponse::clear_status() {
  status_ = 0;
}
inline ::kiapi::common::types::ItemRequestStatus GetItemsResponse::_internal_status() const {
  return static_cast< ::kiapi::common::types::ItemRequestStatus >(status_);
}
inline ::kiapi::common::types::ItemRequestStatus GetItemsResponse::status() const {
  // @@protoc_insertion_point(field_get:kiapi.common.commands.GetItemsResponse.status)
  return _internal_status();
}
inline void GetItemsResponse::_internal_set_status(::kiapi::common::types::ItemRequestStatus value) {
  
  status_ = value;
}
inline void GetItemsResponse::set_status(::kiapi::common::types::ItemRequestStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:kiapi.common.commands.GetItemsResponse.status)
}

// repeated .google.protobuf.Any items = 3;
inline int GetItemsResponse::_internal_items_size() const {
  return items_.size();
}
inline int GetItemsResponse::items_size() const {
  return _internal_items_size();
}
inline ::PROTOBUF_NAMESPACE_ID::Any* GetItemsResponse::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:kiapi.common.commands.GetItemsResponse.items)
  return items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Any >*
GetItemsResponse::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:kiapi.common.commands.GetItemsResponse.items)
  return &items_;
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& GetItemsResponse::_internal_items(int index) const {
  return items_.Get(index);
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& GetItemsResponse::items(int index) const {
  // @@protoc_insertion_point(field_get:kiapi.common.commands.GetItemsResponse.items)
  return _internal_items(index);
}
inline ::PROTOBUF_NAMESPACE_ID::Any* GetItemsResponse::_internal_add_items() {
  return items_.Add();
}
inline ::PROTOBUF_NAMESPACE_ID::Any* GetItemsResponse::add_items() {
  ::PROTOBUF_NAMESPACE_ID::Any* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:kiapi.common.commands.GetItemsResponse.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Any >&
GetItemsResponse::items() const {
  // @@protoc_insertion_point(field_list:kiapi.common.commands.GetItemsResponse.items)
  return items_;
}

// -------------------------------------------------------------------

// UpdateItems

// .kiapi.common.types.ItemHeader header = 1;
inline bool UpdateItems::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool UpdateItems::has_header() const {
  return _internal_has_header();
}
inline const ::kiapi::common::types::ItemHeader& UpdateItems::_internal_header() const {
  const ::kiapi::common::types::ItemHeader* p = header_;
  return p != nullptr ? *p : reinterpret_cast<const ::kiapi::common::types::ItemHeader&>(
      ::kiapi::common::types::_ItemHeader_default_instance_);
}
inline const ::kiapi::common::types::ItemHeader& UpdateItems::header() const {
  // @@protoc_insertion_point(field_get:kiapi.common.commands.UpdateItems.header)
  return _internal_header();
}
inline void UpdateItems::unsafe_arena_set_allocated_header(
    ::kiapi::common::types::ItemHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kiapi.common.commands.UpdateItems.header)
}
inline ::kiapi::common::types::ItemHeader* UpdateItems::release_header() {
  
  ::kiapi::common::types::ItemHeader* temp = header_;
  header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kiapi::common::types::ItemHeader* UpdateItems::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:kiapi.common.commands.UpdateItems.header)
  
  ::kiapi::common::types::ItemHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::kiapi::common::types::ItemHeader* UpdateItems::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::kiapi::common::types::ItemHeader>(GetArenaForAllocation());
    header_ = p;
  }
  return header_;
}
inline ::kiapi::common::types::ItemHeader* UpdateItems::mutable_header() {
  ::kiapi::common::types::ItemHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:kiapi.common.commands.UpdateItems.header)
  return _msg;
}
inline void UpdateItems::set_allocated_header(::kiapi::common::types::ItemHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.commands.UpdateItems.header)
}

// repeated .google.protobuf.Any items = 2;
inline int UpdateItems::_internal_items_size() const {
  return items_.size();
}
inline int UpdateItems::items_size() const {
  return _internal_items_size();
}
inline ::PROTOBUF_NAMESPACE_ID::Any* UpdateItems::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:kiapi.common.commands.UpdateItems.items)
  return items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Any >*
UpdateItems::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:kiapi.common.commands.UpdateItems.items)
  return &items_;
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& UpdateItems::_internal_items(int index) const {
  return items_.Get(index);
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& UpdateItems::items(int index) const {
  // @@protoc_insertion_point(field_get:kiapi.common.commands.UpdateItems.items)
  return _internal_items(index);
}
inline ::PROTOBUF_NAMESPACE_ID::Any* UpdateItems::_internal_add_items() {
  return items_.Add();
}
inline ::PROTOBUF_NAMESPACE_ID::Any* UpdateItems::add_items() {
  ::PROTOBUF_NAMESPACE_ID::Any* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:kiapi.common.commands.UpdateItems.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Any >&
UpdateItems::items() const {
  // @@protoc_insertion_point(field_list:kiapi.common.commands.UpdateItems.items)
  return items_;
}

// -------------------------------------------------------------------

// ItemUpdateResult

// .kiapi.common.commands.ItemStatus status = 1;
inline bool ItemUpdateResult::_internal_has_status() const {
  return this != internal_default_instance() && status_ != nullptr;
}
inline bool ItemUpdateResult::has_status() const {
  return _internal_has_status();
}
inline void ItemUpdateResult::clear_status() {
  if (GetArenaForAllocation() == nullptr && status_ != nullptr) {
    delete status_;
  }
  status_ = nullptr;
}
inline const ::kiapi::common::commands::ItemStatus& ItemUpdateResult::_internal_status() const {
  const ::kiapi::common::commands::ItemStatus* p = status_;
  return p != nullptr ? *p : reinterpret_cast<const ::kiapi::common::commands::ItemStatus&>(
      ::kiapi::common::commands::_ItemStatus_default_instance_);
}
inline const ::kiapi::common::commands::ItemStatus& ItemUpdateResult::status() const {
  // @@protoc_insertion_point(field_get:kiapi.common.commands.ItemUpdateResult.status)
  return _internal_status();
}
inline void ItemUpdateResult::unsafe_arena_set_allocated_status(
    ::kiapi::common::commands::ItemStatus* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kiapi.common.commands.ItemUpdateResult.status)
}
inline ::kiapi::common::commands::ItemStatus* ItemUpdateResult::release_status() {
  
  ::kiapi::common::commands::ItemStatus* temp = status_;
  status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kiapi::common::commands::ItemStatus* ItemUpdateResult::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:kiapi.common.commands.ItemUpdateResult.status)
  
  ::kiapi::common::commands::ItemStatus* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::kiapi::common::commands::ItemStatus* ItemUpdateResult::_internal_mutable_status() {
  
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::kiapi::common::commands::ItemStatus>(GetArenaForAllocation());
    status_ = p;
  }
  return status_;
}
inline ::kiapi::common::commands::ItemStatus* ItemUpdateResult::mutable_status() {
  ::kiapi::common::commands::ItemStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:kiapi.common.commands.ItemUpdateResult.status)
  return _msg;
}
inline void ItemUpdateResult::set_allocated_status(::kiapi::common::commands::ItemStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::kiapi::common::commands::ItemStatus>::GetOwningArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.commands.ItemUpdateResult.status)
}

// .google.protobuf.Any item = 2;
inline bool ItemUpdateResult::_internal_has_item() const {
  return this != internal_default_instance() && item_ != nullptr;
}
inline bool ItemUpdateResult::has_item() const {
  return _internal_has_item();
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& ItemUpdateResult::_internal_item() const {
  const ::PROTOBUF_NAMESPACE_ID::Any* p = item_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Any&>(
      ::PROTOBUF_NAMESPACE_ID::_Any_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& ItemUpdateResult::item() const {
  // @@protoc_insertion_point(field_get:kiapi.common.commands.ItemUpdateResult.item)
  return _internal_item();
}
inline void ItemUpdateResult::unsafe_arena_set_allocated_item(
    ::PROTOBUF_NAMESPACE_ID::Any* item) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(item_);
  }
  item_ = item;
  if (item) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kiapi.common.commands.ItemUpdateResult.item)
}
inline ::PROTOBUF_NAMESPACE_ID::Any* ItemUpdateResult::release_item() {
  
  ::PROTOBUF_NAMESPACE_ID::Any* temp = item_;
  item_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* ItemUpdateResult::unsafe_arena_release_item() {
  // @@protoc_insertion_point(field_release:kiapi.common.commands.ItemUpdateResult.item)
  
  ::PROTOBUF_NAMESPACE_ID::Any* temp = item_;
  item_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* ItemUpdateResult::_internal_mutable_item() {
  
  if (item_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Any>(GetArenaForAllocation());
    item_ = p;
  }
  return item_;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* ItemUpdateResult::mutable_item() {
  ::PROTOBUF_NAMESPACE_ID::Any* _msg = _internal_mutable_item();
  // @@protoc_insertion_point(field_mutable:kiapi.common.commands.ItemUpdateResult.item)
  return _msg;
}
inline void ItemUpdateResult::set_allocated_item(::PROTOBUF_NAMESPACE_ID::Any* item) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(item_);
  }
  if (item) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(item));
    if (message_arena != submessage_arena) {
      item = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, item, submessage_arena);
    }
    
  } else {
    
  }
  item_ = item;
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.commands.ItemUpdateResult.item)
}

// -------------------------------------------------------------------

// UpdateItemsResponse

// .kiapi.common.types.ItemHeader header = 1;
inline bool UpdateItemsResponse::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool UpdateItemsResponse::has_header() const {
  return _internal_has_header();
}
inline const ::kiapi::common::types::ItemHeader& UpdateItemsResponse::_internal_header() const {
  const ::kiapi::common::types::ItemHeader* p = header_;
  return p != nullptr ? *p : reinterpret_cast<const ::kiapi::common::types::ItemHeader&>(
      ::kiapi::common::types::_ItemHeader_default_instance_);
}
inline const ::kiapi::common::types::ItemHeader& UpdateItemsResponse::header() const {
  // @@protoc_insertion_point(field_get:kiapi.common.commands.UpdateItemsResponse.header)
  return _internal_header();
}
inline void UpdateItemsResponse::unsafe_arena_set_allocated_header(
    ::kiapi::common::types::ItemHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kiapi.common.commands.UpdateItemsResponse.header)
}
inline ::kiapi::common::types::ItemHeader* UpdateItemsResponse::release_header() {
  
  ::kiapi::common::types::ItemHeader* temp = header_;
  header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kiapi::common::types::ItemHeader* UpdateItemsResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:kiapi.common.commands.UpdateItemsResponse.header)
  
  ::kiapi::common::types::ItemHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::kiapi::common::types::ItemHeader* UpdateItemsResponse::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::kiapi::common::types::ItemHeader>(GetArenaForAllocation());
    header_ = p;
  }
  return header_;
}
inline ::kiapi::common::types::ItemHeader* UpdateItemsResponse::mutable_header() {
  ::kiapi::common::types::ItemHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:kiapi.common.commands.UpdateItemsResponse.header)
  return _msg;
}
inline void UpdateItemsResponse::set_allocated_header(::kiapi::common::types::ItemHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.commands.UpdateItemsResponse.header)
}

// .kiapi.common.types.ItemRequestStatus status = 2;
inline void UpdateItemsResponse::clear_status() {
  status_ = 0;
}
inline ::kiapi::common::types::ItemRequestStatus UpdateItemsResponse::_internal_status() const {
  return static_cast< ::kiapi::common::types::ItemRequestStatus >(status_);
}
inline ::kiapi::common::types::ItemRequestStatus UpdateItemsResponse::status() const {
  // @@protoc_insertion_point(field_get:kiapi.common.commands.UpdateItemsResponse.status)
  return _internal_status();
}
inline void UpdateItemsResponse::_internal_set_status(::kiapi::common::types::ItemRequestStatus value) {
  
  status_ = value;
}
inline void UpdateItemsResponse::set_status(::kiapi::common::types::ItemRequestStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:kiapi.common.commands.UpdateItemsResponse.status)
}

// repeated .kiapi.common.commands.ItemUpdateResult updated_items = 3;
inline int UpdateItemsResponse::_internal_updated_items_size() const {
  return updated_items_.size();
}
inline int UpdateItemsResponse::updated_items_size() const {
  return _internal_updated_items_size();
}
inline void UpdateItemsResponse::clear_updated_items() {
  updated_items_.Clear();
}
inline ::kiapi::common::commands::ItemUpdateResult* UpdateItemsResponse::mutable_updated_items(int index) {
  // @@protoc_insertion_point(field_mutable:kiapi.common.commands.UpdateItemsResponse.updated_items)
  return updated_items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::commands::ItemUpdateResult >*
UpdateItemsResponse::mutable_updated_items() {
  // @@protoc_insertion_point(field_mutable_list:kiapi.common.commands.UpdateItemsResponse.updated_items)
  return &updated_items_;
}
inline const ::kiapi::common::commands::ItemUpdateResult& UpdateItemsResponse::_internal_updated_items(int index) const {
  return updated_items_.Get(index);
}
inline const ::kiapi::common::commands::ItemUpdateResult& UpdateItemsResponse::updated_items(int index) const {
  // @@protoc_insertion_point(field_get:kiapi.common.commands.UpdateItemsResponse.updated_items)
  return _internal_updated_items(index);
}
inline ::kiapi::common::commands::ItemUpdateResult* UpdateItemsResponse::_internal_add_updated_items() {
  return updated_items_.Add();
}
inline ::kiapi::common::commands::ItemUpdateResult* UpdateItemsResponse::add_updated_items() {
  ::kiapi::common::commands::ItemUpdateResult* _add = _internal_add_updated_items();
  // @@protoc_insertion_point(field_add:kiapi.common.commands.UpdateItemsResponse.updated_items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::commands::ItemUpdateResult >&
UpdateItemsResponse::updated_items() const {
  // @@protoc_insertion_point(field_list:kiapi.common.commands.UpdateItemsResponse.updated_items)
  return updated_items_;
}

// -------------------------------------------------------------------

// DeleteItems

// .kiapi.common.types.ItemHeader header = 1;
inline bool DeleteItems::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool DeleteItems::has_header() const {
  return _internal_has_header();
}
inline const ::kiapi::common::types::ItemHeader& DeleteItems::_internal_header() const {
  const ::kiapi::common::types::ItemHeader* p = header_;
  return p != nullptr ? *p : reinterpret_cast<const ::kiapi::common::types::ItemHeader&>(
      ::kiapi::common::types::_ItemHeader_default_instance_);
}
inline const ::kiapi::common::types::ItemHeader& DeleteItems::header() const {
  // @@protoc_insertion_point(field_get:kiapi.common.commands.DeleteItems.header)
  return _internal_header();
}
inline void DeleteItems::unsafe_arena_set_allocated_header(
    ::kiapi::common::types::ItemHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kiapi.common.commands.DeleteItems.header)
}
inline ::kiapi::common::types::ItemHeader* DeleteItems::release_header() {
  
  ::kiapi::common::types::ItemHeader* temp = header_;
  header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kiapi::common::types::ItemHeader* DeleteItems::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:kiapi.common.commands.DeleteItems.header)
  
  ::kiapi::common::types::ItemHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::kiapi::common::types::ItemHeader* DeleteItems::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::kiapi::common::types::ItemHeader>(GetArenaForAllocation());
    header_ = p;
  }
  return header_;
}
inline ::kiapi::common::types::ItemHeader* DeleteItems::mutable_header() {
  ::kiapi::common::types::ItemHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:kiapi.common.commands.DeleteItems.header)
  return _msg;
}
inline void DeleteItems::set_allocated_header(::kiapi::common::types::ItemHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.commands.DeleteItems.header)
}

// repeated .kiapi.common.types.KIID item_ids = 2;
inline int DeleteItems::_internal_item_ids_size() const {
  return item_ids_.size();
}
inline int DeleteItems::item_ids_size() const {
  return _internal_item_ids_size();
}
inline ::kiapi::common::types::KIID* DeleteItems::mutable_item_ids(int index) {
  // @@protoc_insertion_point(field_mutable:kiapi.common.commands.DeleteItems.item_ids)
  return item_ids_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::types::KIID >*
DeleteItems::mutable_item_ids() {
  // @@protoc_insertion_point(field_mutable_list:kiapi.common.commands.DeleteItems.item_ids)
  return &item_ids_;
}
inline const ::kiapi::common::types::KIID& DeleteItems::_internal_item_ids(int index) const {
  return item_ids_.Get(index);
}
inline const ::kiapi::common::types::KIID& DeleteItems::item_ids(int index) const {
  // @@protoc_insertion_point(field_get:kiapi.common.commands.DeleteItems.item_ids)
  return _internal_item_ids(index);
}
inline ::kiapi::common::types::KIID* DeleteItems::_internal_add_item_ids() {
  return item_ids_.Add();
}
inline ::kiapi::common::types::KIID* DeleteItems::add_item_ids() {
  ::kiapi::common::types::KIID* _add = _internal_add_item_ids();
  // @@protoc_insertion_point(field_add:kiapi.common.commands.DeleteItems.item_ids)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::types::KIID >&
DeleteItems::item_ids() const {
  // @@protoc_insertion_point(field_list:kiapi.common.commands.DeleteItems.item_ids)
  return item_ids_;
}

// -------------------------------------------------------------------

// ItemDeletionResult

// .kiapi.common.types.KIID id = 1;
inline bool ItemDeletionResult::_internal_has_id() const {
  return this != internal_default_instance() && id_ != nullptr;
}
inline bool ItemDeletionResult::has_id() const {
  return _internal_has_id();
}
inline const ::kiapi::common::types::KIID& ItemDeletionResult::_internal_id() const {
  const ::kiapi::common::types::KIID* p = id_;
  return p != nullptr ? *p : reinterpret_cast<const ::kiapi::common::types::KIID&>(
      ::kiapi::common::types::_KIID_default_instance_);
}
inline const ::kiapi::common::types::KIID& ItemDeletionResult::id() const {
  // @@protoc_insertion_point(field_get:kiapi.common.commands.ItemDeletionResult.id)
  return _internal_id();
}
inline void ItemDeletionResult::unsafe_arena_set_allocated_id(
    ::kiapi::common::types::KIID* id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  id_ = id;
  if (id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kiapi.common.commands.ItemDeletionResult.id)
}
inline ::kiapi::common::types::KIID* ItemDeletionResult::release_id() {
  
  ::kiapi::common::types::KIID* temp = id_;
  id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kiapi::common::types::KIID* ItemDeletionResult::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_release:kiapi.common.commands.ItemDeletionResult.id)
  
  ::kiapi::common::types::KIID* temp = id_;
  id_ = nullptr;
  return temp;
}
inline ::kiapi::common::types::KIID* ItemDeletionResult::_internal_mutable_id() {
  
  if (id_ == nullptr) {
    auto* p = CreateMaybeMessage<::kiapi::common::types::KIID>(GetArenaForAllocation());
    id_ = p;
  }
  return id_;
}
inline ::kiapi::common::types::KIID* ItemDeletionResult::mutable_id() {
  ::kiapi::common::types::KIID* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:kiapi.common.commands.ItemDeletionResult.id)
  return _msg;
}
inline void ItemDeletionResult::set_allocated_id(::kiapi::common::types::KIID* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id));
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.commands.ItemDeletionResult.id)
}

// .kiapi.common.commands.ItemDeletionStatus status = 2;
inline void ItemDeletionResult::clear_status() {
  status_ = 0;
}
inline ::kiapi::common::commands::ItemDeletionStatus ItemDeletionResult::_internal_status() const {
  return static_cast< ::kiapi::common::commands::ItemDeletionStatus >(status_);
}
inline ::kiapi::common::commands::ItemDeletionStatus ItemDeletionResult::status() const {
  // @@protoc_insertion_point(field_get:kiapi.common.commands.ItemDeletionResult.status)
  return _internal_status();
}
inline void ItemDeletionResult::_internal_set_status(::kiapi::common::commands::ItemDeletionStatus value) {
  
  status_ = value;
}
inline void ItemDeletionResult::set_status(::kiapi::common::commands::ItemDeletionStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:kiapi.common.commands.ItemDeletionResult.status)
}

// -------------------------------------------------------------------

// DeleteItemsResponse

// .kiapi.common.types.ItemHeader header = 1;
inline bool DeleteItemsResponse::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool DeleteItemsResponse::has_header() const {
  return _internal_has_header();
}
inline const ::kiapi::common::types::ItemHeader& DeleteItemsResponse::_internal_header() const {
  const ::kiapi::common::types::ItemHeader* p = header_;
  return p != nullptr ? *p : reinterpret_cast<const ::kiapi::common::types::ItemHeader&>(
      ::kiapi::common::types::_ItemHeader_default_instance_);
}
inline const ::kiapi::common::types::ItemHeader& DeleteItemsResponse::header() const {
  // @@protoc_insertion_point(field_get:kiapi.common.commands.DeleteItemsResponse.header)
  return _internal_header();
}
inline void DeleteItemsResponse::unsafe_arena_set_allocated_header(
    ::kiapi::common::types::ItemHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kiapi.common.commands.DeleteItemsResponse.header)
}
inline ::kiapi::common::types::ItemHeader* DeleteItemsResponse::release_header() {
  
  ::kiapi::common::types::ItemHeader* temp = header_;
  header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kiapi::common::types::ItemHeader* DeleteItemsResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:kiapi.common.commands.DeleteItemsResponse.header)
  
  ::kiapi::common::types::ItemHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::kiapi::common::types::ItemHeader* DeleteItemsResponse::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::kiapi::common::types::ItemHeader>(GetArenaForAllocation());
    header_ = p;
  }
  return header_;
}
inline ::kiapi::common::types::ItemHeader* DeleteItemsResponse::mutable_header() {
  ::kiapi::common::types::ItemHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:kiapi.common.commands.DeleteItemsResponse.header)
  return _msg;
}
inline void DeleteItemsResponse::set_allocated_header(::kiapi::common::types::ItemHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.commands.DeleteItemsResponse.header)
}

// .kiapi.common.types.ItemRequestStatus status = 2;
inline void DeleteItemsResponse::clear_status() {
  status_ = 0;
}
inline ::kiapi::common::types::ItemRequestStatus DeleteItemsResponse::_internal_status() const {
  return static_cast< ::kiapi::common::types::ItemRequestStatus >(status_);
}
inline ::kiapi::common::types::ItemRequestStatus DeleteItemsResponse::status() const {
  // @@protoc_insertion_point(field_get:kiapi.common.commands.DeleteItemsResponse.status)
  return _internal_status();
}
inline void DeleteItemsResponse::_internal_set_status(::kiapi::common::types::ItemRequestStatus value) {
  
  status_ = value;
}
inline void DeleteItemsResponse::set_status(::kiapi::common::types::ItemRequestStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:kiapi.common.commands.DeleteItemsResponse.status)
}

// repeated .kiapi.common.commands.ItemDeletionResult deleted_items = 3;
inline int DeleteItemsResponse::_internal_deleted_items_size() const {
  return deleted_items_.size();
}
inline int DeleteItemsResponse::deleted_items_size() const {
  return _internal_deleted_items_size();
}
inline void DeleteItemsResponse::clear_deleted_items() {
  deleted_items_.Clear();
}
inline ::kiapi::common::commands::ItemDeletionResult* DeleteItemsResponse::mutable_deleted_items(int index) {
  // @@protoc_insertion_point(field_mutable:kiapi.common.commands.DeleteItemsResponse.deleted_items)
  return deleted_items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::commands::ItemDeletionResult >*
DeleteItemsResponse::mutable_deleted_items() {
  // @@protoc_insertion_point(field_mutable_list:kiapi.common.commands.DeleteItemsResponse.deleted_items)
  return &deleted_items_;
}
inline const ::kiapi::common::commands::ItemDeletionResult& DeleteItemsResponse::_internal_deleted_items(int index) const {
  return deleted_items_.Get(index);
}
inline const ::kiapi::common::commands::ItemDeletionResult& DeleteItemsResponse::deleted_items(int index) const {
  // @@protoc_insertion_point(field_get:kiapi.common.commands.DeleteItemsResponse.deleted_items)
  return _internal_deleted_items(index);
}
inline ::kiapi::common::commands::ItemDeletionResult* DeleteItemsResponse::_internal_add_deleted_items() {
  return deleted_items_.Add();
}
inline ::kiapi::common::commands::ItemDeletionResult* DeleteItemsResponse::add_deleted_items() {
  ::kiapi::common::commands::ItemDeletionResult* _add = _internal_add_deleted_items();
  // @@protoc_insertion_point(field_add:kiapi.common.commands.DeleteItemsResponse.deleted_items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::commands::ItemDeletionResult >&
DeleteItemsResponse::deleted_items() const {
  // @@protoc_insertion_point(field_list:kiapi.common.commands.DeleteItemsResponse.deleted_items)
  return deleted_items_;
}

// -------------------------------------------------------------------

// GetBoundingBox

// .kiapi.common.types.ItemHeader header = 1;
inline bool GetBoundingBox::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool GetBoundingBox::has_header() const {
  return _internal_has_header();
}
inline const ::kiapi::common::types::ItemHeader& GetBoundingBox::_internal_header() const {
  const ::kiapi::common::types::ItemHeader* p = header_;
  return p != nullptr ? *p : reinterpret_cast<const ::kiapi::common::types::ItemHeader&>(
      ::kiapi::common::types::_ItemHeader_default_instance_);
}
inline const ::kiapi::common::types::ItemHeader& GetBoundingBox::header() const {
  // @@protoc_insertion_point(field_get:kiapi.common.commands.GetBoundingBox.header)
  return _internal_header();
}
inline void GetBoundingBox::unsafe_arena_set_allocated_header(
    ::kiapi::common::types::ItemHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kiapi.common.commands.GetBoundingBox.header)
}
inline ::kiapi::common::types::ItemHeader* GetBoundingBox::release_header() {
  
  ::kiapi::common::types::ItemHeader* temp = header_;
  header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kiapi::common::types::ItemHeader* GetBoundingBox::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:kiapi.common.commands.GetBoundingBox.header)
  
  ::kiapi::common::types::ItemHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::kiapi::common::types::ItemHeader* GetBoundingBox::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::kiapi::common::types::ItemHeader>(GetArenaForAllocation());
    header_ = p;
  }
  return header_;
}
inline ::kiapi::common::types::ItemHeader* GetBoundingBox::mutable_header() {
  ::kiapi::common::types::ItemHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:kiapi.common.commands.GetBoundingBox.header)
  return _msg;
}
inline void GetBoundingBox::set_allocated_header(::kiapi::common::types::ItemHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.commands.GetBoundingBox.header)
}

// repeated .kiapi.common.types.KIID items = 2;
inline int GetBoundingBox::_internal_items_size() const {
  return items_.size();
}
inline int GetBoundingBox::items_size() const {
  return _internal_items_size();
}
inline ::kiapi::common::types::KIID* GetBoundingBox::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:kiapi.common.commands.GetBoundingBox.items)
  return items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::types::KIID >*
GetBoundingBox::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:kiapi.common.commands.GetBoundingBox.items)
  return &items_;
}
inline const ::kiapi::common::types::KIID& GetBoundingBox::_internal_items(int index) const {
  return items_.Get(index);
}
inline const ::kiapi::common::types::KIID& GetBoundingBox::items(int index) const {
  // @@protoc_insertion_point(field_get:kiapi.common.commands.GetBoundingBox.items)
  return _internal_items(index);
}
inline ::kiapi::common::types::KIID* GetBoundingBox::_internal_add_items() {
  return items_.Add();
}
inline ::kiapi::common::types::KIID* GetBoundingBox::add_items() {
  ::kiapi::common::types::KIID* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:kiapi.common.commands.GetBoundingBox.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::types::KIID >&
GetBoundingBox::items() const {
  // @@protoc_insertion_point(field_list:kiapi.common.commands.GetBoundingBox.items)
  return items_;
}

// .kiapi.common.commands.BoundingBoxMode mode = 3;
inline void GetBoundingBox::clear_mode() {
  mode_ = 0;
}
inline ::kiapi::common::commands::BoundingBoxMode GetBoundingBox::_internal_mode() const {
  return static_cast< ::kiapi::common::commands::BoundingBoxMode >(mode_);
}
inline ::kiapi::common::commands::BoundingBoxMode GetBoundingBox::mode() const {
  // @@protoc_insertion_point(field_get:kiapi.common.commands.GetBoundingBox.mode)
  return _internal_mode();
}
inline void GetBoundingBox::_internal_set_mode(::kiapi::common::commands::BoundingBoxMode value) {
  
  mode_ = value;
}
inline void GetBoundingBox::set_mode(::kiapi::common::commands::BoundingBoxMode value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:kiapi.common.commands.GetBoundingBox.mode)
}

// -------------------------------------------------------------------

// GetBoundingBoxResponse

// repeated .kiapi.common.types.KIID items = 1;
inline int GetBoundingBoxResponse::_internal_items_size() const {
  return items_.size();
}
inline int GetBoundingBoxResponse::items_size() const {
  return _internal_items_size();
}
inline ::kiapi::common::types::KIID* GetBoundingBoxResponse::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:kiapi.common.commands.GetBoundingBoxResponse.items)
  return items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::types::KIID >*
GetBoundingBoxResponse::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:kiapi.common.commands.GetBoundingBoxResponse.items)
  return &items_;
}
inline const ::kiapi::common::types::KIID& GetBoundingBoxResponse::_internal_items(int index) const {
  return items_.Get(index);
}
inline const ::kiapi::common::types::KIID& GetBoundingBoxResponse::items(int index) const {
  // @@protoc_insertion_point(field_get:kiapi.common.commands.GetBoundingBoxResponse.items)
  return _internal_items(index);
}
inline ::kiapi::common::types::KIID* GetBoundingBoxResponse::_internal_add_items() {
  return items_.Add();
}
inline ::kiapi::common::types::KIID* GetBoundingBoxResponse::add_items() {
  ::kiapi::common::types::KIID* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:kiapi.common.commands.GetBoundingBoxResponse.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::types::KIID >&
GetBoundingBoxResponse::items() const {
  // @@protoc_insertion_point(field_list:kiapi.common.commands.GetBoundingBoxResponse.items)
  return items_;
}

// repeated .kiapi.common.types.Box2 boxes = 2;
inline int GetBoundingBoxResponse::_internal_boxes_size() const {
  return boxes_.size();
}
inline int GetBoundingBoxResponse::boxes_size() const {
  return _internal_boxes_size();
}
inline ::kiapi::common::types::Box2* GetBoundingBoxResponse::mutable_boxes(int index) {
  // @@protoc_insertion_point(field_mutable:kiapi.common.commands.GetBoundingBoxResponse.boxes)
  return boxes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::types::Box2 >*
GetBoundingBoxResponse::mutable_boxes() {
  // @@protoc_insertion_point(field_mutable_list:kiapi.common.commands.GetBoundingBoxResponse.boxes)
  return &boxes_;
}
inline const ::kiapi::common::types::Box2& GetBoundingBoxResponse::_internal_boxes(int index) const {
  return boxes_.Get(index);
}
inline const ::kiapi::common::types::Box2& GetBoundingBoxResponse::boxes(int index) const {
  // @@protoc_insertion_point(field_get:kiapi.common.commands.GetBoundingBoxResponse.boxes)
  return _internal_boxes(index);
}
inline ::kiapi::common::types::Box2* GetBoundingBoxResponse::_internal_add_boxes() {
  return boxes_.Add();
}
inline ::kiapi::common::types::Box2* GetBoundingBoxResponse::add_boxes() {
  ::kiapi::common::types::Box2* _add = _internal_add_boxes();
  // @@protoc_insertion_point(field_add:kiapi.common.commands.GetBoundingBoxResponse.boxes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::types::Box2 >&
GetBoundingBoxResponse::boxes() const {
  // @@protoc_insertion_point(field_list:kiapi.common.commands.GetBoundingBoxResponse.boxes)
  return boxes_;
}

// -------------------------------------------------------------------

// GetSelection

// .kiapi.common.types.ItemHeader header = 1;
inline bool GetSelection::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool GetSelection::has_header() const {
  return _internal_has_header();
}
inline const ::kiapi::common::types::ItemHeader& GetSelection::_internal_header() const {
  const ::kiapi::common::types::ItemHeader* p = header_;
  return p != nullptr ? *p : reinterpret_cast<const ::kiapi::common::types::ItemHeader&>(
      ::kiapi::common::types::_ItemHeader_default_instance_);
}
inline const ::kiapi::common::types::ItemHeader& GetSelection::header() const {
  // @@protoc_insertion_point(field_get:kiapi.common.commands.GetSelection.header)
  return _internal_header();
}
inline void GetSelection::unsafe_arena_set_allocated_header(
    ::kiapi::common::types::ItemHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kiapi.common.commands.GetSelection.header)
}
inline ::kiapi::common::types::ItemHeader* GetSelection::release_header() {
  
  ::kiapi::common::types::ItemHeader* temp = header_;
  header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kiapi::common::types::ItemHeader* GetSelection::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:kiapi.common.commands.GetSelection.header)
  
  ::kiapi::common::types::ItemHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::kiapi::common::types::ItemHeader* GetSelection::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::kiapi::common::types::ItemHeader>(GetArenaForAllocation());
    header_ = p;
  }
  return header_;
}
inline ::kiapi::common::types::ItemHeader* GetSelection::mutable_header() {
  ::kiapi::common::types::ItemHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:kiapi.common.commands.GetSelection.header)
  return _msg;
}
inline void GetSelection::set_allocated_header(::kiapi::common::types::ItemHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.commands.GetSelection.header)
}

// repeated .kiapi.common.types.KiCadObjectType types = 2;
inline int GetSelection::_internal_types_size() const {
  return types_.size();
}
inline int GetSelection::types_size() const {
  return _internal_types_size();
}
inline void GetSelection::clear_types() {
  types_.Clear();
}
inline ::kiapi::common::types::KiCadObjectType GetSelection::_internal_types(int index) const {
  return static_cast< ::kiapi::common::types::KiCadObjectType >(types_.Get(index));
}
inline ::kiapi::common::types::KiCadObjectType GetSelection::types(int index) const {
  // @@protoc_insertion_point(field_get:kiapi.common.commands.GetSelection.types)
  return _internal_types(index);
}
inline void GetSelection::set_types(int index, ::kiapi::common::types::KiCadObjectType value) {
  types_.Set(index, value);
  // @@protoc_insertion_point(field_set:kiapi.common.commands.GetSelection.types)
}
inline void GetSelection::_internal_add_types(::kiapi::common::types::KiCadObjectType value) {
  types_.Add(value);
}
inline void GetSelection::add_types(::kiapi::common::types::KiCadObjectType value) {
  _internal_add_types(value);
  // @@protoc_insertion_point(field_add:kiapi.common.commands.GetSelection.types)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
GetSelection::types() const {
  // @@protoc_insertion_point(field_list:kiapi.common.commands.GetSelection.types)
  return types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
GetSelection::_internal_mutable_types() {
  return &types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
GetSelection::mutable_types() {
  // @@protoc_insertion_point(field_mutable_list:kiapi.common.commands.GetSelection.types)
  return _internal_mutable_types();
}

// -------------------------------------------------------------------

// SelectionResponse

// repeated .google.protobuf.Any items = 1;
inline int SelectionResponse::_internal_items_size() const {
  return items_.size();
}
inline int SelectionResponse::items_size() const {
  return _internal_items_size();
}
inline ::PROTOBUF_NAMESPACE_ID::Any* SelectionResponse::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:kiapi.common.commands.SelectionResponse.items)
  return items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Any >*
SelectionResponse::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:kiapi.common.commands.SelectionResponse.items)
  return &items_;
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& SelectionResponse::_internal_items(int index) const {
  return items_.Get(index);
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& SelectionResponse::items(int index) const {
  // @@protoc_insertion_point(field_get:kiapi.common.commands.SelectionResponse.items)
  return _internal_items(index);
}
inline ::PROTOBUF_NAMESPACE_ID::Any* SelectionResponse::_internal_add_items() {
  return items_.Add();
}
inline ::PROTOBUF_NAMESPACE_ID::Any* SelectionResponse::add_items() {
  ::PROTOBUF_NAMESPACE_ID::Any* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:kiapi.common.commands.SelectionResponse.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Any >&
SelectionResponse::items() const {
  // @@protoc_insertion_point(field_list:kiapi.common.commands.SelectionResponse.items)
  return items_;
}

// -------------------------------------------------------------------

// AddToSelection

// .kiapi.common.types.ItemHeader header = 1;
inline bool AddToSelection::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool AddToSelection::has_header() const {
  return _internal_has_header();
}
inline const ::kiapi::common::types::ItemHeader& AddToSelection::_internal_header() const {
  const ::kiapi::common::types::ItemHeader* p = header_;
  return p != nullptr ? *p : reinterpret_cast<const ::kiapi::common::types::ItemHeader&>(
      ::kiapi::common::types::_ItemHeader_default_instance_);
}
inline const ::kiapi::common::types::ItemHeader& AddToSelection::header() const {
  // @@protoc_insertion_point(field_get:kiapi.common.commands.AddToSelection.header)
  return _internal_header();
}
inline void AddToSelection::unsafe_arena_set_allocated_header(
    ::kiapi::common::types::ItemHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kiapi.common.commands.AddToSelection.header)
}
inline ::kiapi::common::types::ItemHeader* AddToSelection::release_header() {
  
  ::kiapi::common::types::ItemHeader* temp = header_;
  header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kiapi::common::types::ItemHeader* AddToSelection::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:kiapi.common.commands.AddToSelection.header)
  
  ::kiapi::common::types::ItemHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::kiapi::common::types::ItemHeader* AddToSelection::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::kiapi::common::types::ItemHeader>(GetArenaForAllocation());
    header_ = p;
  }
  return header_;
}
inline ::kiapi::common::types::ItemHeader* AddToSelection::mutable_header() {
  ::kiapi::common::types::ItemHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:kiapi.common.commands.AddToSelection.header)
  return _msg;
}
inline void AddToSelection::set_allocated_header(::kiapi::common::types::ItemHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.commands.AddToSelection.header)
}

// repeated .kiapi.common.types.KIID items = 2;
inline int AddToSelection::_internal_items_size() const {
  return items_.size();
}
inline int AddToSelection::items_size() const {
  return _internal_items_size();
}
inline ::kiapi::common::types::KIID* AddToSelection::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:kiapi.common.commands.AddToSelection.items)
  return items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::types::KIID >*
AddToSelection::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:kiapi.common.commands.AddToSelection.items)
  return &items_;
}
inline const ::kiapi::common::types::KIID& AddToSelection::_internal_items(int index) const {
  return items_.Get(index);
}
inline const ::kiapi::common::types::KIID& AddToSelection::items(int index) const {
  // @@protoc_insertion_point(field_get:kiapi.common.commands.AddToSelection.items)
  return _internal_items(index);
}
inline ::kiapi::common::types::KIID* AddToSelection::_internal_add_items() {
  return items_.Add();
}
inline ::kiapi::common::types::KIID* AddToSelection::add_items() {
  ::kiapi::common::types::KIID* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:kiapi.common.commands.AddToSelection.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::types::KIID >&
AddToSelection::items() const {
  // @@protoc_insertion_point(field_list:kiapi.common.commands.AddToSelection.items)
  return items_;
}

// -------------------------------------------------------------------

// RemoveFromSelection

// .kiapi.common.types.ItemHeader header = 1;
inline bool RemoveFromSelection::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool RemoveFromSelection::has_header() const {
  return _internal_has_header();
}
inline const ::kiapi::common::types::ItemHeader& RemoveFromSelection::_internal_header() const {
  const ::kiapi::common::types::ItemHeader* p = header_;
  return p != nullptr ? *p : reinterpret_cast<const ::kiapi::common::types::ItemHeader&>(
      ::kiapi::common::types::_ItemHeader_default_instance_);
}
inline const ::kiapi::common::types::ItemHeader& RemoveFromSelection::header() const {
  // @@protoc_insertion_point(field_get:kiapi.common.commands.RemoveFromSelection.header)
  return _internal_header();
}
inline void RemoveFromSelection::unsafe_arena_set_allocated_header(
    ::kiapi::common::types::ItemHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kiapi.common.commands.RemoveFromSelection.header)
}
inline ::kiapi::common::types::ItemHeader* RemoveFromSelection::release_header() {
  
  ::kiapi::common::types::ItemHeader* temp = header_;
  header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kiapi::common::types::ItemHeader* RemoveFromSelection::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:kiapi.common.commands.RemoveFromSelection.header)
  
  ::kiapi::common::types::ItemHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::kiapi::common::types::ItemHeader* RemoveFromSelection::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::kiapi::common::types::ItemHeader>(GetArenaForAllocation());
    header_ = p;
  }
  return header_;
}
inline ::kiapi::common::types::ItemHeader* RemoveFromSelection::mutable_header() {
  ::kiapi::common::types::ItemHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:kiapi.common.commands.RemoveFromSelection.header)
  return _msg;
}
inline void RemoveFromSelection::set_allocated_header(::kiapi::common::types::ItemHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.commands.RemoveFromSelection.header)
}

// repeated .kiapi.common.types.KIID items = 2;
inline int RemoveFromSelection::_internal_items_size() const {
  return items_.size();
}
inline int RemoveFromSelection::items_size() const {
  return _internal_items_size();
}
inline ::kiapi::common::types::KIID* RemoveFromSelection::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:kiapi.common.commands.RemoveFromSelection.items)
  return items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::types::KIID >*
RemoveFromSelection::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:kiapi.common.commands.RemoveFromSelection.items)
  return &items_;
}
inline const ::kiapi::common::types::KIID& RemoveFromSelection::_internal_items(int index) const {
  return items_.Get(index);
}
inline const ::kiapi::common::types::KIID& RemoveFromSelection::items(int index) const {
  // @@protoc_insertion_point(field_get:kiapi.common.commands.RemoveFromSelection.items)
  return _internal_items(index);
}
inline ::kiapi::common::types::KIID* RemoveFromSelection::_internal_add_items() {
  return items_.Add();
}
inline ::kiapi::common::types::KIID* RemoveFromSelection::add_items() {
  ::kiapi::common::types::KIID* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:kiapi.common.commands.RemoveFromSelection.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::types::KIID >&
RemoveFromSelection::items() const {
  // @@protoc_insertion_point(field_list:kiapi.common.commands.RemoveFromSelection.items)
  return items_;
}

// -------------------------------------------------------------------

// ClearSelection

// .kiapi.common.types.ItemHeader header = 1;
inline bool ClearSelection::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool ClearSelection::has_header() const {
  return _internal_has_header();
}
inline const ::kiapi::common::types::ItemHeader& ClearSelection::_internal_header() const {
  const ::kiapi::common::types::ItemHeader* p = header_;
  return p != nullptr ? *p : reinterpret_cast<const ::kiapi::common::types::ItemHeader&>(
      ::kiapi::common::types::_ItemHeader_default_instance_);
}
inline const ::kiapi::common::types::ItemHeader& ClearSelection::header() const {
  // @@protoc_insertion_point(field_get:kiapi.common.commands.ClearSelection.header)
  return _internal_header();
}
inline void ClearSelection::unsafe_arena_set_allocated_header(
    ::kiapi::common::types::ItemHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kiapi.common.commands.ClearSelection.header)
}
inline ::kiapi::common::types::ItemHeader* ClearSelection::release_header() {
  
  ::kiapi::common::types::ItemHeader* temp = header_;
  header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kiapi::common::types::ItemHeader* ClearSelection::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:kiapi.common.commands.ClearSelection.header)
  
  ::kiapi::common::types::ItemHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::kiapi::common::types::ItemHeader* ClearSelection::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::kiapi::common::types::ItemHeader>(GetArenaForAllocation());
    header_ = p;
  }
  return header_;
}
inline ::kiapi::common::types::ItemHeader* ClearSelection::mutable_header() {
  ::kiapi::common::types::ItemHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:kiapi.common.commands.ClearSelection.header)
  return _msg;
}
inline void ClearSelection::set_allocated_header(::kiapi::common::types::ItemHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.commands.ClearSelection.header)
}

// -------------------------------------------------------------------

// HitTest

// .kiapi.common.types.ItemHeader header = 1;
inline bool HitTest::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool HitTest::has_header() const {
  return _internal_has_header();
}
inline const ::kiapi::common::types::ItemHeader& HitTest::_internal_header() const {
  const ::kiapi::common::types::ItemHeader* p = header_;
  return p != nullptr ? *p : reinterpret_cast<const ::kiapi::common::types::ItemHeader&>(
      ::kiapi::common::types::_ItemHeader_default_instance_);
}
inline const ::kiapi::common::types::ItemHeader& HitTest::header() const {
  // @@protoc_insertion_point(field_get:kiapi.common.commands.HitTest.header)
  return _internal_header();
}
inline void HitTest::unsafe_arena_set_allocated_header(
    ::kiapi::common::types::ItemHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kiapi.common.commands.HitTest.header)
}
inline ::kiapi::common::types::ItemHeader* HitTest::release_header() {
  
  ::kiapi::common::types::ItemHeader* temp = header_;
  header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kiapi::common::types::ItemHeader* HitTest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:kiapi.common.commands.HitTest.header)
  
  ::kiapi::common::types::ItemHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::kiapi::common::types::ItemHeader* HitTest::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::kiapi::common::types::ItemHeader>(GetArenaForAllocation());
    header_ = p;
  }
  return header_;
}
inline ::kiapi::common::types::ItemHeader* HitTest::mutable_header() {
  ::kiapi::common::types::ItemHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:kiapi.common.commands.HitTest.header)
  return _msg;
}
inline void HitTest::set_allocated_header(::kiapi::common::types::ItemHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.commands.HitTest.header)
}

// .kiapi.common.types.KIID id = 2;
inline bool HitTest::_internal_has_id() const {
  return this != internal_default_instance() && id_ != nullptr;
}
inline bool HitTest::has_id() const {
  return _internal_has_id();
}
inline const ::kiapi::common::types::KIID& HitTest::_internal_id() const {
  const ::kiapi::common::types::KIID* p = id_;
  return p != nullptr ? *p : reinterpret_cast<const ::kiapi::common::types::KIID&>(
      ::kiapi::common::types::_KIID_default_instance_);
}
inline const ::kiapi::common::types::KIID& HitTest::id() const {
  // @@protoc_insertion_point(field_get:kiapi.common.commands.HitTest.id)
  return _internal_id();
}
inline void HitTest::unsafe_arena_set_allocated_id(
    ::kiapi::common::types::KIID* id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  id_ = id;
  if (id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kiapi.common.commands.HitTest.id)
}
inline ::kiapi::common::types::KIID* HitTest::release_id() {
  
  ::kiapi::common::types::KIID* temp = id_;
  id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kiapi::common::types::KIID* HitTest::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_release:kiapi.common.commands.HitTest.id)
  
  ::kiapi::common::types::KIID* temp = id_;
  id_ = nullptr;
  return temp;
}
inline ::kiapi::common::types::KIID* HitTest::_internal_mutable_id() {
  
  if (id_ == nullptr) {
    auto* p = CreateMaybeMessage<::kiapi::common::types::KIID>(GetArenaForAllocation());
    id_ = p;
  }
  return id_;
}
inline ::kiapi::common::types::KIID* HitTest::mutable_id() {
  ::kiapi::common::types::KIID* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:kiapi.common.commands.HitTest.id)
  return _msg;
}
inline void HitTest::set_allocated_id(::kiapi::common::types::KIID* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id));
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.commands.HitTest.id)
}

// .kiapi.common.types.Vector2 position = 3;
inline bool HitTest::_internal_has_position() const {
  return this != internal_default_instance() && position_ != nullptr;
}
inline bool HitTest::has_position() const {
  return _internal_has_position();
}
inline const ::kiapi::common::types::Vector2& HitTest::_internal_position() const {
  const ::kiapi::common::types::Vector2* p = position_;
  return p != nullptr ? *p : reinterpret_cast<const ::kiapi::common::types::Vector2&>(
      ::kiapi::common::types::_Vector2_default_instance_);
}
inline const ::kiapi::common::types::Vector2& HitTest::position() const {
  // @@protoc_insertion_point(field_get:kiapi.common.commands.HitTest.position)
  return _internal_position();
}
inline void HitTest::unsafe_arena_set_allocated_position(
    ::kiapi::common::types::Vector2* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(position_);
  }
  position_ = position;
  if (position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kiapi.common.commands.HitTest.position)
}
inline ::kiapi::common::types::Vector2* HitTest::release_position() {
  
  ::kiapi::common::types::Vector2* temp = position_;
  position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kiapi::common::types::Vector2* HitTest::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:kiapi.common.commands.HitTest.position)
  
  ::kiapi::common::types::Vector2* temp = position_;
  position_ = nullptr;
  return temp;
}
inline ::kiapi::common::types::Vector2* HitTest::_internal_mutable_position() {
  
  if (position_ == nullptr) {
    auto* p = CreateMaybeMessage<::kiapi::common::types::Vector2>(GetArenaForAllocation());
    position_ = p;
  }
  return position_;
}
inline ::kiapi::common::types::Vector2* HitTest::mutable_position() {
  ::kiapi::common::types::Vector2* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:kiapi.common.commands.HitTest.position)
  return _msg;
}
inline void HitTest::set_allocated_position(::kiapi::common::types::Vector2* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(position_);
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(position));
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.commands.HitTest.position)
}

// int32 tolerance = 4;
inline void HitTest::clear_tolerance() {
  tolerance_ = 0;
}
inline int32_t HitTest::_internal_tolerance() const {
  return tolerance_;
}
inline int32_t HitTest::tolerance() const {
  // @@protoc_insertion_point(field_get:kiapi.common.commands.HitTest.tolerance)
  return _internal_tolerance();
}
inline void HitTest::_internal_set_tolerance(int32_t value) {
  
  tolerance_ = value;
}
inline void HitTest::set_tolerance(int32_t value) {
  _internal_set_tolerance(value);
  // @@protoc_insertion_point(field_set:kiapi.common.commands.HitTest.tolerance)
}

// -------------------------------------------------------------------

// HitTestResponse

// .kiapi.common.commands.HitTestResult result = 1;
inline void HitTestResponse::clear_result() {
  result_ = 0;
}
inline ::kiapi::common::commands::HitTestResult HitTestResponse::_internal_result() const {
  return static_cast< ::kiapi::common::commands::HitTestResult >(result_);
}
inline ::kiapi::common::commands::HitTestResult HitTestResponse::result() const {
  // @@protoc_insertion_point(field_get:kiapi.common.commands.HitTestResponse.result)
  return _internal_result();
}
inline void HitTestResponse::_internal_set_result(::kiapi::common::commands::HitTestResult value) {
  
  result_ = value;
}
inline void HitTestResponse::set_result(::kiapi::common::commands::HitTestResult value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:kiapi.common.commands.HitTestResponse.result)
}

// -------------------------------------------------------------------

// GetTitleBlockInfo

// .kiapi.common.types.DocumentSpecifier document = 1;
inline bool GetTitleBlockInfo::_internal_has_document() const {
  return this != internal_default_instance() && document_ != nullptr;
}
inline bool GetTitleBlockInfo::has_document() const {
  return _internal_has_document();
}
inline const ::kiapi::common::types::DocumentSpecifier& GetTitleBlockInfo::_internal_document() const {
  const ::kiapi::common::types::DocumentSpecifier* p = document_;
  return p != nullptr ? *p : reinterpret_cast<const ::kiapi::common::types::DocumentSpecifier&>(
      ::kiapi::common::types::_DocumentSpecifier_default_instance_);
}
inline const ::kiapi::common::types::DocumentSpecifier& GetTitleBlockInfo::document() const {
  // @@protoc_insertion_point(field_get:kiapi.common.commands.GetTitleBlockInfo.document)
  return _internal_document();
}
inline void GetTitleBlockInfo::unsafe_arena_set_allocated_document(
    ::kiapi::common::types::DocumentSpecifier* document) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(document_);
  }
  document_ = document;
  if (document) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kiapi.common.commands.GetTitleBlockInfo.document)
}
inline ::kiapi::common::types::DocumentSpecifier* GetTitleBlockInfo::release_document() {
  
  ::kiapi::common::types::DocumentSpecifier* temp = document_;
  document_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kiapi::common::types::DocumentSpecifier* GetTitleBlockInfo::unsafe_arena_release_document() {
  // @@protoc_insertion_point(field_release:kiapi.common.commands.GetTitleBlockInfo.document)
  
  ::kiapi::common::types::DocumentSpecifier* temp = document_;
  document_ = nullptr;
  return temp;
}
inline ::kiapi::common::types::DocumentSpecifier* GetTitleBlockInfo::_internal_mutable_document() {
  
  if (document_ == nullptr) {
    auto* p = CreateMaybeMessage<::kiapi::common::types::DocumentSpecifier>(GetArenaForAllocation());
    document_ = p;
  }
  return document_;
}
inline ::kiapi::common::types::DocumentSpecifier* GetTitleBlockInfo::mutable_document() {
  ::kiapi::common::types::DocumentSpecifier* _msg = _internal_mutable_document();
  // @@protoc_insertion_point(field_mutable:kiapi.common.commands.GetTitleBlockInfo.document)
  return _msg;
}
inline void GetTitleBlockInfo::set_allocated_document(::kiapi::common::types::DocumentSpecifier* document) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(document_);
  }
  if (document) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(document));
    if (message_arena != submessage_arena) {
      document = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, document, submessage_arena);
    }
    
  } else {
    
  }
  document_ = document;
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.commands.GetTitleBlockInfo.document)
}

// -------------------------------------------------------------------

// SaveDocumentToString

// .kiapi.common.types.DocumentSpecifier document = 1;
inline bool SaveDocumentToString::_internal_has_document() const {
  return this != internal_default_instance() && document_ != nullptr;
}
inline bool SaveDocumentToString::has_document() const {
  return _internal_has_document();
}
inline const ::kiapi::common::types::DocumentSpecifier& SaveDocumentToString::_internal_document() const {
  const ::kiapi::common::types::DocumentSpecifier* p = document_;
  return p != nullptr ? *p : reinterpret_cast<const ::kiapi::common::types::DocumentSpecifier&>(
      ::kiapi::common::types::_DocumentSpecifier_default_instance_);
}
inline const ::kiapi::common::types::DocumentSpecifier& SaveDocumentToString::document() const {
  // @@protoc_insertion_point(field_get:kiapi.common.commands.SaveDocumentToString.document)
  return _internal_document();
}
inline void SaveDocumentToString::unsafe_arena_set_allocated_document(
    ::kiapi::common::types::DocumentSpecifier* document) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(document_);
  }
  document_ = document;
  if (document) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kiapi.common.commands.SaveDocumentToString.document)
}
inline ::kiapi::common::types::DocumentSpecifier* SaveDocumentToString::release_document() {
  
  ::kiapi::common::types::DocumentSpecifier* temp = document_;
  document_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kiapi::common::types::DocumentSpecifier* SaveDocumentToString::unsafe_arena_release_document() {
  // @@protoc_insertion_point(field_release:kiapi.common.commands.SaveDocumentToString.document)
  
  ::kiapi::common::types::DocumentSpecifier* temp = document_;
  document_ = nullptr;
  return temp;
}
inline ::kiapi::common::types::DocumentSpecifier* SaveDocumentToString::_internal_mutable_document() {
  
  if (document_ == nullptr) {
    auto* p = CreateMaybeMessage<::kiapi::common::types::DocumentSpecifier>(GetArenaForAllocation());
    document_ = p;
  }
  return document_;
}
inline ::kiapi::common::types::DocumentSpecifier* SaveDocumentToString::mutable_document() {
  ::kiapi::common::types::DocumentSpecifier* _msg = _internal_mutable_document();
  // @@protoc_insertion_point(field_mutable:kiapi.common.commands.SaveDocumentToString.document)
  return _msg;
}
inline void SaveDocumentToString::set_allocated_document(::kiapi::common::types::DocumentSpecifier* document) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(document_);
  }
  if (document) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(document));
    if (message_arena != submessage_arena) {
      document = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, document, submessage_arena);
    }
    
  } else {
    
  }
  document_ = document;
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.commands.SaveDocumentToString.document)
}

// -------------------------------------------------------------------

// SavedDocumentResponse

// .kiapi.common.types.DocumentSpecifier document = 1;
inline bool SavedDocumentResponse::_internal_has_document() const {
  return this != internal_default_instance() && document_ != nullptr;
}
inline bool SavedDocumentResponse::has_document() const {
  return _internal_has_document();
}
inline const ::kiapi::common::types::DocumentSpecifier& SavedDocumentResponse::_internal_document() const {
  const ::kiapi::common::types::DocumentSpecifier* p = document_;
  return p != nullptr ? *p : reinterpret_cast<const ::kiapi::common::types::DocumentSpecifier&>(
      ::kiapi::common::types::_DocumentSpecifier_default_instance_);
}
inline const ::kiapi::common::types::DocumentSpecifier& SavedDocumentResponse::document() const {
  // @@protoc_insertion_point(field_get:kiapi.common.commands.SavedDocumentResponse.document)
  return _internal_document();
}
inline void SavedDocumentResponse::unsafe_arena_set_allocated_document(
    ::kiapi::common::types::DocumentSpecifier* document) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(document_);
  }
  document_ = document;
  if (document) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kiapi.common.commands.SavedDocumentResponse.document)
}
inline ::kiapi::common::types::DocumentSpecifier* SavedDocumentResponse::release_document() {
  
  ::kiapi::common::types::DocumentSpecifier* temp = document_;
  document_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kiapi::common::types::DocumentSpecifier* SavedDocumentResponse::unsafe_arena_release_document() {
  // @@protoc_insertion_point(field_release:kiapi.common.commands.SavedDocumentResponse.document)
  
  ::kiapi::common::types::DocumentSpecifier* temp = document_;
  document_ = nullptr;
  return temp;
}
inline ::kiapi::common::types::DocumentSpecifier* SavedDocumentResponse::_internal_mutable_document() {
  
  if (document_ == nullptr) {
    auto* p = CreateMaybeMessage<::kiapi::common::types::DocumentSpecifier>(GetArenaForAllocation());
    document_ = p;
  }
  return document_;
}
inline ::kiapi::common::types::DocumentSpecifier* SavedDocumentResponse::mutable_document() {
  ::kiapi::common::types::DocumentSpecifier* _msg = _internal_mutable_document();
  // @@protoc_insertion_point(field_mutable:kiapi.common.commands.SavedDocumentResponse.document)
  return _msg;
}
inline void SavedDocumentResponse::set_allocated_document(::kiapi::common::types::DocumentSpecifier* document) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(document_);
  }
  if (document) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(document));
    if (message_arena != submessage_arena) {
      document = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, document, submessage_arena);
    }
    
  } else {
    
  }
  document_ = document;
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.commands.SavedDocumentResponse.document)
}

// string contents = 2;
inline void SavedDocumentResponse::clear_contents() {
  contents_.ClearToEmpty();
}
inline const std::string& SavedDocumentResponse::contents() const {
  // @@protoc_insertion_point(field_get:kiapi.common.commands.SavedDocumentResponse.contents)
  return _internal_contents();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SavedDocumentResponse::set_contents(ArgT0&& arg0, ArgT... args) {
 
 contents_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kiapi.common.commands.SavedDocumentResponse.contents)
}
inline std::string* SavedDocumentResponse::mutable_contents() {
  std::string* _s = _internal_mutable_contents();
  // @@protoc_insertion_point(field_mutable:kiapi.common.commands.SavedDocumentResponse.contents)
  return _s;
}
inline const std::string& SavedDocumentResponse::_internal_contents() const {
  return contents_.Get();
}
inline void SavedDocumentResponse::_internal_set_contents(const std::string& value) {
  
  contents_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SavedDocumentResponse::_internal_mutable_contents() {
  
  return contents_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SavedDocumentResponse::release_contents() {
  // @@protoc_insertion_point(field_release:kiapi.common.commands.SavedDocumentResponse.contents)
  return contents_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SavedDocumentResponse::set_allocated_contents(std::string* contents) {
  if (contents != nullptr) {
    
  } else {
    
  }
  contents_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), contents,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (contents_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    contents_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.commands.SavedDocumentResponse.contents)
}

// -------------------------------------------------------------------

// SaveSelectionToString

// -------------------------------------------------------------------

// SavedSelectionResponse

// repeated .kiapi.common.types.KIID ids = 1;
inline int SavedSelectionResponse::_internal_ids_size() const {
  return ids_.size();
}
inline int SavedSelectionResponse::ids_size() const {
  return _internal_ids_size();
}
inline ::kiapi::common::types::KIID* SavedSelectionResponse::mutable_ids(int index) {
  // @@protoc_insertion_point(field_mutable:kiapi.common.commands.SavedSelectionResponse.ids)
  return ids_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::types::KIID >*
SavedSelectionResponse::mutable_ids() {
  // @@protoc_insertion_point(field_mutable_list:kiapi.common.commands.SavedSelectionResponse.ids)
  return &ids_;
}
inline const ::kiapi::common::types::KIID& SavedSelectionResponse::_internal_ids(int index) const {
  return ids_.Get(index);
}
inline const ::kiapi::common::types::KIID& SavedSelectionResponse::ids(int index) const {
  // @@protoc_insertion_point(field_get:kiapi.common.commands.SavedSelectionResponse.ids)
  return _internal_ids(index);
}
inline ::kiapi::common::types::KIID* SavedSelectionResponse::_internal_add_ids() {
  return ids_.Add();
}
inline ::kiapi::common::types::KIID* SavedSelectionResponse::add_ids() {
  ::kiapi::common::types::KIID* _add = _internal_add_ids();
  // @@protoc_insertion_point(field_add:kiapi.common.commands.SavedSelectionResponse.ids)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::types::KIID >&
SavedSelectionResponse::ids() const {
  // @@protoc_insertion_point(field_list:kiapi.common.commands.SavedSelectionResponse.ids)
  return ids_;
}

// string contents = 2;
inline void SavedSelectionResponse::clear_contents() {
  contents_.ClearToEmpty();
}
inline const std::string& SavedSelectionResponse::contents() const {
  // @@protoc_insertion_point(field_get:kiapi.common.commands.SavedSelectionResponse.contents)
  return _internal_contents();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SavedSelectionResponse::set_contents(ArgT0&& arg0, ArgT... args) {
 
 contents_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kiapi.common.commands.SavedSelectionResponse.contents)
}
inline std::string* SavedSelectionResponse::mutable_contents() {
  std::string* _s = _internal_mutable_contents();
  // @@protoc_insertion_point(field_mutable:kiapi.common.commands.SavedSelectionResponse.contents)
  return _s;
}
inline const std::string& SavedSelectionResponse::_internal_contents() const {
  return contents_.Get();
}
inline void SavedSelectionResponse::_internal_set_contents(const std::string& value) {
  
  contents_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SavedSelectionResponse::_internal_mutable_contents() {
  
  return contents_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SavedSelectionResponse::release_contents() {
  // @@protoc_insertion_point(field_release:kiapi.common.commands.SavedSelectionResponse.contents)
  return contents_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SavedSelectionResponse::set_allocated_contents(std::string* contents) {
  if (contents != nullptr) {
    
  } else {
    
  }
  contents_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), contents,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (contents_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    contents_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.commands.SavedSelectionResponse.contents)
}

// -------------------------------------------------------------------

// ParseAndCreateItemsFromString

// .kiapi.common.types.DocumentSpecifier document = 1;
inline bool ParseAndCreateItemsFromString::_internal_has_document() const {
  return this != internal_default_instance() && document_ != nullptr;
}
inline bool ParseAndCreateItemsFromString::has_document() const {
  return _internal_has_document();
}
inline const ::kiapi::common::types::DocumentSpecifier& ParseAndCreateItemsFromString::_internal_document() const {
  const ::kiapi::common::types::DocumentSpecifier* p = document_;
  return p != nullptr ? *p : reinterpret_cast<const ::kiapi::common::types::DocumentSpecifier&>(
      ::kiapi::common::types::_DocumentSpecifier_default_instance_);
}
inline const ::kiapi::common::types::DocumentSpecifier& ParseAndCreateItemsFromString::document() const {
  // @@protoc_insertion_point(field_get:kiapi.common.commands.ParseAndCreateItemsFromString.document)
  return _internal_document();
}
inline void ParseAndCreateItemsFromString::unsafe_arena_set_allocated_document(
    ::kiapi::common::types::DocumentSpecifier* document) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(document_);
  }
  document_ = document;
  if (document) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kiapi.common.commands.ParseAndCreateItemsFromString.document)
}
inline ::kiapi::common::types::DocumentSpecifier* ParseAndCreateItemsFromString::release_document() {
  
  ::kiapi::common::types::DocumentSpecifier* temp = document_;
  document_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kiapi::common::types::DocumentSpecifier* ParseAndCreateItemsFromString::unsafe_arena_release_document() {
  // @@protoc_insertion_point(field_release:kiapi.common.commands.ParseAndCreateItemsFromString.document)
  
  ::kiapi::common::types::DocumentSpecifier* temp = document_;
  document_ = nullptr;
  return temp;
}
inline ::kiapi::common::types::DocumentSpecifier* ParseAndCreateItemsFromString::_internal_mutable_document() {
  
  if (document_ == nullptr) {
    auto* p = CreateMaybeMessage<::kiapi::common::types::DocumentSpecifier>(GetArenaForAllocation());
    document_ = p;
  }
  return document_;
}
inline ::kiapi::common::types::DocumentSpecifier* ParseAndCreateItemsFromString::mutable_document() {
  ::kiapi::common::types::DocumentSpecifier* _msg = _internal_mutable_document();
  // @@protoc_insertion_point(field_mutable:kiapi.common.commands.ParseAndCreateItemsFromString.document)
  return _msg;
}
inline void ParseAndCreateItemsFromString::set_allocated_document(::kiapi::common::types::DocumentSpecifier* document) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(document_);
  }
  if (document) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(document));
    if (message_arena != submessage_arena) {
      document = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, document, submessage_arena);
    }
    
  } else {
    
  }
  document_ = document;
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.commands.ParseAndCreateItemsFromString.document)
}

// string contents = 2;
inline void ParseAndCreateItemsFromString::clear_contents() {
  contents_.ClearToEmpty();
}
inline const std::string& ParseAndCreateItemsFromString::contents() const {
  // @@protoc_insertion_point(field_get:kiapi.common.commands.ParseAndCreateItemsFromString.contents)
  return _internal_contents();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ParseAndCreateItemsFromString::set_contents(ArgT0&& arg0, ArgT... args) {
 
 contents_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kiapi.common.commands.ParseAndCreateItemsFromString.contents)
}
inline std::string* ParseAndCreateItemsFromString::mutable_contents() {
  std::string* _s = _internal_mutable_contents();
  // @@protoc_insertion_point(field_mutable:kiapi.common.commands.ParseAndCreateItemsFromString.contents)
  return _s;
}
inline const std::string& ParseAndCreateItemsFromString::_internal_contents() const {
  return contents_.Get();
}
inline void ParseAndCreateItemsFromString::_internal_set_contents(const std::string& value) {
  
  contents_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ParseAndCreateItemsFromString::_internal_mutable_contents() {
  
  return contents_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ParseAndCreateItemsFromString::release_contents() {
  // @@protoc_insertion_point(field_release:kiapi.common.commands.ParseAndCreateItemsFromString.contents)
  return contents_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ParseAndCreateItemsFromString::set_allocated_contents(std::string* contents) {
  if (contents != nullptr) {
    
  } else {
    
  }
  contents_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), contents,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (contents_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    contents_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.commands.ParseAndCreateItemsFromString.contents)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace commands
}  // namespace common
}  // namespace kiapi

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::kiapi::common::commands::RunActionStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::kiapi::common::commands::RunActionStatus>() {
  return ::kiapi::common::commands::RunActionStatus_descriptor();
}
template <> struct is_proto_enum< ::kiapi::common::commands::CommitAction> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::kiapi::common::commands::CommitAction>() {
  return ::kiapi::common::commands::CommitAction_descriptor();
}
template <> struct is_proto_enum< ::kiapi::common::commands::ItemStatusCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::kiapi::common::commands::ItemStatusCode>() {
  return ::kiapi::common::commands::ItemStatusCode_descriptor();
}
template <> struct is_proto_enum< ::kiapi::common::commands::ItemDeletionStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::kiapi::common::commands::ItemDeletionStatus>() {
  return ::kiapi::common::commands::ItemDeletionStatus_descriptor();
}
template <> struct is_proto_enum< ::kiapi::common::commands::BoundingBoxMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::kiapi::common::commands::BoundingBoxMode>() {
  return ::kiapi::common::commands::BoundingBoxMode_descriptor();
}
template <> struct is_proto_enum< ::kiapi::common::commands::HitTestResult> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::kiapi::common::commands::HitTestResult>() {
  return ::kiapi::common::commands::HitTestResult_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_common_2fcommands_2feditor_5fcommands_2eproto

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: common/types/enums.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_common_2ftypes_2fenums_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_common_2ftypes_2fenums_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_common_2ftypes_2fenums_2eproto KIAPI_IMPORTEXPORT
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct KIAPI_IMPORTEXPORT TableStruct_common_2ftypes_2fenums_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[1]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
KIAPI_IMPORTEXPORT extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_common_2ftypes_2fenums_2eproto;
PROTOBUF_NAMESPACE_OPEN
PROTOBUF_NAMESPACE_CLOSE
namespace kiapi {
namespace common {
namespace types {

enum KiCadObjectType : int {
  KOT_UNKNOWN = 0,
  KOT_PCB_FOOTPRINT = 1,
  KOT_PCB_PAD = 2,
  KOT_PCB_SHAPE = 3,
  KOT_PCB_REFERENCE_IMAGE = 4,
  KOT_PCB_FIELD = 5,
  KOT_PCB_GENERATOR = 6,
  KOT_PCB_TEXT = 7,
  KOT_PCB_TEXTBOX = 8,
  KOT_PCB_TABLE = 9,
  KOT_PCB_TABLECELL = 10,
  KOT_PCB_TRACE = 11,
  KOT_PCB_VIA = 12,
  KOT_PCB_ARC = 13,
  KOT_PCB_MARKER = 14,
  KOT_PCB_DIMENSION = 15,
  KOT_PCB_ZONE = 16,
  KOT_PCB_GROUP = 17,
  KOT_SCH_MARKER = 18,
  KOT_SCH_JUNCTION = 19,
  KOT_SCH_NO_CONNECT = 20,
  KOT_SCH_BUS_WIRE_ENTRY = 21,
  KOT_SCH_BUS_BUS_ENTRY = 22,
  KOT_SCH_LINE = 23,
  KOT_SCH_SHAPE = 24,
  KOT_SCH_BITMAP = 25,
  KOT_SCH_TEXTBOX = 26,
  KOT_SCH_TEXT = 27,
  KOT_SCH_TABLE = 28,
  KOT_SCH_TABLECELL = 29,
  KOT_SCH_LABEL = 30,
  KOT_SCH_GLOBAL_LABEL = 31,
  KOT_SCH_HIER_LABEL = 32,
  KOT_SCH_DIRECTIVE_LABEL = 33,
  KOT_SCH_FIELD = 34,
  KOT_SCH_SYMBOL = 35,
  KOT_SCH_SHEET_PIN = 36,
  KOT_SCH_SHEET = 37,
  KOT_SCH_PIN = 38,
  KOT_LIB_SYMBOL = 39,
  KOT_WSG_LINE = 45,
  KOT_WSG_RECT = 46,
  KOT_WSG_POLY = 47,
  KOT_WSG_TEXT = 48,
  KOT_WSG_BITMAP = 49,
  KOT_WSG_PAGE = 50,
  KiCadObjectType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  KiCadObjectType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
KIAPI_IMPORTEXPORT bool KiCadObjectType_IsValid(int value);
constexpr KiCadObjectType KiCadObjectType_MIN = KOT_UNKNOWN;
constexpr KiCadObjectType KiCadObjectType_MAX = KOT_WSG_PAGE;
constexpr int KiCadObjectType_ARRAYSIZE = KiCadObjectType_MAX + 1;

KIAPI_IMPORTEXPORT const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* KiCadObjectType_descriptor();
template<typename T>
inline const std::string& KiCadObjectType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, KiCadObjectType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function KiCadObjectType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    KiCadObjectType_descriptor(), enum_t_value);
}
inline bool KiCadObjectType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, KiCadObjectType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<KiCadObjectType>(
    KiCadObjectType_descriptor(), name, value);
}
enum HorizontalAlignment : int {
  HA_UNKNOWN = 0,
  HA_LEFT = 1,
  HA_CENTER = 2,
  HA_RIGHT = 3,
  HA_INDETERMINATE = 4,
  HorizontalAlignment_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  HorizontalAlignment_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
KIAPI_IMPORTEXPORT bool HorizontalAlignment_IsValid(int value);
constexpr HorizontalAlignment HorizontalAlignment_MIN = HA_UNKNOWN;
constexpr HorizontalAlignment HorizontalAlignment_MAX = HA_INDETERMINATE;
constexpr int HorizontalAlignment_ARRAYSIZE = HorizontalAlignment_MAX + 1;

KIAPI_IMPORTEXPORT const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* HorizontalAlignment_descriptor();
template<typename T>
inline const std::string& HorizontalAlignment_Name(T enum_t_value) {
  static_assert(::std::is_same<T, HorizontalAlignment>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function HorizontalAlignment_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    HorizontalAlignment_descriptor(), enum_t_value);
}
inline bool HorizontalAlignment_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, HorizontalAlignment* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<HorizontalAlignment>(
    HorizontalAlignment_descriptor(), name, value);
}
enum VerticalAlignment : int {
  VA_UNKNOWN = 0,
  VA_TOP = 1,
  VA_CENTER = 2,
  VA_BOTTOM = 3,
  VA_INDETERMINATE = 4,
  VerticalAlignment_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  VerticalAlignment_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
KIAPI_IMPORTEXPORT bool VerticalAlignment_IsValid(int value);
constexpr VerticalAlignment VerticalAlignment_MIN = VA_UNKNOWN;
constexpr VerticalAlignment VerticalAlignment_MAX = VA_INDETERMINATE;
constexpr int VerticalAlignment_ARRAYSIZE = VerticalAlignment_MAX + 1;

KIAPI_IMPORTEXPORT const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VerticalAlignment_descriptor();
template<typename T>
inline const std::string& VerticalAlignment_Name(T enum_t_value) {
  static_assert(::std::is_same<T, VerticalAlignment>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function VerticalAlignment_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    VerticalAlignment_descriptor(), enum_t_value);
}
inline bool VerticalAlignment_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, VerticalAlignment* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<VerticalAlignment>(
    VerticalAlignment_descriptor(), name, value);
}
enum StrokeLineStyle : int {
  SLS_UNKNOWN = 0,
  SLS_DEFAULT = 1,
  SLS_SOLID = 2,
  SLS_DASH = 3,
  SLS_DOT = 4,
  SLS_DASHDOT = 5,
  SLS_DASHDOTDOT = 6,
  StrokeLineStyle_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  StrokeLineStyle_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
KIAPI_IMPORTEXPORT bool StrokeLineStyle_IsValid(int value);
constexpr StrokeLineStyle StrokeLineStyle_MIN = SLS_UNKNOWN;
constexpr StrokeLineStyle StrokeLineStyle_MAX = SLS_DASHDOTDOT;
constexpr int StrokeLineStyle_ARRAYSIZE = StrokeLineStyle_MAX + 1;

KIAPI_IMPORTEXPORT const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StrokeLineStyle_descriptor();
template<typename T>
inline const std::string& StrokeLineStyle_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StrokeLineStyle>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StrokeLineStyle_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    StrokeLineStyle_descriptor(), enum_t_value);
}
inline bool StrokeLineStyle_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, StrokeLineStyle* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<StrokeLineStyle>(
    StrokeLineStyle_descriptor(), name, value);
}
// ===================================================================


// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)

}  // namespace types
}  // namespace common
}  // namespace kiapi

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::kiapi::common::types::KiCadObjectType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::kiapi::common::types::KiCadObjectType>() {
  return ::kiapi::common::types::KiCadObjectType_descriptor();
}
template <> struct is_proto_enum< ::kiapi::common::types::HorizontalAlignment> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::kiapi::common::types::HorizontalAlignment>() {
  return ::kiapi::common::types::HorizontalAlignment_descriptor();
}
template <> struct is_proto_enum< ::kiapi::common::types::VerticalAlignment> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::kiapi::common::types::VerticalAlignment>() {
  return ::kiapi::common::types::VerticalAlignment_descriptor();
}
template <> struct is_proto_enum< ::kiapi::common::types::StrokeLineStyle> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::kiapi::common::types::StrokeLineStyle>() {
  return ::kiapi::common::types::StrokeLineStyle_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_common_2ftypes_2fenums_2eproto

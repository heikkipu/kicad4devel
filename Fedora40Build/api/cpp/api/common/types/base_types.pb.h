// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: common/types/base_types.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_common_2ftypes_2fbase_5ftypes_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_common_2ftypes_2fbase_5ftypes_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/field_mask.pb.h>
#include "common/types/enums.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_common_2ftypes_2fbase_5ftypes_2eproto KIAPI_IMPORTEXPORT
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct KIAPI_IMPORTEXPORT TableStruct_common_2ftypes_2fbase_5ftypes_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[35]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
KIAPI_IMPORTEXPORT extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_common_2ftypes_2fbase_5ftypes_2eproto;
namespace kiapi {
namespace common {
namespace types {
class Angle;
struct AngleDefaultTypeInternal;
KIAPI_IMPORTEXPORT extern AngleDefaultTypeInternal _Angle_default_instance_;
class ArcStartMidEnd;
struct ArcStartMidEndDefaultTypeInternal;
KIAPI_IMPORTEXPORT extern ArcStartMidEndDefaultTypeInternal _ArcStartMidEnd_default_instance_;
class Box2;
struct Box2DefaultTypeInternal;
KIAPI_IMPORTEXPORT extern Box2DefaultTypeInternal _Box2_default_instance_;
class Color;
struct ColorDefaultTypeInternal;
KIAPI_IMPORTEXPORT extern ColorDefaultTypeInternal _Color_default_instance_;
class CommandStatusResponse;
struct CommandStatusResponseDefaultTypeInternal;
KIAPI_IMPORTEXPORT extern CommandStatusResponseDefaultTypeInternal _CommandStatusResponse_default_instance_;
class CompoundShape;
struct CompoundShapeDefaultTypeInternal;
KIAPI_IMPORTEXPORT extern CompoundShapeDefaultTypeInternal _CompoundShape_default_instance_;
class Distance;
struct DistanceDefaultTypeInternal;
KIAPI_IMPORTEXPORT extern DistanceDefaultTypeInternal _Distance_default_instance_;
class DocumentSpecifier;
struct DocumentSpecifierDefaultTypeInternal;
KIAPI_IMPORTEXPORT extern DocumentSpecifierDefaultTypeInternal _DocumentSpecifier_default_instance_;
class GraphicArcAttributes;
struct GraphicArcAttributesDefaultTypeInternal;
KIAPI_IMPORTEXPORT extern GraphicArcAttributesDefaultTypeInternal _GraphicArcAttributes_default_instance_;
class GraphicAttributes;
struct GraphicAttributesDefaultTypeInternal;
KIAPI_IMPORTEXPORT extern GraphicAttributesDefaultTypeInternal _GraphicAttributes_default_instance_;
class GraphicBezierAttributes;
struct GraphicBezierAttributesDefaultTypeInternal;
KIAPI_IMPORTEXPORT extern GraphicBezierAttributesDefaultTypeInternal _GraphicBezierAttributes_default_instance_;
class GraphicCircleAttributes;
struct GraphicCircleAttributesDefaultTypeInternal;
KIAPI_IMPORTEXPORT extern GraphicCircleAttributesDefaultTypeInternal _GraphicCircleAttributes_default_instance_;
class GraphicFillAttributes;
struct GraphicFillAttributesDefaultTypeInternal;
KIAPI_IMPORTEXPORT extern GraphicFillAttributesDefaultTypeInternal _GraphicFillAttributes_default_instance_;
class GraphicRectangleAttributes;
struct GraphicRectangleAttributesDefaultTypeInternal;
KIAPI_IMPORTEXPORT extern GraphicRectangleAttributesDefaultTypeInternal _GraphicRectangleAttributes_default_instance_;
class GraphicSegmentAttributes;
struct GraphicSegmentAttributesDefaultTypeInternal;
KIAPI_IMPORTEXPORT extern GraphicSegmentAttributesDefaultTypeInternal _GraphicSegmentAttributes_default_instance_;
class GraphicShape;
struct GraphicShapeDefaultTypeInternal;
KIAPI_IMPORTEXPORT extern GraphicShapeDefaultTypeInternal _GraphicShape_default_instance_;
class ItemHeader;
struct ItemHeaderDefaultTypeInternal;
KIAPI_IMPORTEXPORT extern ItemHeaderDefaultTypeInternal _ItemHeader_default_instance_;
class KIID;
struct KIIDDefaultTypeInternal;
KIAPI_IMPORTEXPORT extern KIIDDefaultTypeInternal _KIID_default_instance_;
class KiCadVersion;
struct KiCadVersionDefaultTypeInternal;
KIAPI_IMPORTEXPORT extern KiCadVersionDefaultTypeInternal _KiCadVersion_default_instance_;
class LibraryIdentifier;
struct LibraryIdentifierDefaultTypeInternal;
KIAPI_IMPORTEXPORT extern LibraryIdentifierDefaultTypeInternal _LibraryIdentifier_default_instance_;
class PolyLine;
struct PolyLineDefaultTypeInternal;
KIAPI_IMPORTEXPORT extern PolyLineDefaultTypeInternal _PolyLine_default_instance_;
class PolyLineNode;
struct PolyLineNodeDefaultTypeInternal;
KIAPI_IMPORTEXPORT extern PolyLineNodeDefaultTypeInternal _PolyLineNode_default_instance_;
class PolySet;
struct PolySetDefaultTypeInternal;
KIAPI_IMPORTEXPORT extern PolySetDefaultTypeInternal _PolySet_default_instance_;
class PolygonWithHoles;
struct PolygonWithHolesDefaultTypeInternal;
KIAPI_IMPORTEXPORT extern PolygonWithHolesDefaultTypeInternal _PolygonWithHoles_default_instance_;
class ProjectSpecifier;
struct ProjectSpecifierDefaultTypeInternal;
KIAPI_IMPORTEXPORT extern ProjectSpecifierDefaultTypeInternal _ProjectSpecifier_default_instance_;
class Ratio;
struct RatioDefaultTypeInternal;
KIAPI_IMPORTEXPORT extern RatioDefaultTypeInternal _Ratio_default_instance_;
class SheetPath;
struct SheetPathDefaultTypeInternal;
KIAPI_IMPORTEXPORT extern SheetPathDefaultTypeInternal _SheetPath_default_instance_;
class StrokeAttributes;
struct StrokeAttributesDefaultTypeInternal;
KIAPI_IMPORTEXPORT extern StrokeAttributesDefaultTypeInternal _StrokeAttributes_default_instance_;
class Text;
struct TextDefaultTypeInternal;
KIAPI_IMPORTEXPORT extern TextDefaultTypeInternal _Text_default_instance_;
class TextAttributes;
struct TextAttributesDefaultTypeInternal;
KIAPI_IMPORTEXPORT extern TextAttributesDefaultTypeInternal _TextAttributes_default_instance_;
class TextBox;
struct TextBoxDefaultTypeInternal;
KIAPI_IMPORTEXPORT extern TextBoxDefaultTypeInternal _TextBox_default_instance_;
class TitleBlockInfo;
struct TitleBlockInfoDefaultTypeInternal;
KIAPI_IMPORTEXPORT extern TitleBlockInfoDefaultTypeInternal _TitleBlockInfo_default_instance_;
class Vector2;
struct Vector2DefaultTypeInternal;
KIAPI_IMPORTEXPORT extern Vector2DefaultTypeInternal _Vector2_default_instance_;
class Vector3;
struct Vector3DefaultTypeInternal;
KIAPI_IMPORTEXPORT extern Vector3DefaultTypeInternal _Vector3_default_instance_;
class Vector3D;
struct Vector3DDefaultTypeInternal;
KIAPI_IMPORTEXPORT extern Vector3DDefaultTypeInternal _Vector3D_default_instance_;
}  // namespace types
}  // namespace common
}  // namespace kiapi
PROTOBUF_NAMESPACE_OPEN
template<> KIAPI_IMPORTEXPORT ::kiapi::common::types::Angle* Arena::CreateMaybeMessage<::kiapi::common::types::Angle>(Arena*);
template<> KIAPI_IMPORTEXPORT ::kiapi::common::types::ArcStartMidEnd* Arena::CreateMaybeMessage<::kiapi::common::types::ArcStartMidEnd>(Arena*);
template<> KIAPI_IMPORTEXPORT ::kiapi::common::types::Box2* Arena::CreateMaybeMessage<::kiapi::common::types::Box2>(Arena*);
template<> KIAPI_IMPORTEXPORT ::kiapi::common::types::Color* Arena::CreateMaybeMessage<::kiapi::common::types::Color>(Arena*);
template<> KIAPI_IMPORTEXPORT ::kiapi::common::types::CommandStatusResponse* Arena::CreateMaybeMessage<::kiapi::common::types::CommandStatusResponse>(Arena*);
template<> KIAPI_IMPORTEXPORT ::kiapi::common::types::CompoundShape* Arena::CreateMaybeMessage<::kiapi::common::types::CompoundShape>(Arena*);
template<> KIAPI_IMPORTEXPORT ::kiapi::common::types::Distance* Arena::CreateMaybeMessage<::kiapi::common::types::Distance>(Arena*);
template<> KIAPI_IMPORTEXPORT ::kiapi::common::types::DocumentSpecifier* Arena::CreateMaybeMessage<::kiapi::common::types::DocumentSpecifier>(Arena*);
template<> KIAPI_IMPORTEXPORT ::kiapi::common::types::GraphicArcAttributes* Arena::CreateMaybeMessage<::kiapi::common::types::GraphicArcAttributes>(Arena*);
template<> KIAPI_IMPORTEXPORT ::kiapi::common::types::GraphicAttributes* Arena::CreateMaybeMessage<::kiapi::common::types::GraphicAttributes>(Arena*);
template<> KIAPI_IMPORTEXPORT ::kiapi::common::types::GraphicBezierAttributes* Arena::CreateMaybeMessage<::kiapi::common::types::GraphicBezierAttributes>(Arena*);
template<> KIAPI_IMPORTEXPORT ::kiapi::common::types::GraphicCircleAttributes* Arena::CreateMaybeMessage<::kiapi::common::types::GraphicCircleAttributes>(Arena*);
template<> KIAPI_IMPORTEXPORT ::kiapi::common::types::GraphicFillAttributes* Arena::CreateMaybeMessage<::kiapi::common::types::GraphicFillAttributes>(Arena*);
template<> KIAPI_IMPORTEXPORT ::kiapi::common::types::GraphicRectangleAttributes* Arena::CreateMaybeMessage<::kiapi::common::types::GraphicRectangleAttributes>(Arena*);
template<> KIAPI_IMPORTEXPORT ::kiapi::common::types::GraphicSegmentAttributes* Arena::CreateMaybeMessage<::kiapi::common::types::GraphicSegmentAttributes>(Arena*);
template<> KIAPI_IMPORTEXPORT ::kiapi::common::types::GraphicShape* Arena::CreateMaybeMessage<::kiapi::common::types::GraphicShape>(Arena*);
template<> KIAPI_IMPORTEXPORT ::kiapi::common::types::ItemHeader* Arena::CreateMaybeMessage<::kiapi::common::types::ItemHeader>(Arena*);
template<> KIAPI_IMPORTEXPORT ::kiapi::common::types::KIID* Arena::CreateMaybeMessage<::kiapi::common::types::KIID>(Arena*);
template<> KIAPI_IMPORTEXPORT ::kiapi::common::types::KiCadVersion* Arena::CreateMaybeMessage<::kiapi::common::types::KiCadVersion>(Arena*);
template<> KIAPI_IMPORTEXPORT ::kiapi::common::types::LibraryIdentifier* Arena::CreateMaybeMessage<::kiapi::common::types::LibraryIdentifier>(Arena*);
template<> KIAPI_IMPORTEXPORT ::kiapi::common::types::PolyLine* Arena::CreateMaybeMessage<::kiapi::common::types::PolyLine>(Arena*);
template<> KIAPI_IMPORTEXPORT ::kiapi::common::types::PolyLineNode* Arena::CreateMaybeMessage<::kiapi::common::types::PolyLineNode>(Arena*);
template<> KIAPI_IMPORTEXPORT ::kiapi::common::types::PolySet* Arena::CreateMaybeMessage<::kiapi::common::types::PolySet>(Arena*);
template<> KIAPI_IMPORTEXPORT ::kiapi::common::types::PolygonWithHoles* Arena::CreateMaybeMessage<::kiapi::common::types::PolygonWithHoles>(Arena*);
template<> KIAPI_IMPORTEXPORT ::kiapi::common::types::ProjectSpecifier* Arena::CreateMaybeMessage<::kiapi::common::types::ProjectSpecifier>(Arena*);
template<> KIAPI_IMPORTEXPORT ::kiapi::common::types::Ratio* Arena::CreateMaybeMessage<::kiapi::common::types::Ratio>(Arena*);
template<> KIAPI_IMPORTEXPORT ::kiapi::common::types::SheetPath* Arena::CreateMaybeMessage<::kiapi::common::types::SheetPath>(Arena*);
template<> KIAPI_IMPORTEXPORT ::kiapi::common::types::StrokeAttributes* Arena::CreateMaybeMessage<::kiapi::common::types::StrokeAttributes>(Arena*);
template<> KIAPI_IMPORTEXPORT ::kiapi::common::types::Text* Arena::CreateMaybeMessage<::kiapi::common::types::Text>(Arena*);
template<> KIAPI_IMPORTEXPORT ::kiapi::common::types::TextAttributes* Arena::CreateMaybeMessage<::kiapi::common::types::TextAttributes>(Arena*);
template<> KIAPI_IMPORTEXPORT ::kiapi::common::types::TextBox* Arena::CreateMaybeMessage<::kiapi::common::types::TextBox>(Arena*);
template<> KIAPI_IMPORTEXPORT ::kiapi::common::types::TitleBlockInfo* Arena::CreateMaybeMessage<::kiapi::common::types::TitleBlockInfo>(Arena*);
template<> KIAPI_IMPORTEXPORT ::kiapi::common::types::Vector2* Arena::CreateMaybeMessage<::kiapi::common::types::Vector2>(Arena*);
template<> KIAPI_IMPORTEXPORT ::kiapi::common::types::Vector3* Arena::CreateMaybeMessage<::kiapi::common::types::Vector3>(Arena*);
template<> KIAPI_IMPORTEXPORT ::kiapi::common::types::Vector3D* Arena::CreateMaybeMessage<::kiapi::common::types::Vector3D>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace kiapi {
namespace common {
namespace types {

enum CommandStatus : int {
  CS_UNKNOWN = 0,
  CS_OK = 1,
  CS_FAILED = 2,
  CommandStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CommandStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
KIAPI_IMPORTEXPORT bool CommandStatus_IsValid(int value);
constexpr CommandStatus CommandStatus_MIN = CS_UNKNOWN;
constexpr CommandStatus CommandStatus_MAX = CS_FAILED;
constexpr int CommandStatus_ARRAYSIZE = CommandStatus_MAX + 1;

KIAPI_IMPORTEXPORT const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CommandStatus_descriptor();
template<typename T>
inline const std::string& CommandStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CommandStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CommandStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CommandStatus_descriptor(), enum_t_value);
}
inline bool CommandStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CommandStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CommandStatus>(
    CommandStatus_descriptor(), name, value);
}
enum FrameType : int {
  FT_UNKNOWN = 0,
  FT_PROJECT_MANAGER = 1,
  FT_SCHEMATIC_EDITOR = 2,
  FT_PCB_EDITOR = 3,
  FT_SPICE_SIMULATOR = 4,
  FT_SYMBOL_EDITOR = 5,
  FT_FOOTPRINT_EDITOR = 6,
  FT_DRAWING_SHEET_EDITOR = 7,
  FrameType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  FrameType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
KIAPI_IMPORTEXPORT bool FrameType_IsValid(int value);
constexpr FrameType FrameType_MIN = FT_UNKNOWN;
constexpr FrameType FrameType_MAX = FT_DRAWING_SHEET_EDITOR;
constexpr int FrameType_ARRAYSIZE = FrameType_MAX + 1;

KIAPI_IMPORTEXPORT const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FrameType_descriptor();
template<typename T>
inline const std::string& FrameType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FrameType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FrameType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FrameType_descriptor(), enum_t_value);
}
inline bool FrameType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FrameType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FrameType>(
    FrameType_descriptor(), name, value);
}
enum DocumentType : int {
  DOCTYPE_UNKNOWN = 0,
  DOCTYPE_SCHEMATIC = 1,
  DOCTYPE_SYMBOL = 2,
  DOCTYPE_PCB = 3,
  DOCTYPE_FOOTPRINT = 4,
  DOCTYPE_DRAWING_SHEET = 5,
  DOCTYPE_PROJECT = 6,
  DocumentType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DocumentType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
KIAPI_IMPORTEXPORT bool DocumentType_IsValid(int value);
constexpr DocumentType DocumentType_MIN = DOCTYPE_UNKNOWN;
constexpr DocumentType DocumentType_MAX = DOCTYPE_PROJECT;
constexpr int DocumentType_ARRAYSIZE = DocumentType_MAX + 1;

KIAPI_IMPORTEXPORT const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DocumentType_descriptor();
template<typename T>
inline const std::string& DocumentType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DocumentType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DocumentType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DocumentType_descriptor(), enum_t_value);
}
inline bool DocumentType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DocumentType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DocumentType>(
    DocumentType_descriptor(), name, value);
}
enum ItemRequestStatus : int {
  IRS_UNKNOWN = 0,
  IRS_OK = 1,
  IRS_DOCUMENT_NOT_FOUND = 2,
  IRS_FIELD_MASK_INVALID = 3,
  ItemRequestStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ItemRequestStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
KIAPI_IMPORTEXPORT bool ItemRequestStatus_IsValid(int value);
constexpr ItemRequestStatus ItemRequestStatus_MIN = IRS_UNKNOWN;
constexpr ItemRequestStatus ItemRequestStatus_MAX = IRS_FIELD_MASK_INVALID;
constexpr int ItemRequestStatus_ARRAYSIZE = ItemRequestStatus_MAX + 1;

KIAPI_IMPORTEXPORT const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ItemRequestStatus_descriptor();
template<typename T>
inline const std::string& ItemRequestStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ItemRequestStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ItemRequestStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ItemRequestStatus_descriptor(), enum_t_value);
}
inline bool ItemRequestStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ItemRequestStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ItemRequestStatus>(
    ItemRequestStatus_descriptor(), name, value);
}
enum LockedState : int {
  LS_UNKNOWN = 0,
  LS_UNLOCKED = 1,
  LS_LOCKED = 2,
  LockedState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  LockedState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
KIAPI_IMPORTEXPORT bool LockedState_IsValid(int value);
constexpr LockedState LockedState_MIN = LS_UNKNOWN;
constexpr LockedState LockedState_MAX = LS_LOCKED;
constexpr int LockedState_ARRAYSIZE = LockedState_MAX + 1;

KIAPI_IMPORTEXPORT const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LockedState_descriptor();
template<typename T>
inline const std::string& LockedState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LockedState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LockedState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LockedState_descriptor(), enum_t_value);
}
inline bool LockedState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LockedState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LockedState>(
    LockedState_descriptor(), name, value);
}
enum GraphicFillType : int {
  GFT_UNKNOWN = 0,
  GFT_UNFILLED = 1,
  GFT_FILLED = 2,
  GraphicFillType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  GraphicFillType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
KIAPI_IMPORTEXPORT bool GraphicFillType_IsValid(int value);
constexpr GraphicFillType GraphicFillType_MIN = GFT_UNKNOWN;
constexpr GraphicFillType GraphicFillType_MAX = GFT_FILLED;
constexpr int GraphicFillType_ARRAYSIZE = GraphicFillType_MAX + 1;

KIAPI_IMPORTEXPORT const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GraphicFillType_descriptor();
template<typename T>
inline const std::string& GraphicFillType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GraphicFillType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GraphicFillType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GraphicFillType_descriptor(), enum_t_value);
}
inline bool GraphicFillType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GraphicFillType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GraphicFillType>(
    GraphicFillType_descriptor(), name, value);
}
enum AxisAlignment : int {
  AA_UNKNOWN = 0,
  AA_X_AXIS = 1,
  AA_Y_AXIS = 2,
  AxisAlignment_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  AxisAlignment_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
KIAPI_IMPORTEXPORT bool AxisAlignment_IsValid(int value);
constexpr AxisAlignment AxisAlignment_MIN = AA_UNKNOWN;
constexpr AxisAlignment AxisAlignment_MAX = AA_Y_AXIS;
constexpr int AxisAlignment_ARRAYSIZE = AxisAlignment_MAX + 1;

KIAPI_IMPORTEXPORT const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AxisAlignment_descriptor();
template<typename T>
inline const std::string& AxisAlignment_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AxisAlignment>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AxisAlignment_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AxisAlignment_descriptor(), enum_t_value);
}
inline bool AxisAlignment_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AxisAlignment* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AxisAlignment>(
    AxisAlignment_descriptor(), name, value);
}
enum MapMergeMode : int {
  MMM_UNKNOWN = 0,
  MMM_MERGE = 1,
  MMM_REPLACE = 2,
  MapMergeMode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MapMergeMode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
KIAPI_IMPORTEXPORT bool MapMergeMode_IsValid(int value);
constexpr MapMergeMode MapMergeMode_MIN = MMM_UNKNOWN;
constexpr MapMergeMode MapMergeMode_MAX = MMM_REPLACE;
constexpr int MapMergeMode_ARRAYSIZE = MapMergeMode_MAX + 1;

KIAPI_IMPORTEXPORT const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MapMergeMode_descriptor();
template<typename T>
inline const std::string& MapMergeMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MapMergeMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MapMergeMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MapMergeMode_descriptor(), enum_t_value);
}
inline bool MapMergeMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MapMergeMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MapMergeMode>(
    MapMergeMode_descriptor(), name, value);
}
// ===================================================================

class KIAPI_IMPORTEXPORT CommandStatusResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kiapi.common.types.CommandStatusResponse) */ {
 public:
  inline CommandStatusResponse() : CommandStatusResponse(nullptr) {}
  ~CommandStatusResponse() override;
  explicit constexpr CommandStatusResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommandStatusResponse(const CommandStatusResponse& from);
  CommandStatusResponse(CommandStatusResponse&& from) noexcept
    : CommandStatusResponse() {
    *this = ::std::move(from);
  }

  inline CommandStatusResponse& operator=(const CommandStatusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandStatusResponse& operator=(CommandStatusResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CommandStatusResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandStatusResponse* internal_default_instance() {
    return reinterpret_cast<const CommandStatusResponse*>(
               &_CommandStatusResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CommandStatusResponse& a, CommandStatusResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandStatusResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandStatusResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandStatusResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommandStatusResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CommandStatusResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CommandStatusResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CommandStatusResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kiapi.common.types.CommandStatusResponse";
  }
  protected:
  explicit CommandStatusResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // .kiapi.common.types.CommandStatus status = 1;
  void clear_status();
  ::kiapi::common::types::CommandStatus status() const;
  void set_status(::kiapi::common::types::CommandStatus value);
  private:
  ::kiapi::common::types::CommandStatus _internal_status() const;
  void _internal_set_status(::kiapi::common::types::CommandStatus value);
  public:

  // @@protoc_insertion_point(class_scope:kiapi.common.types.CommandStatusResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2ftypes_2fbase_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class KIAPI_IMPORTEXPORT KiCadVersion final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kiapi.common.types.KiCadVersion) */ {
 public:
  inline KiCadVersion() : KiCadVersion(nullptr) {}
  ~KiCadVersion() override;
  explicit constexpr KiCadVersion(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KiCadVersion(const KiCadVersion& from);
  KiCadVersion(KiCadVersion&& from) noexcept
    : KiCadVersion() {
    *this = ::std::move(from);
  }

  inline KiCadVersion& operator=(const KiCadVersion& from) {
    CopyFrom(from);
    return *this;
  }
  inline KiCadVersion& operator=(KiCadVersion&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KiCadVersion& default_instance() {
    return *internal_default_instance();
  }
  static inline const KiCadVersion* internal_default_instance() {
    return reinterpret_cast<const KiCadVersion*>(
               &_KiCadVersion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(KiCadVersion& a, KiCadVersion& b) {
    a.Swap(&b);
  }
  inline void Swap(KiCadVersion* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KiCadVersion* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KiCadVersion* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KiCadVersion>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KiCadVersion& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const KiCadVersion& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KiCadVersion* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kiapi.common.types.KiCadVersion";
  }
  protected:
  explicit KiCadVersion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFullVersionFieldNumber = 4,
    kMajorFieldNumber = 1,
    kMinorFieldNumber = 2,
    kPatchFieldNumber = 3,
  };
  // string full_version = 4;
  void clear_full_version();
  const std::string& full_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_full_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_full_version();
  PROTOBUF_NODISCARD std::string* release_full_version();
  void set_allocated_full_version(std::string* full_version);
  private:
  const std::string& _internal_full_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_full_version(const std::string& value);
  std::string* _internal_mutable_full_version();
  public:

  // uint32 major = 1;
  void clear_major();
  uint32_t major() const;
  void set_major(uint32_t value);
  private:
  uint32_t _internal_major() const;
  void _internal_set_major(uint32_t value);
  public:

  // uint32 minor = 2;
  void clear_minor();
  uint32_t minor() const;
  void set_minor(uint32_t value);
  private:
  uint32_t _internal_minor() const;
  void _internal_set_minor(uint32_t value);
  public:

  // uint32 patch = 3;
  void clear_patch();
  uint32_t patch() const;
  void set_patch(uint32_t value);
  private:
  uint32_t _internal_patch() const;
  void _internal_set_patch(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:kiapi.common.types.KiCadVersion)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr full_version_;
  uint32_t major_;
  uint32_t minor_;
  uint32_t patch_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2ftypes_2fbase_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class KIAPI_IMPORTEXPORT KIID final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kiapi.common.types.KIID) */ {
 public:
  inline KIID() : KIID(nullptr) {}
  ~KIID() override;
  explicit constexpr KIID(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KIID(const KIID& from);
  KIID(KIID&& from) noexcept
    : KIID() {
    *this = ::std::move(from);
  }

  inline KIID& operator=(const KIID& from) {
    CopyFrom(from);
    return *this;
  }
  inline KIID& operator=(KIID&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KIID& default_instance() {
    return *internal_default_instance();
  }
  static inline const KIID* internal_default_instance() {
    return reinterpret_cast<const KIID*>(
               &_KIID_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(KIID& a, KIID& b) {
    a.Swap(&b);
  }
  inline void Swap(KIID* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KIID* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KIID* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KIID>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KIID& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const KIID& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KIID* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kiapi.common.types.KIID";
  }
  protected:
  explicit KIID(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // string value = 1;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:kiapi.common.types.KIID)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2ftypes_2fbase_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class KIAPI_IMPORTEXPORT LibraryIdentifier final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kiapi.common.types.LibraryIdentifier) */ {
 public:
  inline LibraryIdentifier() : LibraryIdentifier(nullptr) {}
  ~LibraryIdentifier() override;
  explicit constexpr LibraryIdentifier(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LibraryIdentifier(const LibraryIdentifier& from);
  LibraryIdentifier(LibraryIdentifier&& from) noexcept
    : LibraryIdentifier() {
    *this = ::std::move(from);
  }

  inline LibraryIdentifier& operator=(const LibraryIdentifier& from) {
    CopyFrom(from);
    return *this;
  }
  inline LibraryIdentifier& operator=(LibraryIdentifier&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LibraryIdentifier& default_instance() {
    return *internal_default_instance();
  }
  static inline const LibraryIdentifier* internal_default_instance() {
    return reinterpret_cast<const LibraryIdentifier*>(
               &_LibraryIdentifier_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(LibraryIdentifier& a, LibraryIdentifier& b) {
    a.Swap(&b);
  }
  inline void Swap(LibraryIdentifier* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LibraryIdentifier* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LibraryIdentifier* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LibraryIdentifier>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LibraryIdentifier& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LibraryIdentifier& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LibraryIdentifier* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kiapi.common.types.LibraryIdentifier";
  }
  protected:
  explicit LibraryIdentifier(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLibraryNicknameFieldNumber = 1,
    kEntryNameFieldNumber = 2,
  };
  // string library_nickname = 1;
  void clear_library_nickname();
  const std::string& library_nickname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_library_nickname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_library_nickname();
  PROTOBUF_NODISCARD std::string* release_library_nickname();
  void set_allocated_library_nickname(std::string* library_nickname);
  private:
  const std::string& _internal_library_nickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_library_nickname(const std::string& value);
  std::string* _internal_mutable_library_nickname();
  public:

  // string entry_name = 2;
  void clear_entry_name();
  const std::string& entry_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_entry_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_entry_name();
  PROTOBUF_NODISCARD std::string* release_entry_name();
  void set_allocated_entry_name(std::string* entry_name);
  private:
  const std::string& _internal_entry_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_entry_name(const std::string& value);
  std::string* _internal_mutable_entry_name();
  public:

  // @@protoc_insertion_point(class_scope:kiapi.common.types.LibraryIdentifier)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr library_nickname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr entry_name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2ftypes_2fbase_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class KIAPI_IMPORTEXPORT SheetPath final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kiapi.common.types.SheetPath) */ {
 public:
  inline SheetPath() : SheetPath(nullptr) {}
  ~SheetPath() override;
  explicit constexpr SheetPath(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SheetPath(const SheetPath& from);
  SheetPath(SheetPath&& from) noexcept
    : SheetPath() {
    *this = ::std::move(from);
  }

  inline SheetPath& operator=(const SheetPath& from) {
    CopyFrom(from);
    return *this;
  }
  inline SheetPath& operator=(SheetPath&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SheetPath& default_instance() {
    return *internal_default_instance();
  }
  static inline const SheetPath* internal_default_instance() {
    return reinterpret_cast<const SheetPath*>(
               &_SheetPath_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SheetPath& a, SheetPath& b) {
    a.Swap(&b);
  }
  inline void Swap(SheetPath* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SheetPath* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SheetPath* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SheetPath>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SheetPath& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SheetPath& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SheetPath* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kiapi.common.types.SheetPath";
  }
  protected:
  explicit SheetPath(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 1,
    kPathHumanReadableFieldNumber = 2,
  };
  // repeated .kiapi.common.types.KIID path = 1;
  int path_size() const;
  private:
  int _internal_path_size() const;
  public:
  void clear_path();
  ::kiapi::common::types::KIID* mutable_path(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::types::KIID >*
      mutable_path();
  private:
  const ::kiapi::common::types::KIID& _internal_path(int index) const;
  ::kiapi::common::types::KIID* _internal_add_path();
  public:
  const ::kiapi::common::types::KIID& path(int index) const;
  ::kiapi::common::types::KIID* add_path();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::types::KIID >&
      path() const;

  // string path_human_readable = 2;
  void clear_path_human_readable();
  const std::string& path_human_readable() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path_human_readable(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path_human_readable();
  PROTOBUF_NODISCARD std::string* release_path_human_readable();
  void set_allocated_path_human_readable(std::string* path_human_readable);
  private:
  const std::string& _internal_path_human_readable() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path_human_readable(const std::string& value);
  std::string* _internal_mutable_path_human_readable();
  public:

  // @@protoc_insertion_point(class_scope:kiapi.common.types.SheetPath)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::types::KIID > path_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_human_readable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2ftypes_2fbase_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class KIAPI_IMPORTEXPORT ProjectSpecifier final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kiapi.common.types.ProjectSpecifier) */ {
 public:
  inline ProjectSpecifier() : ProjectSpecifier(nullptr) {}
  ~ProjectSpecifier() override;
  explicit constexpr ProjectSpecifier(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProjectSpecifier(const ProjectSpecifier& from);
  ProjectSpecifier(ProjectSpecifier&& from) noexcept
    : ProjectSpecifier() {
    *this = ::std::move(from);
  }

  inline ProjectSpecifier& operator=(const ProjectSpecifier& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProjectSpecifier& operator=(ProjectSpecifier&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProjectSpecifier& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProjectSpecifier* internal_default_instance() {
    return reinterpret_cast<const ProjectSpecifier*>(
               &_ProjectSpecifier_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ProjectSpecifier& a, ProjectSpecifier& b) {
    a.Swap(&b);
  }
  inline void Swap(ProjectSpecifier* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProjectSpecifier* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProjectSpecifier* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProjectSpecifier>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProjectSpecifier& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ProjectSpecifier& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProjectSpecifier* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kiapi.common.types.ProjectSpecifier";
  }
  protected:
  explicit ProjectSpecifier(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kPathFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string path = 2;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // @@protoc_insertion_point(class_scope:kiapi.common.types.ProjectSpecifier)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2ftypes_2fbase_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class KIAPI_IMPORTEXPORT DocumentSpecifier final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kiapi.common.types.DocumentSpecifier) */ {
 public:
  inline DocumentSpecifier() : DocumentSpecifier(nullptr) {}
  ~DocumentSpecifier() override;
  explicit constexpr DocumentSpecifier(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DocumentSpecifier(const DocumentSpecifier& from);
  DocumentSpecifier(DocumentSpecifier&& from) noexcept
    : DocumentSpecifier() {
    *this = ::std::move(from);
  }

  inline DocumentSpecifier& operator=(const DocumentSpecifier& from) {
    CopyFrom(from);
    return *this;
  }
  inline DocumentSpecifier& operator=(DocumentSpecifier&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DocumentSpecifier& default_instance() {
    return *internal_default_instance();
  }
  enum IdentifierCase {
    kLibId = 2,
    kSheetPath = 3,
    kBoardFilename = 4,
    IDENTIFIER_NOT_SET = 0,
  };

  static inline const DocumentSpecifier* internal_default_instance() {
    return reinterpret_cast<const DocumentSpecifier*>(
               &_DocumentSpecifier_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(DocumentSpecifier& a, DocumentSpecifier& b) {
    a.Swap(&b);
  }
  inline void Swap(DocumentSpecifier* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DocumentSpecifier* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DocumentSpecifier* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DocumentSpecifier>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DocumentSpecifier& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DocumentSpecifier& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DocumentSpecifier* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kiapi.common.types.DocumentSpecifier";
  }
  protected:
  explicit DocumentSpecifier(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProjectFieldNumber = 5,
    kTypeFieldNumber = 1,
    kLibIdFieldNumber = 2,
    kSheetPathFieldNumber = 3,
    kBoardFilenameFieldNumber = 4,
  };
  // .kiapi.common.types.ProjectSpecifier project = 5;
  bool has_project() const;
  private:
  bool _internal_has_project() const;
  public:
  void clear_project();
  const ::kiapi::common::types::ProjectSpecifier& project() const;
  PROTOBUF_NODISCARD ::kiapi::common::types::ProjectSpecifier* release_project();
  ::kiapi::common::types::ProjectSpecifier* mutable_project();
  void set_allocated_project(::kiapi::common::types::ProjectSpecifier* project);
  private:
  const ::kiapi::common::types::ProjectSpecifier& _internal_project() const;
  ::kiapi::common::types::ProjectSpecifier* _internal_mutable_project();
  public:
  void unsafe_arena_set_allocated_project(
      ::kiapi::common::types::ProjectSpecifier* project);
  ::kiapi::common::types::ProjectSpecifier* unsafe_arena_release_project();

  // .kiapi.common.types.DocumentType type = 1;
  void clear_type();
  ::kiapi::common::types::DocumentType type() const;
  void set_type(::kiapi::common::types::DocumentType value);
  private:
  ::kiapi::common::types::DocumentType _internal_type() const;
  void _internal_set_type(::kiapi::common::types::DocumentType value);
  public:

  // .kiapi.common.types.LibraryIdentifier lib_id = 2;
  bool has_lib_id() const;
  private:
  bool _internal_has_lib_id() const;
  public:
  void clear_lib_id();
  const ::kiapi::common::types::LibraryIdentifier& lib_id() const;
  PROTOBUF_NODISCARD ::kiapi::common::types::LibraryIdentifier* release_lib_id();
  ::kiapi::common::types::LibraryIdentifier* mutable_lib_id();
  void set_allocated_lib_id(::kiapi::common::types::LibraryIdentifier* lib_id);
  private:
  const ::kiapi::common::types::LibraryIdentifier& _internal_lib_id() const;
  ::kiapi::common::types::LibraryIdentifier* _internal_mutable_lib_id();
  public:
  void unsafe_arena_set_allocated_lib_id(
      ::kiapi::common::types::LibraryIdentifier* lib_id);
  ::kiapi::common::types::LibraryIdentifier* unsafe_arena_release_lib_id();

  // .kiapi.common.types.SheetPath sheet_path = 3;
  bool has_sheet_path() const;
  private:
  bool _internal_has_sheet_path() const;
  public:
  void clear_sheet_path();
  const ::kiapi::common::types::SheetPath& sheet_path() const;
  PROTOBUF_NODISCARD ::kiapi::common::types::SheetPath* release_sheet_path();
  ::kiapi::common::types::SheetPath* mutable_sheet_path();
  void set_allocated_sheet_path(::kiapi::common::types::SheetPath* sheet_path);
  private:
  const ::kiapi::common::types::SheetPath& _internal_sheet_path() const;
  ::kiapi::common::types::SheetPath* _internal_mutable_sheet_path();
  public:
  void unsafe_arena_set_allocated_sheet_path(
      ::kiapi::common::types::SheetPath* sheet_path);
  ::kiapi::common::types::SheetPath* unsafe_arena_release_sheet_path();

  // string board_filename = 4;
  bool has_board_filename() const;
  private:
  bool _internal_has_board_filename() const;
  public:
  void clear_board_filename();
  const std::string& board_filename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_board_filename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_board_filename();
  PROTOBUF_NODISCARD std::string* release_board_filename();
  void set_allocated_board_filename(std::string* board_filename);
  private:
  const std::string& _internal_board_filename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_board_filename(const std::string& value);
  std::string* _internal_mutable_board_filename();
  public:

  void clear_identifier();
  IdentifierCase identifier_case() const;
  // @@protoc_insertion_point(class_scope:kiapi.common.types.DocumentSpecifier)
 private:
  class _Internal;
  void set_has_lib_id();
  void set_has_sheet_path();
  void set_has_board_filename();

  inline bool has_identifier() const;
  inline void clear_has_identifier();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::kiapi::common::types::ProjectSpecifier* project_;
  int type_;
  union IdentifierUnion {
    constexpr IdentifierUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::kiapi::common::types::LibraryIdentifier* lib_id_;
    ::kiapi::common::types::SheetPath* sheet_path_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr board_filename_;
  } identifier_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_common_2ftypes_2fbase_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class KIAPI_IMPORTEXPORT ItemHeader final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kiapi.common.types.ItemHeader) */ {
 public:
  inline ItemHeader() : ItemHeader(nullptr) {}
  ~ItemHeader() override;
  explicit constexpr ItemHeader(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ItemHeader(const ItemHeader& from);
  ItemHeader(ItemHeader&& from) noexcept
    : ItemHeader() {
    *this = ::std::move(from);
  }

  inline ItemHeader& operator=(const ItemHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline ItemHeader& operator=(ItemHeader&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ItemHeader& default_instance() {
    return *internal_default_instance();
  }
  static inline const ItemHeader* internal_default_instance() {
    return reinterpret_cast<const ItemHeader*>(
               &_ItemHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ItemHeader& a, ItemHeader& b) {
    a.Swap(&b);
  }
  inline void Swap(ItemHeader* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ItemHeader* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ItemHeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ItemHeader>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ItemHeader& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ItemHeader& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ItemHeader* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kiapi.common.types.ItemHeader";
  }
  protected:
  explicit ItemHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDocumentFieldNumber = 1,
    kContainerFieldNumber = 2,
    kFieldMaskFieldNumber = 3,
  };
  // .kiapi.common.types.DocumentSpecifier document = 1;
  bool has_document() const;
  private:
  bool _internal_has_document() const;
  public:
  void clear_document();
  const ::kiapi::common::types::DocumentSpecifier& document() const;
  PROTOBUF_NODISCARD ::kiapi::common::types::DocumentSpecifier* release_document();
  ::kiapi::common::types::DocumentSpecifier* mutable_document();
  void set_allocated_document(::kiapi::common::types::DocumentSpecifier* document);
  private:
  const ::kiapi::common::types::DocumentSpecifier& _internal_document() const;
  ::kiapi::common::types::DocumentSpecifier* _internal_mutable_document();
  public:
  void unsafe_arena_set_allocated_document(
      ::kiapi::common::types::DocumentSpecifier* document);
  ::kiapi::common::types::DocumentSpecifier* unsafe_arena_release_document();

  // .kiapi.common.types.KIID container = 2;
  bool has_container() const;
  private:
  bool _internal_has_container() const;
  public:
  void clear_container();
  const ::kiapi::common::types::KIID& container() const;
  PROTOBUF_NODISCARD ::kiapi::common::types::KIID* release_container();
  ::kiapi::common::types::KIID* mutable_container();
  void set_allocated_container(::kiapi::common::types::KIID* container);
  private:
  const ::kiapi::common::types::KIID& _internal_container() const;
  ::kiapi::common::types::KIID* _internal_mutable_container();
  public:
  void unsafe_arena_set_allocated_container(
      ::kiapi::common::types::KIID* container);
  ::kiapi::common::types::KIID* unsafe_arena_release_container();

  // .google.protobuf.FieldMask field_mask = 3;
  bool has_field_mask() const;
  private:
  bool _internal_has_field_mask() const;
  public:
  void clear_field_mask();
  const ::PROTOBUF_NAMESPACE_ID::FieldMask& field_mask() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::FieldMask* release_field_mask();
  ::PROTOBUF_NAMESPACE_ID::FieldMask* mutable_field_mask();
  void set_allocated_field_mask(::PROTOBUF_NAMESPACE_ID::FieldMask* field_mask);
  private:
  const ::PROTOBUF_NAMESPACE_ID::FieldMask& _internal_field_mask() const;
  ::PROTOBUF_NAMESPACE_ID::FieldMask* _internal_mutable_field_mask();
  public:
  void unsafe_arena_set_allocated_field_mask(
      ::PROTOBUF_NAMESPACE_ID::FieldMask* field_mask);
  ::PROTOBUF_NAMESPACE_ID::FieldMask* unsafe_arena_release_field_mask();

  // @@protoc_insertion_point(class_scope:kiapi.common.types.ItemHeader)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::kiapi::common::types::DocumentSpecifier* document_;
  ::kiapi::common::types::KIID* container_;
  ::PROTOBUF_NAMESPACE_ID::FieldMask* field_mask_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2ftypes_2fbase_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class KIAPI_IMPORTEXPORT Vector2 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kiapi.common.types.Vector2) */ {
 public:
  inline Vector2() : Vector2(nullptr) {}
  ~Vector2() override;
  explicit constexpr Vector2(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Vector2(const Vector2& from);
  Vector2(Vector2&& from) noexcept
    : Vector2() {
    *this = ::std::move(from);
  }

  inline Vector2& operator=(const Vector2& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vector2& operator=(Vector2&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vector2& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vector2* internal_default_instance() {
    return reinterpret_cast<const Vector2*>(
               &_Vector2_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Vector2& a, Vector2& b) {
    a.Swap(&b);
  }
  inline void Swap(Vector2* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vector2* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vector2* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Vector2>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Vector2& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Vector2& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vector2* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kiapi.common.types.Vector2";
  }
  protected:
  explicit Vector2(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXNmFieldNumber = 1,
    kYNmFieldNumber = 2,
  };
  // int64 x_nm = 1;
  void clear_x_nm();
  int64_t x_nm() const;
  void set_x_nm(int64_t value);
  private:
  int64_t _internal_x_nm() const;
  void _internal_set_x_nm(int64_t value);
  public:

  // int64 y_nm = 2;
  void clear_y_nm();
  int64_t y_nm() const;
  void set_y_nm(int64_t value);
  private:
  int64_t _internal_y_nm() const;
  void _internal_set_y_nm(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:kiapi.common.types.Vector2)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int64_t x_nm_;
  int64_t y_nm_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2ftypes_2fbase_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class KIAPI_IMPORTEXPORT Vector3 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kiapi.common.types.Vector3) */ {
 public:
  inline Vector3() : Vector3(nullptr) {}
  ~Vector3() override;
  explicit constexpr Vector3(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Vector3(const Vector3& from);
  Vector3(Vector3&& from) noexcept
    : Vector3() {
    *this = ::std::move(from);
  }

  inline Vector3& operator=(const Vector3& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vector3& operator=(Vector3&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vector3& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vector3* internal_default_instance() {
    return reinterpret_cast<const Vector3*>(
               &_Vector3_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Vector3& a, Vector3& b) {
    a.Swap(&b);
  }
  inline void Swap(Vector3* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vector3* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vector3* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Vector3>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Vector3& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Vector3& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vector3* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kiapi.common.types.Vector3";
  }
  protected:
  explicit Vector3(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXNmFieldNumber = 1,
    kYNmFieldNumber = 2,
    kZNmFieldNumber = 3,
  };
  // int64 x_nm = 1;
  void clear_x_nm();
  int64_t x_nm() const;
  void set_x_nm(int64_t value);
  private:
  int64_t _internal_x_nm() const;
  void _internal_set_x_nm(int64_t value);
  public:

  // int64 y_nm = 2;
  void clear_y_nm();
  int64_t y_nm() const;
  void set_y_nm(int64_t value);
  private:
  int64_t _internal_y_nm() const;
  void _internal_set_y_nm(int64_t value);
  public:

  // int64 z_nm = 3;
  void clear_z_nm();
  int64_t z_nm() const;
  void set_z_nm(int64_t value);
  private:
  int64_t _internal_z_nm() const;
  void _internal_set_z_nm(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:kiapi.common.types.Vector3)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int64_t x_nm_;
  int64_t y_nm_;
  int64_t z_nm_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2ftypes_2fbase_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class KIAPI_IMPORTEXPORT Vector3D final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kiapi.common.types.Vector3D) */ {
 public:
  inline Vector3D() : Vector3D(nullptr) {}
  ~Vector3D() override;
  explicit constexpr Vector3D(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Vector3D(const Vector3D& from);
  Vector3D(Vector3D&& from) noexcept
    : Vector3D() {
    *this = ::std::move(from);
  }

  inline Vector3D& operator=(const Vector3D& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vector3D& operator=(Vector3D&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vector3D& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vector3D* internal_default_instance() {
    return reinterpret_cast<const Vector3D*>(
               &_Vector3D_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Vector3D& a, Vector3D& b) {
    a.Swap(&b);
  }
  inline void Swap(Vector3D* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vector3D* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vector3D* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Vector3D>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Vector3D& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Vector3D& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vector3D* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kiapi.common.types.Vector3D";
  }
  protected:
  explicit Vector3D(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXNmFieldNumber = 1,
    kYNmFieldNumber = 2,
    kZNmFieldNumber = 3,
  };
  // double x_nm = 1;
  void clear_x_nm();
  double x_nm() const;
  void set_x_nm(double value);
  private:
  double _internal_x_nm() const;
  void _internal_set_x_nm(double value);
  public:

  // double y_nm = 2;
  void clear_y_nm();
  double y_nm() const;
  void set_y_nm(double value);
  private:
  double _internal_y_nm() const;
  void _internal_set_y_nm(double value);
  public:

  // double z_nm = 3;
  void clear_z_nm();
  double z_nm() const;
  void set_z_nm(double value);
  private:
  double _internal_z_nm() const;
  void _internal_set_z_nm(double value);
  public:

  // @@protoc_insertion_point(class_scope:kiapi.common.types.Vector3D)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double x_nm_;
  double y_nm_;
  double z_nm_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2ftypes_2fbase_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class KIAPI_IMPORTEXPORT Box2 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kiapi.common.types.Box2) */ {
 public:
  inline Box2() : Box2(nullptr) {}
  ~Box2() override;
  explicit constexpr Box2(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Box2(const Box2& from);
  Box2(Box2&& from) noexcept
    : Box2() {
    *this = ::std::move(from);
  }

  inline Box2& operator=(const Box2& from) {
    CopyFrom(from);
    return *this;
  }
  inline Box2& operator=(Box2&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Box2& default_instance() {
    return *internal_default_instance();
  }
  static inline const Box2* internal_default_instance() {
    return reinterpret_cast<const Box2*>(
               &_Box2_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Box2& a, Box2& b) {
    a.Swap(&b);
  }
  inline void Swap(Box2* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Box2* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Box2* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Box2>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Box2& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Box2& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Box2* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kiapi.common.types.Box2";
  }
  protected:
  explicit Box2(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 1,
    kSizeFieldNumber = 2,
  };
  // .kiapi.common.types.Vector2 position = 1;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::kiapi::common::types::Vector2& position() const;
  PROTOBUF_NODISCARD ::kiapi::common::types::Vector2* release_position();
  ::kiapi::common::types::Vector2* mutable_position();
  void set_allocated_position(::kiapi::common::types::Vector2* position);
  private:
  const ::kiapi::common::types::Vector2& _internal_position() const;
  ::kiapi::common::types::Vector2* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::kiapi::common::types::Vector2* position);
  ::kiapi::common::types::Vector2* unsafe_arena_release_position();

  // .kiapi.common.types.Vector2 size = 2;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  const ::kiapi::common::types::Vector2& size() const;
  PROTOBUF_NODISCARD ::kiapi::common::types::Vector2* release_size();
  ::kiapi::common::types::Vector2* mutable_size();
  void set_allocated_size(::kiapi::common::types::Vector2* size);
  private:
  const ::kiapi::common::types::Vector2& _internal_size() const;
  ::kiapi::common::types::Vector2* _internal_mutable_size();
  public:
  void unsafe_arena_set_allocated_size(
      ::kiapi::common::types::Vector2* size);
  ::kiapi::common::types::Vector2* unsafe_arena_release_size();

  // @@protoc_insertion_point(class_scope:kiapi.common.types.Box2)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::kiapi::common::types::Vector2* position_;
  ::kiapi::common::types::Vector2* size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2ftypes_2fbase_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class KIAPI_IMPORTEXPORT Distance final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kiapi.common.types.Distance) */ {
 public:
  inline Distance() : Distance(nullptr) {}
  ~Distance() override;
  explicit constexpr Distance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Distance(const Distance& from);
  Distance(Distance&& from) noexcept
    : Distance() {
    *this = ::std::move(from);
  }

  inline Distance& operator=(const Distance& from) {
    CopyFrom(from);
    return *this;
  }
  inline Distance& operator=(Distance&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Distance& default_instance() {
    return *internal_default_instance();
  }
  static inline const Distance* internal_default_instance() {
    return reinterpret_cast<const Distance*>(
               &_Distance_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Distance& a, Distance& b) {
    a.Swap(&b);
  }
  inline void Swap(Distance* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Distance* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Distance* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Distance>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Distance& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Distance& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Distance* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kiapi.common.types.Distance";
  }
  protected:
  explicit Distance(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueNmFieldNumber = 1,
  };
  // int64 value_nm = 1;
  void clear_value_nm();
  int64_t value_nm() const;
  void set_value_nm(int64_t value);
  private:
  int64_t _internal_value_nm() const;
  void _internal_set_value_nm(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:kiapi.common.types.Distance)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int64_t value_nm_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2ftypes_2fbase_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class KIAPI_IMPORTEXPORT Angle final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kiapi.common.types.Angle) */ {
 public:
  inline Angle() : Angle(nullptr) {}
  ~Angle() override;
  explicit constexpr Angle(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Angle(const Angle& from);
  Angle(Angle&& from) noexcept
    : Angle() {
    *this = ::std::move(from);
  }

  inline Angle& operator=(const Angle& from) {
    CopyFrom(from);
    return *this;
  }
  inline Angle& operator=(Angle&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Angle& default_instance() {
    return *internal_default_instance();
  }
  static inline const Angle* internal_default_instance() {
    return reinterpret_cast<const Angle*>(
               &_Angle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(Angle& a, Angle& b) {
    a.Swap(&b);
  }
  inline void Swap(Angle* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Angle* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Angle* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Angle>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Angle& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Angle& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Angle* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kiapi.common.types.Angle";
  }
  protected:
  explicit Angle(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueDegreesFieldNumber = 1,
  };
  // double value_degrees = 1;
  void clear_value_degrees();
  double value_degrees() const;
  void set_value_degrees(double value);
  private:
  double _internal_value_degrees() const;
  void _internal_set_value_degrees(double value);
  public:

  // @@protoc_insertion_point(class_scope:kiapi.common.types.Angle)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double value_degrees_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2ftypes_2fbase_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class KIAPI_IMPORTEXPORT Ratio final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kiapi.common.types.Ratio) */ {
 public:
  inline Ratio() : Ratio(nullptr) {}
  ~Ratio() override;
  explicit constexpr Ratio(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Ratio(const Ratio& from);
  Ratio(Ratio&& from) noexcept
    : Ratio() {
    *this = ::std::move(from);
  }

  inline Ratio& operator=(const Ratio& from) {
    CopyFrom(from);
    return *this;
  }
  inline Ratio& operator=(Ratio&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Ratio& default_instance() {
    return *internal_default_instance();
  }
  static inline const Ratio* internal_default_instance() {
    return reinterpret_cast<const Ratio*>(
               &_Ratio_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(Ratio& a, Ratio& b) {
    a.Swap(&b);
  }
  inline void Swap(Ratio* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Ratio* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Ratio* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Ratio>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Ratio& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Ratio& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Ratio* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kiapi.common.types.Ratio";
  }
  protected:
  explicit Ratio(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // double value = 1;
  void clear_value();
  double value() const;
  void set_value(double value);
  private:
  double _internal_value() const;
  void _internal_set_value(double value);
  public:

  // @@protoc_insertion_point(class_scope:kiapi.common.types.Ratio)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2ftypes_2fbase_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class KIAPI_IMPORTEXPORT Color final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kiapi.common.types.Color) */ {
 public:
  inline Color() : Color(nullptr) {}
  ~Color() override;
  explicit constexpr Color(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Color(const Color& from);
  Color(Color&& from) noexcept
    : Color() {
    *this = ::std::move(from);
  }

  inline Color& operator=(const Color& from) {
    CopyFrom(from);
    return *this;
  }
  inline Color& operator=(Color&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Color& default_instance() {
    return *internal_default_instance();
  }
  static inline const Color* internal_default_instance() {
    return reinterpret_cast<const Color*>(
               &_Color_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(Color& a, Color& b) {
    a.Swap(&b);
  }
  inline void Swap(Color* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Color* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Color* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Color>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Color& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Color& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Color* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kiapi.common.types.Color";
  }
  protected:
  explicit Color(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRFieldNumber = 1,
    kGFieldNumber = 2,
    kBFieldNumber = 3,
    kAFieldNumber = 4,
  };
  // double r = 1;
  void clear_r();
  double r() const;
  void set_r(double value);
  private:
  double _internal_r() const;
  void _internal_set_r(double value);
  public:

  // double g = 2;
  void clear_g();
  double g() const;
  void set_g(double value);
  private:
  double _internal_g() const;
  void _internal_set_g(double value);
  public:

  // double b = 3;
  void clear_b();
  double b() const;
  void set_b(double value);
  private:
  double _internal_b() const;
  void _internal_set_b(double value);
  public:

  // double a = 4;
  void clear_a();
  double a() const;
  void set_a(double value);
  private:
  double _internal_a() const;
  void _internal_set_a(double value);
  public:

  // @@protoc_insertion_point(class_scope:kiapi.common.types.Color)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double r_;
  double g_;
  double b_;
  double a_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2ftypes_2fbase_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class KIAPI_IMPORTEXPORT ArcStartMidEnd final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kiapi.common.types.ArcStartMidEnd) */ {
 public:
  inline ArcStartMidEnd() : ArcStartMidEnd(nullptr) {}
  ~ArcStartMidEnd() override;
  explicit constexpr ArcStartMidEnd(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ArcStartMidEnd(const ArcStartMidEnd& from);
  ArcStartMidEnd(ArcStartMidEnd&& from) noexcept
    : ArcStartMidEnd() {
    *this = ::std::move(from);
  }

  inline ArcStartMidEnd& operator=(const ArcStartMidEnd& from) {
    CopyFrom(from);
    return *this;
  }
  inline ArcStartMidEnd& operator=(ArcStartMidEnd&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ArcStartMidEnd& default_instance() {
    return *internal_default_instance();
  }
  static inline const ArcStartMidEnd* internal_default_instance() {
    return reinterpret_cast<const ArcStartMidEnd*>(
               &_ArcStartMidEnd_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ArcStartMidEnd& a, ArcStartMidEnd& b) {
    a.Swap(&b);
  }
  inline void Swap(ArcStartMidEnd* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ArcStartMidEnd* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ArcStartMidEnd* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ArcStartMidEnd>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ArcStartMidEnd& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ArcStartMidEnd& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ArcStartMidEnd* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kiapi.common.types.ArcStartMidEnd";
  }
  protected:
  explicit ArcStartMidEnd(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartFieldNumber = 1,
    kMidFieldNumber = 2,
    kEndFieldNumber = 3,
  };
  // .kiapi.common.types.Vector2 start = 1;
  bool has_start() const;
  private:
  bool _internal_has_start() const;
  public:
  void clear_start();
  const ::kiapi::common::types::Vector2& start() const;
  PROTOBUF_NODISCARD ::kiapi::common::types::Vector2* release_start();
  ::kiapi::common::types::Vector2* mutable_start();
  void set_allocated_start(::kiapi::common::types::Vector2* start);
  private:
  const ::kiapi::common::types::Vector2& _internal_start() const;
  ::kiapi::common::types::Vector2* _internal_mutable_start();
  public:
  void unsafe_arena_set_allocated_start(
      ::kiapi::common::types::Vector2* start);
  ::kiapi::common::types::Vector2* unsafe_arena_release_start();

  // .kiapi.common.types.Vector2 mid = 2;
  bool has_mid() const;
  private:
  bool _internal_has_mid() const;
  public:
  void clear_mid();
  const ::kiapi::common::types::Vector2& mid() const;
  PROTOBUF_NODISCARD ::kiapi::common::types::Vector2* release_mid();
  ::kiapi::common::types::Vector2* mutable_mid();
  void set_allocated_mid(::kiapi::common::types::Vector2* mid);
  private:
  const ::kiapi::common::types::Vector2& _internal_mid() const;
  ::kiapi::common::types::Vector2* _internal_mutable_mid();
  public:
  void unsafe_arena_set_allocated_mid(
      ::kiapi::common::types::Vector2* mid);
  ::kiapi::common::types::Vector2* unsafe_arena_release_mid();

  // .kiapi.common.types.Vector2 end = 3;
  bool has_end() const;
  private:
  bool _internal_has_end() const;
  public:
  void clear_end();
  const ::kiapi::common::types::Vector2& end() const;
  PROTOBUF_NODISCARD ::kiapi::common::types::Vector2* release_end();
  ::kiapi::common::types::Vector2* mutable_end();
  void set_allocated_end(::kiapi::common::types::Vector2* end);
  private:
  const ::kiapi::common::types::Vector2& _internal_end() const;
  ::kiapi::common::types::Vector2* _internal_mutable_end();
  public:
  void unsafe_arena_set_allocated_end(
      ::kiapi::common::types::Vector2* end);
  ::kiapi::common::types::Vector2* unsafe_arena_release_end();

  // @@protoc_insertion_point(class_scope:kiapi.common.types.ArcStartMidEnd)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::kiapi::common::types::Vector2* start_;
  ::kiapi::common::types::Vector2* mid_;
  ::kiapi::common::types::Vector2* end_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2ftypes_2fbase_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class KIAPI_IMPORTEXPORT PolyLineNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kiapi.common.types.PolyLineNode) */ {
 public:
  inline PolyLineNode() : PolyLineNode(nullptr) {}
  ~PolyLineNode() override;
  explicit constexpr PolyLineNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PolyLineNode(const PolyLineNode& from);
  PolyLineNode(PolyLineNode&& from) noexcept
    : PolyLineNode() {
    *this = ::std::move(from);
  }

  inline PolyLineNode& operator=(const PolyLineNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline PolyLineNode& operator=(PolyLineNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PolyLineNode& default_instance() {
    return *internal_default_instance();
  }
  enum GeometryCase {
    kPoint = 1,
    kArc = 2,
    GEOMETRY_NOT_SET = 0,
  };

  static inline const PolyLineNode* internal_default_instance() {
    return reinterpret_cast<const PolyLineNode*>(
               &_PolyLineNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(PolyLineNode& a, PolyLineNode& b) {
    a.Swap(&b);
  }
  inline void Swap(PolyLineNode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PolyLineNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PolyLineNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PolyLineNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PolyLineNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PolyLineNode& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PolyLineNode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kiapi.common.types.PolyLineNode";
  }
  protected:
  explicit PolyLineNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPointFieldNumber = 1,
    kArcFieldNumber = 2,
  };
  // .kiapi.common.types.Vector2 point = 1;
  bool has_point() const;
  private:
  bool _internal_has_point() const;
  public:
  void clear_point();
  const ::kiapi::common::types::Vector2& point() const;
  PROTOBUF_NODISCARD ::kiapi::common::types::Vector2* release_point();
  ::kiapi::common::types::Vector2* mutable_point();
  void set_allocated_point(::kiapi::common::types::Vector2* point);
  private:
  const ::kiapi::common::types::Vector2& _internal_point() const;
  ::kiapi::common::types::Vector2* _internal_mutable_point();
  public:
  void unsafe_arena_set_allocated_point(
      ::kiapi::common::types::Vector2* point);
  ::kiapi::common::types::Vector2* unsafe_arena_release_point();

  // .kiapi.common.types.ArcStartMidEnd arc = 2;
  bool has_arc() const;
  private:
  bool _internal_has_arc() const;
  public:
  void clear_arc();
  const ::kiapi::common::types::ArcStartMidEnd& arc() const;
  PROTOBUF_NODISCARD ::kiapi::common::types::ArcStartMidEnd* release_arc();
  ::kiapi::common::types::ArcStartMidEnd* mutable_arc();
  void set_allocated_arc(::kiapi::common::types::ArcStartMidEnd* arc);
  private:
  const ::kiapi::common::types::ArcStartMidEnd& _internal_arc() const;
  ::kiapi::common::types::ArcStartMidEnd* _internal_mutable_arc();
  public:
  void unsafe_arena_set_allocated_arc(
      ::kiapi::common::types::ArcStartMidEnd* arc);
  ::kiapi::common::types::ArcStartMidEnd* unsafe_arena_release_arc();

  void clear_geometry();
  GeometryCase geometry_case() const;
  // @@protoc_insertion_point(class_scope:kiapi.common.types.PolyLineNode)
 private:
  class _Internal;
  void set_has_point();
  void set_has_arc();

  inline bool has_geometry() const;
  inline void clear_has_geometry();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union GeometryUnion {
    constexpr GeometryUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::kiapi::common::types::Vector2* point_;
    ::kiapi::common::types::ArcStartMidEnd* arc_;
  } geometry_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_common_2ftypes_2fbase_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class KIAPI_IMPORTEXPORT PolyLine final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kiapi.common.types.PolyLine) */ {
 public:
  inline PolyLine() : PolyLine(nullptr) {}
  ~PolyLine() override;
  explicit constexpr PolyLine(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PolyLine(const PolyLine& from);
  PolyLine(PolyLine&& from) noexcept
    : PolyLine() {
    *this = ::std::move(from);
  }

  inline PolyLine& operator=(const PolyLine& from) {
    CopyFrom(from);
    return *this;
  }
  inline PolyLine& operator=(PolyLine&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PolyLine& default_instance() {
    return *internal_default_instance();
  }
  static inline const PolyLine* internal_default_instance() {
    return reinterpret_cast<const PolyLine*>(
               &_PolyLine_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(PolyLine& a, PolyLine& b) {
    a.Swap(&b);
  }
  inline void Swap(PolyLine* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PolyLine* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PolyLine* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PolyLine>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PolyLine& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PolyLine& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PolyLine* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kiapi.common.types.PolyLine";
  }
  protected:
  explicit PolyLine(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodesFieldNumber = 1,
    kClosedFieldNumber = 2,
  };
  // repeated .kiapi.common.types.PolyLineNode nodes = 1;
  int nodes_size() const;
  private:
  int _internal_nodes_size() const;
  public:
  void clear_nodes();
  ::kiapi::common::types::PolyLineNode* mutable_nodes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::types::PolyLineNode >*
      mutable_nodes();
  private:
  const ::kiapi::common::types::PolyLineNode& _internal_nodes(int index) const;
  ::kiapi::common::types::PolyLineNode* _internal_add_nodes();
  public:
  const ::kiapi::common::types::PolyLineNode& nodes(int index) const;
  ::kiapi::common::types::PolyLineNode* add_nodes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::types::PolyLineNode >&
      nodes() const;

  // bool closed = 2;
  void clear_closed();
  bool closed() const;
  void set_closed(bool value);
  private:
  bool _internal_closed() const;
  void _internal_set_closed(bool value);
  public:

  // @@protoc_insertion_point(class_scope:kiapi.common.types.PolyLine)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::types::PolyLineNode > nodes_;
  bool closed_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2ftypes_2fbase_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class KIAPI_IMPORTEXPORT PolygonWithHoles final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kiapi.common.types.PolygonWithHoles) */ {
 public:
  inline PolygonWithHoles() : PolygonWithHoles(nullptr) {}
  ~PolygonWithHoles() override;
  explicit constexpr PolygonWithHoles(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PolygonWithHoles(const PolygonWithHoles& from);
  PolygonWithHoles(PolygonWithHoles&& from) noexcept
    : PolygonWithHoles() {
    *this = ::std::move(from);
  }

  inline PolygonWithHoles& operator=(const PolygonWithHoles& from) {
    CopyFrom(from);
    return *this;
  }
  inline PolygonWithHoles& operator=(PolygonWithHoles&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PolygonWithHoles& default_instance() {
    return *internal_default_instance();
  }
  static inline const PolygonWithHoles* internal_default_instance() {
    return reinterpret_cast<const PolygonWithHoles*>(
               &_PolygonWithHoles_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(PolygonWithHoles& a, PolygonWithHoles& b) {
    a.Swap(&b);
  }
  inline void Swap(PolygonWithHoles* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PolygonWithHoles* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PolygonWithHoles* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PolygonWithHoles>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PolygonWithHoles& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PolygonWithHoles& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PolygonWithHoles* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kiapi.common.types.PolygonWithHoles";
  }
  protected:
  explicit PolygonWithHoles(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHolesFieldNumber = 2,
    kOutlineFieldNumber = 1,
  };
  // repeated .kiapi.common.types.PolyLine holes = 2;
  int holes_size() const;
  private:
  int _internal_holes_size() const;
  public:
  void clear_holes();
  ::kiapi::common::types::PolyLine* mutable_holes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::types::PolyLine >*
      mutable_holes();
  private:
  const ::kiapi::common::types::PolyLine& _internal_holes(int index) const;
  ::kiapi::common::types::PolyLine* _internal_add_holes();
  public:
  const ::kiapi::common::types::PolyLine& holes(int index) const;
  ::kiapi::common::types::PolyLine* add_holes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::types::PolyLine >&
      holes() const;

  // .kiapi.common.types.PolyLine outline = 1;
  bool has_outline() const;
  private:
  bool _internal_has_outline() const;
  public:
  void clear_outline();
  const ::kiapi::common::types::PolyLine& outline() const;
  PROTOBUF_NODISCARD ::kiapi::common::types::PolyLine* release_outline();
  ::kiapi::common::types::PolyLine* mutable_outline();
  void set_allocated_outline(::kiapi::common::types::PolyLine* outline);
  private:
  const ::kiapi::common::types::PolyLine& _internal_outline() const;
  ::kiapi::common::types::PolyLine* _internal_mutable_outline();
  public:
  void unsafe_arena_set_allocated_outline(
      ::kiapi::common::types::PolyLine* outline);
  ::kiapi::common::types::PolyLine* unsafe_arena_release_outline();

  // @@protoc_insertion_point(class_scope:kiapi.common.types.PolygonWithHoles)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::types::PolyLine > holes_;
  ::kiapi::common::types::PolyLine* outline_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2ftypes_2fbase_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class KIAPI_IMPORTEXPORT PolySet final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kiapi.common.types.PolySet) */ {
 public:
  inline PolySet() : PolySet(nullptr) {}
  ~PolySet() override;
  explicit constexpr PolySet(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PolySet(const PolySet& from);
  PolySet(PolySet&& from) noexcept
    : PolySet() {
    *this = ::std::move(from);
  }

  inline PolySet& operator=(const PolySet& from) {
    CopyFrom(from);
    return *this;
  }
  inline PolySet& operator=(PolySet&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PolySet& default_instance() {
    return *internal_default_instance();
  }
  static inline const PolySet* internal_default_instance() {
    return reinterpret_cast<const PolySet*>(
               &_PolySet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(PolySet& a, PolySet& b) {
    a.Swap(&b);
  }
  inline void Swap(PolySet* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PolySet* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PolySet* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PolySet>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PolySet& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PolySet& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PolySet* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kiapi.common.types.PolySet";
  }
  protected:
  explicit PolySet(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPolygonsFieldNumber = 1,
  };
  // repeated .kiapi.common.types.PolygonWithHoles polygons = 1;
  int polygons_size() const;
  private:
  int _internal_polygons_size() const;
  public:
  void clear_polygons();
  ::kiapi::common::types::PolygonWithHoles* mutable_polygons(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::types::PolygonWithHoles >*
      mutable_polygons();
  private:
  const ::kiapi::common::types::PolygonWithHoles& _internal_polygons(int index) const;
  ::kiapi::common::types::PolygonWithHoles* _internal_add_polygons();
  public:
  const ::kiapi::common::types::PolygonWithHoles& polygons(int index) const;
  ::kiapi::common::types::PolygonWithHoles* add_polygons();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::types::PolygonWithHoles >&
      polygons() const;

  // @@protoc_insertion_point(class_scope:kiapi.common.types.PolySet)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::types::PolygonWithHoles > polygons_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2ftypes_2fbase_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class KIAPI_IMPORTEXPORT TextAttributes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kiapi.common.types.TextAttributes) */ {
 public:
  inline TextAttributes() : TextAttributes(nullptr) {}
  ~TextAttributes() override;
  explicit constexpr TextAttributes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TextAttributes(const TextAttributes& from);
  TextAttributes(TextAttributes&& from) noexcept
    : TextAttributes() {
    *this = ::std::move(from);
  }

  inline TextAttributes& operator=(const TextAttributes& from) {
    CopyFrom(from);
    return *this;
  }
  inline TextAttributes& operator=(TextAttributes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TextAttributes& default_instance() {
    return *internal_default_instance();
  }
  static inline const TextAttributes* internal_default_instance() {
    return reinterpret_cast<const TextAttributes*>(
               &_TextAttributes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(TextAttributes& a, TextAttributes& b) {
    a.Swap(&b);
  }
  inline void Swap(TextAttributes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TextAttributes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TextAttributes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TextAttributes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TextAttributes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TextAttributes& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TextAttributes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kiapi.common.types.TextAttributes";
  }
  protected:
  explicit TextAttributes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFontNameFieldNumber = 1,
    kAngleFieldNumber = 4,
    kStrokeWidthFieldNumber = 6,
    kSizeFieldNumber = 14,
    kHorizontalAlignmentFieldNumber = 2,
    kVerticalAlignmentFieldNumber = 3,
    kLineSpacingFieldNumber = 5,
    kItalicFieldNumber = 7,
    kBoldFieldNumber = 8,
    kUnderlinedFieldNumber = 9,
    kVisibleFieldNumber = 10,
    kMirroredFieldNumber = 11,
    kMultilineFieldNumber = 12,
    kKeepUprightFieldNumber = 13,
  };
  // string font_name = 1;
  void clear_font_name();
  const std::string& font_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_font_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_font_name();
  PROTOBUF_NODISCARD std::string* release_font_name();
  void set_allocated_font_name(std::string* font_name);
  private:
  const std::string& _internal_font_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_font_name(const std::string& value);
  std::string* _internal_mutable_font_name();
  public:

  // .kiapi.common.types.Angle angle = 4;
  bool has_angle() const;
  private:
  bool _internal_has_angle() const;
  public:
  void clear_angle();
  const ::kiapi::common::types::Angle& angle() const;
  PROTOBUF_NODISCARD ::kiapi::common::types::Angle* release_angle();
  ::kiapi::common::types::Angle* mutable_angle();
  void set_allocated_angle(::kiapi::common::types::Angle* angle);
  private:
  const ::kiapi::common::types::Angle& _internal_angle() const;
  ::kiapi::common::types::Angle* _internal_mutable_angle();
  public:
  void unsafe_arena_set_allocated_angle(
      ::kiapi::common::types::Angle* angle);
  ::kiapi::common::types::Angle* unsafe_arena_release_angle();

  // .kiapi.common.types.Distance stroke_width = 6;
  bool has_stroke_width() const;
  private:
  bool _internal_has_stroke_width() const;
  public:
  void clear_stroke_width();
  const ::kiapi::common::types::Distance& stroke_width() const;
  PROTOBUF_NODISCARD ::kiapi::common::types::Distance* release_stroke_width();
  ::kiapi::common::types::Distance* mutable_stroke_width();
  void set_allocated_stroke_width(::kiapi::common::types::Distance* stroke_width);
  private:
  const ::kiapi::common::types::Distance& _internal_stroke_width() const;
  ::kiapi::common::types::Distance* _internal_mutable_stroke_width();
  public:
  void unsafe_arena_set_allocated_stroke_width(
      ::kiapi::common::types::Distance* stroke_width);
  ::kiapi::common::types::Distance* unsafe_arena_release_stroke_width();

  // .kiapi.common.types.Vector2 size = 14;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  const ::kiapi::common::types::Vector2& size() const;
  PROTOBUF_NODISCARD ::kiapi::common::types::Vector2* release_size();
  ::kiapi::common::types::Vector2* mutable_size();
  void set_allocated_size(::kiapi::common::types::Vector2* size);
  private:
  const ::kiapi::common::types::Vector2& _internal_size() const;
  ::kiapi::common::types::Vector2* _internal_mutable_size();
  public:
  void unsafe_arena_set_allocated_size(
      ::kiapi::common::types::Vector2* size);
  ::kiapi::common::types::Vector2* unsafe_arena_release_size();

  // .kiapi.common.types.HorizontalAlignment horizontal_alignment = 2;
  void clear_horizontal_alignment();
  ::kiapi::common::types::HorizontalAlignment horizontal_alignment() const;
  void set_horizontal_alignment(::kiapi::common::types::HorizontalAlignment value);
  private:
  ::kiapi::common::types::HorizontalAlignment _internal_horizontal_alignment() const;
  void _internal_set_horizontal_alignment(::kiapi::common::types::HorizontalAlignment value);
  public:

  // .kiapi.common.types.VerticalAlignment vertical_alignment = 3;
  void clear_vertical_alignment();
  ::kiapi::common::types::VerticalAlignment vertical_alignment() const;
  void set_vertical_alignment(::kiapi::common::types::VerticalAlignment value);
  private:
  ::kiapi::common::types::VerticalAlignment _internal_vertical_alignment() const;
  void _internal_set_vertical_alignment(::kiapi::common::types::VerticalAlignment value);
  public:

  // double line_spacing = 5;
  void clear_line_spacing();
  double line_spacing() const;
  void set_line_spacing(double value);
  private:
  double _internal_line_spacing() const;
  void _internal_set_line_spacing(double value);
  public:

  // bool italic = 7;
  void clear_italic();
  bool italic() const;
  void set_italic(bool value);
  private:
  bool _internal_italic() const;
  void _internal_set_italic(bool value);
  public:

  // bool bold = 8;
  void clear_bold();
  bool bold() const;
  void set_bold(bool value);
  private:
  bool _internal_bold() const;
  void _internal_set_bold(bool value);
  public:

  // bool underlined = 9;
  void clear_underlined();
  bool underlined() const;
  void set_underlined(bool value);
  private:
  bool _internal_underlined() const;
  void _internal_set_underlined(bool value);
  public:

  // bool visible = 10;
  void clear_visible();
  bool visible() const;
  void set_visible(bool value);
  private:
  bool _internal_visible() const;
  void _internal_set_visible(bool value);
  public:

  // bool mirrored = 11;
  void clear_mirrored();
  bool mirrored() const;
  void set_mirrored(bool value);
  private:
  bool _internal_mirrored() const;
  void _internal_set_mirrored(bool value);
  public:

  // bool multiline = 12;
  void clear_multiline();
  bool multiline() const;
  void set_multiline(bool value);
  private:
  bool _internal_multiline() const;
  void _internal_set_multiline(bool value);
  public:

  // bool keep_upright = 13;
  void clear_keep_upright();
  bool keep_upright() const;
  void set_keep_upright(bool value);
  private:
  bool _internal_keep_upright() const;
  void _internal_set_keep_upright(bool value);
  public:

  // @@protoc_insertion_point(class_scope:kiapi.common.types.TextAttributes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr font_name_;
  ::kiapi::common::types::Angle* angle_;
  ::kiapi::common::types::Distance* stroke_width_;
  ::kiapi::common::types::Vector2* size_;
  int horizontal_alignment_;
  int vertical_alignment_;
  double line_spacing_;
  bool italic_;
  bool bold_;
  bool underlined_;
  bool visible_;
  bool mirrored_;
  bool multiline_;
  bool keep_upright_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2ftypes_2fbase_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class KIAPI_IMPORTEXPORT Text final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kiapi.common.types.Text) */ {
 public:
  inline Text() : Text(nullptr) {}
  ~Text() override;
  explicit constexpr Text(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Text(const Text& from);
  Text(Text&& from) noexcept
    : Text() {
    *this = ::std::move(from);
  }

  inline Text& operator=(const Text& from) {
    CopyFrom(from);
    return *this;
  }
  inline Text& operator=(Text&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Text& default_instance() {
    return *internal_default_instance();
  }
  static inline const Text* internal_default_instance() {
    return reinterpret_cast<const Text*>(
               &_Text_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(Text& a, Text& b) {
    a.Swap(&b);
  }
  inline void Swap(Text* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Text* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Text* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Text>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Text& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Text& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Text* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kiapi.common.types.Text";
  }
  protected:
  explicit Text(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 5,
    kHyperlinkFieldNumber = 6,
    kPositionFieldNumber = 2,
    kAttributesFieldNumber = 3,
  };
  // string text = 5;
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // string hyperlink = 6;
  void clear_hyperlink();
  const std::string& hyperlink() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hyperlink(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hyperlink();
  PROTOBUF_NODISCARD std::string* release_hyperlink();
  void set_allocated_hyperlink(std::string* hyperlink);
  private:
  const std::string& _internal_hyperlink() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hyperlink(const std::string& value);
  std::string* _internal_mutable_hyperlink();
  public:

  // .kiapi.common.types.Vector2 position = 2;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::kiapi::common::types::Vector2& position() const;
  PROTOBUF_NODISCARD ::kiapi::common::types::Vector2* release_position();
  ::kiapi::common::types::Vector2* mutable_position();
  void set_allocated_position(::kiapi::common::types::Vector2* position);
  private:
  const ::kiapi::common::types::Vector2& _internal_position() const;
  ::kiapi::common::types::Vector2* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::kiapi::common::types::Vector2* position);
  ::kiapi::common::types::Vector2* unsafe_arena_release_position();

  // .kiapi.common.types.TextAttributes attributes = 3;
  bool has_attributes() const;
  private:
  bool _internal_has_attributes() const;
  public:
  void clear_attributes();
  const ::kiapi::common::types::TextAttributes& attributes() const;
  PROTOBUF_NODISCARD ::kiapi::common::types::TextAttributes* release_attributes();
  ::kiapi::common::types::TextAttributes* mutable_attributes();
  void set_allocated_attributes(::kiapi::common::types::TextAttributes* attributes);
  private:
  const ::kiapi::common::types::TextAttributes& _internal_attributes() const;
  ::kiapi::common::types::TextAttributes* _internal_mutable_attributes();
  public:
  void unsafe_arena_set_allocated_attributes(
      ::kiapi::common::types::TextAttributes* attributes);
  ::kiapi::common::types::TextAttributes* unsafe_arena_release_attributes();

  // @@protoc_insertion_point(class_scope:kiapi.common.types.Text)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hyperlink_;
  ::kiapi::common::types::Vector2* position_;
  ::kiapi::common::types::TextAttributes* attributes_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2ftypes_2fbase_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class KIAPI_IMPORTEXPORT TextBox final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kiapi.common.types.TextBox) */ {
 public:
  inline TextBox() : TextBox(nullptr) {}
  ~TextBox() override;
  explicit constexpr TextBox(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TextBox(const TextBox& from);
  TextBox(TextBox&& from) noexcept
    : TextBox() {
    *this = ::std::move(from);
  }

  inline TextBox& operator=(const TextBox& from) {
    CopyFrom(from);
    return *this;
  }
  inline TextBox& operator=(TextBox&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TextBox& default_instance() {
    return *internal_default_instance();
  }
  static inline const TextBox* internal_default_instance() {
    return reinterpret_cast<const TextBox*>(
               &_TextBox_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(TextBox& a, TextBox& b) {
    a.Swap(&b);
  }
  inline void Swap(TextBox* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TextBox* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TextBox* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TextBox>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TextBox& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TextBox& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TextBox* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kiapi.common.types.TextBox";
  }
  protected:
  explicit TextBox(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 6,
    kTopLeftFieldNumber = 2,
    kBottomRightFieldNumber = 3,
    kAttributesFieldNumber = 4,
  };
  // string text = 6;
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // .kiapi.common.types.Vector2 top_left = 2;
  bool has_top_left() const;
  private:
  bool _internal_has_top_left() const;
  public:
  void clear_top_left();
  const ::kiapi::common::types::Vector2& top_left() const;
  PROTOBUF_NODISCARD ::kiapi::common::types::Vector2* release_top_left();
  ::kiapi::common::types::Vector2* mutable_top_left();
  void set_allocated_top_left(::kiapi::common::types::Vector2* top_left);
  private:
  const ::kiapi::common::types::Vector2& _internal_top_left() const;
  ::kiapi::common::types::Vector2* _internal_mutable_top_left();
  public:
  void unsafe_arena_set_allocated_top_left(
      ::kiapi::common::types::Vector2* top_left);
  ::kiapi::common::types::Vector2* unsafe_arena_release_top_left();

  // .kiapi.common.types.Vector2 bottom_right = 3;
  bool has_bottom_right() const;
  private:
  bool _internal_has_bottom_right() const;
  public:
  void clear_bottom_right();
  const ::kiapi::common::types::Vector2& bottom_right() const;
  PROTOBUF_NODISCARD ::kiapi::common::types::Vector2* release_bottom_right();
  ::kiapi::common::types::Vector2* mutable_bottom_right();
  void set_allocated_bottom_right(::kiapi::common::types::Vector2* bottom_right);
  private:
  const ::kiapi::common::types::Vector2& _internal_bottom_right() const;
  ::kiapi::common::types::Vector2* _internal_mutable_bottom_right();
  public:
  void unsafe_arena_set_allocated_bottom_right(
      ::kiapi::common::types::Vector2* bottom_right);
  ::kiapi::common::types::Vector2* unsafe_arena_release_bottom_right();

  // .kiapi.common.types.TextAttributes attributes = 4;
  bool has_attributes() const;
  private:
  bool _internal_has_attributes() const;
  public:
  void clear_attributes();
  const ::kiapi::common::types::TextAttributes& attributes() const;
  PROTOBUF_NODISCARD ::kiapi::common::types::TextAttributes* release_attributes();
  ::kiapi::common::types::TextAttributes* mutable_attributes();
  void set_allocated_attributes(::kiapi::common::types::TextAttributes* attributes);
  private:
  const ::kiapi::common::types::TextAttributes& _internal_attributes() const;
  ::kiapi::common::types::TextAttributes* _internal_mutable_attributes();
  public:
  void unsafe_arena_set_allocated_attributes(
      ::kiapi::common::types::TextAttributes* attributes);
  ::kiapi::common::types::TextAttributes* unsafe_arena_release_attributes();

  // @@protoc_insertion_point(class_scope:kiapi.common.types.TextBox)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
  ::kiapi::common::types::Vector2* top_left_;
  ::kiapi::common::types::Vector2* bottom_right_;
  ::kiapi::common::types::TextAttributes* attributes_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2ftypes_2fbase_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class KIAPI_IMPORTEXPORT StrokeAttributes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kiapi.common.types.StrokeAttributes) */ {
 public:
  inline StrokeAttributes() : StrokeAttributes(nullptr) {}
  ~StrokeAttributes() override;
  explicit constexpr StrokeAttributes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StrokeAttributes(const StrokeAttributes& from);
  StrokeAttributes(StrokeAttributes&& from) noexcept
    : StrokeAttributes() {
    *this = ::std::move(from);
  }

  inline StrokeAttributes& operator=(const StrokeAttributes& from) {
    CopyFrom(from);
    return *this;
  }
  inline StrokeAttributes& operator=(StrokeAttributes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StrokeAttributes& default_instance() {
    return *internal_default_instance();
  }
  static inline const StrokeAttributes* internal_default_instance() {
    return reinterpret_cast<const StrokeAttributes*>(
               &_StrokeAttributes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(StrokeAttributes& a, StrokeAttributes& b) {
    a.Swap(&b);
  }
  inline void Swap(StrokeAttributes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StrokeAttributes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StrokeAttributes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StrokeAttributes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StrokeAttributes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StrokeAttributes& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StrokeAttributes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kiapi.common.types.StrokeAttributes";
  }
  protected:
  explicit StrokeAttributes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWidthFieldNumber = 1,
    kColorFieldNumber = 3,
    kStyleFieldNumber = 2,
  };
  // .kiapi.common.types.Distance width = 1;
  bool has_width() const;
  private:
  bool _internal_has_width() const;
  public:
  void clear_width();
  const ::kiapi::common::types::Distance& width() const;
  PROTOBUF_NODISCARD ::kiapi::common::types::Distance* release_width();
  ::kiapi::common::types::Distance* mutable_width();
  void set_allocated_width(::kiapi::common::types::Distance* width);
  private:
  const ::kiapi::common::types::Distance& _internal_width() const;
  ::kiapi::common::types::Distance* _internal_mutable_width();
  public:
  void unsafe_arena_set_allocated_width(
      ::kiapi::common::types::Distance* width);
  ::kiapi::common::types::Distance* unsafe_arena_release_width();

  // .kiapi.common.types.Color color = 3;
  bool has_color() const;
  private:
  bool _internal_has_color() const;
  public:
  void clear_color();
  const ::kiapi::common::types::Color& color() const;
  PROTOBUF_NODISCARD ::kiapi::common::types::Color* release_color();
  ::kiapi::common::types::Color* mutable_color();
  void set_allocated_color(::kiapi::common::types::Color* color);
  private:
  const ::kiapi::common::types::Color& _internal_color() const;
  ::kiapi::common::types::Color* _internal_mutable_color();
  public:
  void unsafe_arena_set_allocated_color(
      ::kiapi::common::types::Color* color);
  ::kiapi::common::types::Color* unsafe_arena_release_color();

  // .kiapi.common.types.StrokeLineStyle style = 2;
  void clear_style();
  ::kiapi::common::types::StrokeLineStyle style() const;
  void set_style(::kiapi::common::types::StrokeLineStyle value);
  private:
  ::kiapi::common::types::StrokeLineStyle _internal_style() const;
  void _internal_set_style(::kiapi::common::types::StrokeLineStyle value);
  public:

  // @@protoc_insertion_point(class_scope:kiapi.common.types.StrokeAttributes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::kiapi::common::types::Distance* width_;
  ::kiapi::common::types::Color* color_;
  int style_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2ftypes_2fbase_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class KIAPI_IMPORTEXPORT GraphicFillAttributes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kiapi.common.types.GraphicFillAttributes) */ {
 public:
  inline GraphicFillAttributes() : GraphicFillAttributes(nullptr) {}
  ~GraphicFillAttributes() override;
  explicit constexpr GraphicFillAttributes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GraphicFillAttributes(const GraphicFillAttributes& from);
  GraphicFillAttributes(GraphicFillAttributes&& from) noexcept
    : GraphicFillAttributes() {
    *this = ::std::move(from);
  }

  inline GraphicFillAttributes& operator=(const GraphicFillAttributes& from) {
    CopyFrom(from);
    return *this;
  }
  inline GraphicFillAttributes& operator=(GraphicFillAttributes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GraphicFillAttributes& default_instance() {
    return *internal_default_instance();
  }
  static inline const GraphicFillAttributes* internal_default_instance() {
    return reinterpret_cast<const GraphicFillAttributes*>(
               &_GraphicFillAttributes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(GraphicFillAttributes& a, GraphicFillAttributes& b) {
    a.Swap(&b);
  }
  inline void Swap(GraphicFillAttributes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GraphicFillAttributes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GraphicFillAttributes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GraphicFillAttributes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GraphicFillAttributes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GraphicFillAttributes& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GraphicFillAttributes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kiapi.common.types.GraphicFillAttributes";
  }
  protected:
  explicit GraphicFillAttributes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColorFieldNumber = 2,
    kFillTypeFieldNumber = 1,
  };
  // .kiapi.common.types.Color color = 2;
  bool has_color() const;
  private:
  bool _internal_has_color() const;
  public:
  void clear_color();
  const ::kiapi::common::types::Color& color() const;
  PROTOBUF_NODISCARD ::kiapi::common::types::Color* release_color();
  ::kiapi::common::types::Color* mutable_color();
  void set_allocated_color(::kiapi::common::types::Color* color);
  private:
  const ::kiapi::common::types::Color& _internal_color() const;
  ::kiapi::common::types::Color* _internal_mutable_color();
  public:
  void unsafe_arena_set_allocated_color(
      ::kiapi::common::types::Color* color);
  ::kiapi::common::types::Color* unsafe_arena_release_color();

  // .kiapi.common.types.GraphicFillType fill_type = 1;
  void clear_fill_type();
  ::kiapi::common::types::GraphicFillType fill_type() const;
  void set_fill_type(::kiapi::common::types::GraphicFillType value);
  private:
  ::kiapi::common::types::GraphicFillType _internal_fill_type() const;
  void _internal_set_fill_type(::kiapi::common::types::GraphicFillType value);
  public:

  // @@protoc_insertion_point(class_scope:kiapi.common.types.GraphicFillAttributes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::kiapi::common::types::Color* color_;
  int fill_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2ftypes_2fbase_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class KIAPI_IMPORTEXPORT GraphicAttributes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kiapi.common.types.GraphicAttributes) */ {
 public:
  inline GraphicAttributes() : GraphicAttributes(nullptr) {}
  ~GraphicAttributes() override;
  explicit constexpr GraphicAttributes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GraphicAttributes(const GraphicAttributes& from);
  GraphicAttributes(GraphicAttributes&& from) noexcept
    : GraphicAttributes() {
    *this = ::std::move(from);
  }

  inline GraphicAttributes& operator=(const GraphicAttributes& from) {
    CopyFrom(from);
    return *this;
  }
  inline GraphicAttributes& operator=(GraphicAttributes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GraphicAttributes& default_instance() {
    return *internal_default_instance();
  }
  static inline const GraphicAttributes* internal_default_instance() {
    return reinterpret_cast<const GraphicAttributes*>(
               &_GraphicAttributes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(GraphicAttributes& a, GraphicAttributes& b) {
    a.Swap(&b);
  }
  inline void Swap(GraphicAttributes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GraphicAttributes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GraphicAttributes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GraphicAttributes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GraphicAttributes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GraphicAttributes& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GraphicAttributes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kiapi.common.types.GraphicAttributes";
  }
  protected:
  explicit GraphicAttributes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStrokeFieldNumber = 1,
    kFillFieldNumber = 2,
  };
  // .kiapi.common.types.StrokeAttributes stroke = 1;
  bool has_stroke() const;
  private:
  bool _internal_has_stroke() const;
  public:
  void clear_stroke();
  const ::kiapi::common::types::StrokeAttributes& stroke() const;
  PROTOBUF_NODISCARD ::kiapi::common::types::StrokeAttributes* release_stroke();
  ::kiapi::common::types::StrokeAttributes* mutable_stroke();
  void set_allocated_stroke(::kiapi::common::types::StrokeAttributes* stroke);
  private:
  const ::kiapi::common::types::StrokeAttributes& _internal_stroke() const;
  ::kiapi::common::types::StrokeAttributes* _internal_mutable_stroke();
  public:
  void unsafe_arena_set_allocated_stroke(
      ::kiapi::common::types::StrokeAttributes* stroke);
  ::kiapi::common::types::StrokeAttributes* unsafe_arena_release_stroke();

  // .kiapi.common.types.GraphicFillAttributes fill = 2;
  bool has_fill() const;
  private:
  bool _internal_has_fill() const;
  public:
  void clear_fill();
  const ::kiapi::common::types::GraphicFillAttributes& fill() const;
  PROTOBUF_NODISCARD ::kiapi::common::types::GraphicFillAttributes* release_fill();
  ::kiapi::common::types::GraphicFillAttributes* mutable_fill();
  void set_allocated_fill(::kiapi::common::types::GraphicFillAttributes* fill);
  private:
  const ::kiapi::common::types::GraphicFillAttributes& _internal_fill() const;
  ::kiapi::common::types::GraphicFillAttributes* _internal_mutable_fill();
  public:
  void unsafe_arena_set_allocated_fill(
      ::kiapi::common::types::GraphicFillAttributes* fill);
  ::kiapi::common::types::GraphicFillAttributes* unsafe_arena_release_fill();

  // @@protoc_insertion_point(class_scope:kiapi.common.types.GraphicAttributes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::kiapi::common::types::StrokeAttributes* stroke_;
  ::kiapi::common::types::GraphicFillAttributes* fill_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2ftypes_2fbase_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class KIAPI_IMPORTEXPORT GraphicSegmentAttributes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kiapi.common.types.GraphicSegmentAttributes) */ {
 public:
  inline GraphicSegmentAttributes() : GraphicSegmentAttributes(nullptr) {}
  ~GraphicSegmentAttributes() override;
  explicit constexpr GraphicSegmentAttributes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GraphicSegmentAttributes(const GraphicSegmentAttributes& from);
  GraphicSegmentAttributes(GraphicSegmentAttributes&& from) noexcept
    : GraphicSegmentAttributes() {
    *this = ::std::move(from);
  }

  inline GraphicSegmentAttributes& operator=(const GraphicSegmentAttributes& from) {
    CopyFrom(from);
    return *this;
  }
  inline GraphicSegmentAttributes& operator=(GraphicSegmentAttributes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GraphicSegmentAttributes& default_instance() {
    return *internal_default_instance();
  }
  static inline const GraphicSegmentAttributes* internal_default_instance() {
    return reinterpret_cast<const GraphicSegmentAttributes*>(
               &_GraphicSegmentAttributes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(GraphicSegmentAttributes& a, GraphicSegmentAttributes& b) {
    a.Swap(&b);
  }
  inline void Swap(GraphicSegmentAttributes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GraphicSegmentAttributes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GraphicSegmentAttributes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GraphicSegmentAttributes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GraphicSegmentAttributes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GraphicSegmentAttributes& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GraphicSegmentAttributes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kiapi.common.types.GraphicSegmentAttributes";
  }
  protected:
  explicit GraphicSegmentAttributes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartFieldNumber = 1,
    kEndFieldNumber = 2,
  };
  // .kiapi.common.types.Vector2 start = 1;
  bool has_start() const;
  private:
  bool _internal_has_start() const;
  public:
  void clear_start();
  const ::kiapi::common::types::Vector2& start() const;
  PROTOBUF_NODISCARD ::kiapi::common::types::Vector2* release_start();
  ::kiapi::common::types::Vector2* mutable_start();
  void set_allocated_start(::kiapi::common::types::Vector2* start);
  private:
  const ::kiapi::common::types::Vector2& _internal_start() const;
  ::kiapi::common::types::Vector2* _internal_mutable_start();
  public:
  void unsafe_arena_set_allocated_start(
      ::kiapi::common::types::Vector2* start);
  ::kiapi::common::types::Vector2* unsafe_arena_release_start();

  // .kiapi.common.types.Vector2 end = 2;
  bool has_end() const;
  private:
  bool _internal_has_end() const;
  public:
  void clear_end();
  const ::kiapi::common::types::Vector2& end() const;
  PROTOBUF_NODISCARD ::kiapi::common::types::Vector2* release_end();
  ::kiapi::common::types::Vector2* mutable_end();
  void set_allocated_end(::kiapi::common::types::Vector2* end);
  private:
  const ::kiapi::common::types::Vector2& _internal_end() const;
  ::kiapi::common::types::Vector2* _internal_mutable_end();
  public:
  void unsafe_arena_set_allocated_end(
      ::kiapi::common::types::Vector2* end);
  ::kiapi::common::types::Vector2* unsafe_arena_release_end();

  // @@protoc_insertion_point(class_scope:kiapi.common.types.GraphicSegmentAttributes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::kiapi::common::types::Vector2* start_;
  ::kiapi::common::types::Vector2* end_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2ftypes_2fbase_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class KIAPI_IMPORTEXPORT GraphicRectangleAttributes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kiapi.common.types.GraphicRectangleAttributes) */ {
 public:
  inline GraphicRectangleAttributes() : GraphicRectangleAttributes(nullptr) {}
  ~GraphicRectangleAttributes() override;
  explicit constexpr GraphicRectangleAttributes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GraphicRectangleAttributes(const GraphicRectangleAttributes& from);
  GraphicRectangleAttributes(GraphicRectangleAttributes&& from) noexcept
    : GraphicRectangleAttributes() {
    *this = ::std::move(from);
  }

  inline GraphicRectangleAttributes& operator=(const GraphicRectangleAttributes& from) {
    CopyFrom(from);
    return *this;
  }
  inline GraphicRectangleAttributes& operator=(GraphicRectangleAttributes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GraphicRectangleAttributes& default_instance() {
    return *internal_default_instance();
  }
  static inline const GraphicRectangleAttributes* internal_default_instance() {
    return reinterpret_cast<const GraphicRectangleAttributes*>(
               &_GraphicRectangleAttributes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(GraphicRectangleAttributes& a, GraphicRectangleAttributes& b) {
    a.Swap(&b);
  }
  inline void Swap(GraphicRectangleAttributes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GraphicRectangleAttributes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GraphicRectangleAttributes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GraphicRectangleAttributes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GraphicRectangleAttributes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GraphicRectangleAttributes& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GraphicRectangleAttributes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kiapi.common.types.GraphicRectangleAttributes";
  }
  protected:
  explicit GraphicRectangleAttributes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTopLeftFieldNumber = 1,
    kBottomRightFieldNumber = 2,
  };
  // .kiapi.common.types.Vector2 top_left = 1;
  bool has_top_left() const;
  private:
  bool _internal_has_top_left() const;
  public:
  void clear_top_left();
  const ::kiapi::common::types::Vector2& top_left() const;
  PROTOBUF_NODISCARD ::kiapi::common::types::Vector2* release_top_left();
  ::kiapi::common::types::Vector2* mutable_top_left();
  void set_allocated_top_left(::kiapi::common::types::Vector2* top_left);
  private:
  const ::kiapi::common::types::Vector2& _internal_top_left() const;
  ::kiapi::common::types::Vector2* _internal_mutable_top_left();
  public:
  void unsafe_arena_set_allocated_top_left(
      ::kiapi::common::types::Vector2* top_left);
  ::kiapi::common::types::Vector2* unsafe_arena_release_top_left();

  // .kiapi.common.types.Vector2 bottom_right = 2;
  bool has_bottom_right() const;
  private:
  bool _internal_has_bottom_right() const;
  public:
  void clear_bottom_right();
  const ::kiapi::common::types::Vector2& bottom_right() const;
  PROTOBUF_NODISCARD ::kiapi::common::types::Vector2* release_bottom_right();
  ::kiapi::common::types::Vector2* mutable_bottom_right();
  void set_allocated_bottom_right(::kiapi::common::types::Vector2* bottom_right);
  private:
  const ::kiapi::common::types::Vector2& _internal_bottom_right() const;
  ::kiapi::common::types::Vector2* _internal_mutable_bottom_right();
  public:
  void unsafe_arena_set_allocated_bottom_right(
      ::kiapi::common::types::Vector2* bottom_right);
  ::kiapi::common::types::Vector2* unsafe_arena_release_bottom_right();

  // @@protoc_insertion_point(class_scope:kiapi.common.types.GraphicRectangleAttributes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::kiapi::common::types::Vector2* top_left_;
  ::kiapi::common::types::Vector2* bottom_right_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2ftypes_2fbase_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class KIAPI_IMPORTEXPORT GraphicArcAttributes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kiapi.common.types.GraphicArcAttributes) */ {
 public:
  inline GraphicArcAttributes() : GraphicArcAttributes(nullptr) {}
  ~GraphicArcAttributes() override;
  explicit constexpr GraphicArcAttributes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GraphicArcAttributes(const GraphicArcAttributes& from);
  GraphicArcAttributes(GraphicArcAttributes&& from) noexcept
    : GraphicArcAttributes() {
    *this = ::std::move(from);
  }

  inline GraphicArcAttributes& operator=(const GraphicArcAttributes& from) {
    CopyFrom(from);
    return *this;
  }
  inline GraphicArcAttributes& operator=(GraphicArcAttributes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GraphicArcAttributes& default_instance() {
    return *internal_default_instance();
  }
  static inline const GraphicArcAttributes* internal_default_instance() {
    return reinterpret_cast<const GraphicArcAttributes*>(
               &_GraphicArcAttributes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(GraphicArcAttributes& a, GraphicArcAttributes& b) {
    a.Swap(&b);
  }
  inline void Swap(GraphicArcAttributes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GraphicArcAttributes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GraphicArcAttributes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GraphicArcAttributes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GraphicArcAttributes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GraphicArcAttributes& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GraphicArcAttributes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kiapi.common.types.GraphicArcAttributes";
  }
  protected:
  explicit GraphicArcAttributes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartFieldNumber = 1,
    kMidFieldNumber = 2,
    kEndFieldNumber = 3,
  };
  // .kiapi.common.types.Vector2 start = 1;
  bool has_start() const;
  private:
  bool _internal_has_start() const;
  public:
  void clear_start();
  const ::kiapi::common::types::Vector2& start() const;
  PROTOBUF_NODISCARD ::kiapi::common::types::Vector2* release_start();
  ::kiapi::common::types::Vector2* mutable_start();
  void set_allocated_start(::kiapi::common::types::Vector2* start);
  private:
  const ::kiapi::common::types::Vector2& _internal_start() const;
  ::kiapi::common::types::Vector2* _internal_mutable_start();
  public:
  void unsafe_arena_set_allocated_start(
      ::kiapi::common::types::Vector2* start);
  ::kiapi::common::types::Vector2* unsafe_arena_release_start();

  // .kiapi.common.types.Vector2 mid = 2;
  bool has_mid() const;
  private:
  bool _internal_has_mid() const;
  public:
  void clear_mid();
  const ::kiapi::common::types::Vector2& mid() const;
  PROTOBUF_NODISCARD ::kiapi::common::types::Vector2* release_mid();
  ::kiapi::common::types::Vector2* mutable_mid();
  void set_allocated_mid(::kiapi::common::types::Vector2* mid);
  private:
  const ::kiapi::common::types::Vector2& _internal_mid() const;
  ::kiapi::common::types::Vector2* _internal_mutable_mid();
  public:
  void unsafe_arena_set_allocated_mid(
      ::kiapi::common::types::Vector2* mid);
  ::kiapi::common::types::Vector2* unsafe_arena_release_mid();

  // .kiapi.common.types.Vector2 end = 3;
  bool has_end() const;
  private:
  bool _internal_has_end() const;
  public:
  void clear_end();
  const ::kiapi::common::types::Vector2& end() const;
  PROTOBUF_NODISCARD ::kiapi::common::types::Vector2* release_end();
  ::kiapi::common::types::Vector2* mutable_end();
  void set_allocated_end(::kiapi::common::types::Vector2* end);
  private:
  const ::kiapi::common::types::Vector2& _internal_end() const;
  ::kiapi::common::types::Vector2* _internal_mutable_end();
  public:
  void unsafe_arena_set_allocated_end(
      ::kiapi::common::types::Vector2* end);
  ::kiapi::common::types::Vector2* unsafe_arena_release_end();

  // @@protoc_insertion_point(class_scope:kiapi.common.types.GraphicArcAttributes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::kiapi::common::types::Vector2* start_;
  ::kiapi::common::types::Vector2* mid_;
  ::kiapi::common::types::Vector2* end_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2ftypes_2fbase_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class KIAPI_IMPORTEXPORT GraphicCircleAttributes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kiapi.common.types.GraphicCircleAttributes) */ {
 public:
  inline GraphicCircleAttributes() : GraphicCircleAttributes(nullptr) {}
  ~GraphicCircleAttributes() override;
  explicit constexpr GraphicCircleAttributes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GraphicCircleAttributes(const GraphicCircleAttributes& from);
  GraphicCircleAttributes(GraphicCircleAttributes&& from) noexcept
    : GraphicCircleAttributes() {
    *this = ::std::move(from);
  }

  inline GraphicCircleAttributes& operator=(const GraphicCircleAttributes& from) {
    CopyFrom(from);
    return *this;
  }
  inline GraphicCircleAttributes& operator=(GraphicCircleAttributes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GraphicCircleAttributes& default_instance() {
    return *internal_default_instance();
  }
  static inline const GraphicCircleAttributes* internal_default_instance() {
    return reinterpret_cast<const GraphicCircleAttributes*>(
               &_GraphicCircleAttributes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(GraphicCircleAttributes& a, GraphicCircleAttributes& b) {
    a.Swap(&b);
  }
  inline void Swap(GraphicCircleAttributes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GraphicCircleAttributes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GraphicCircleAttributes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GraphicCircleAttributes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GraphicCircleAttributes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GraphicCircleAttributes& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GraphicCircleAttributes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kiapi.common.types.GraphicCircleAttributes";
  }
  protected:
  explicit GraphicCircleAttributes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCenterFieldNumber = 1,
    kRadiusPointFieldNumber = 2,
  };
  // .kiapi.common.types.Vector2 center = 1;
  bool has_center() const;
  private:
  bool _internal_has_center() const;
  public:
  void clear_center();
  const ::kiapi::common::types::Vector2& center() const;
  PROTOBUF_NODISCARD ::kiapi::common::types::Vector2* release_center();
  ::kiapi::common::types::Vector2* mutable_center();
  void set_allocated_center(::kiapi::common::types::Vector2* center);
  private:
  const ::kiapi::common::types::Vector2& _internal_center() const;
  ::kiapi::common::types::Vector2* _internal_mutable_center();
  public:
  void unsafe_arena_set_allocated_center(
      ::kiapi::common::types::Vector2* center);
  ::kiapi::common::types::Vector2* unsafe_arena_release_center();

  // .kiapi.common.types.Vector2 radius_point = 2;
  bool has_radius_point() const;
  private:
  bool _internal_has_radius_point() const;
  public:
  void clear_radius_point();
  const ::kiapi::common::types::Vector2& radius_point() const;
  PROTOBUF_NODISCARD ::kiapi::common::types::Vector2* release_radius_point();
  ::kiapi::common::types::Vector2* mutable_radius_point();
  void set_allocated_radius_point(::kiapi::common::types::Vector2* radius_point);
  private:
  const ::kiapi::common::types::Vector2& _internal_radius_point() const;
  ::kiapi::common::types::Vector2* _internal_mutable_radius_point();
  public:
  void unsafe_arena_set_allocated_radius_point(
      ::kiapi::common::types::Vector2* radius_point);
  ::kiapi::common::types::Vector2* unsafe_arena_release_radius_point();

  // @@protoc_insertion_point(class_scope:kiapi.common.types.GraphicCircleAttributes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::kiapi::common::types::Vector2* center_;
  ::kiapi::common::types::Vector2* radius_point_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2ftypes_2fbase_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class KIAPI_IMPORTEXPORT GraphicBezierAttributes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kiapi.common.types.GraphicBezierAttributes) */ {
 public:
  inline GraphicBezierAttributes() : GraphicBezierAttributes(nullptr) {}
  ~GraphicBezierAttributes() override;
  explicit constexpr GraphicBezierAttributes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GraphicBezierAttributes(const GraphicBezierAttributes& from);
  GraphicBezierAttributes(GraphicBezierAttributes&& from) noexcept
    : GraphicBezierAttributes() {
    *this = ::std::move(from);
  }

  inline GraphicBezierAttributes& operator=(const GraphicBezierAttributes& from) {
    CopyFrom(from);
    return *this;
  }
  inline GraphicBezierAttributes& operator=(GraphicBezierAttributes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GraphicBezierAttributes& default_instance() {
    return *internal_default_instance();
  }
  static inline const GraphicBezierAttributes* internal_default_instance() {
    return reinterpret_cast<const GraphicBezierAttributes*>(
               &_GraphicBezierAttributes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(GraphicBezierAttributes& a, GraphicBezierAttributes& b) {
    a.Swap(&b);
  }
  inline void Swap(GraphicBezierAttributes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GraphicBezierAttributes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GraphicBezierAttributes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GraphicBezierAttributes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GraphicBezierAttributes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GraphicBezierAttributes& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GraphicBezierAttributes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kiapi.common.types.GraphicBezierAttributes";
  }
  protected:
  explicit GraphicBezierAttributes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartFieldNumber = 1,
    kControl1FieldNumber = 2,
    kControl2FieldNumber = 3,
    kEndFieldNumber = 4,
  };
  // .kiapi.common.types.Vector2 start = 1;
  bool has_start() const;
  private:
  bool _internal_has_start() const;
  public:
  void clear_start();
  const ::kiapi::common::types::Vector2& start() const;
  PROTOBUF_NODISCARD ::kiapi::common::types::Vector2* release_start();
  ::kiapi::common::types::Vector2* mutable_start();
  void set_allocated_start(::kiapi::common::types::Vector2* start);
  private:
  const ::kiapi::common::types::Vector2& _internal_start() const;
  ::kiapi::common::types::Vector2* _internal_mutable_start();
  public:
  void unsafe_arena_set_allocated_start(
      ::kiapi::common::types::Vector2* start);
  ::kiapi::common::types::Vector2* unsafe_arena_release_start();

  // .kiapi.common.types.Vector2 control1 = 2;
  bool has_control1() const;
  private:
  bool _internal_has_control1() const;
  public:
  void clear_control1();
  const ::kiapi::common::types::Vector2& control1() const;
  PROTOBUF_NODISCARD ::kiapi::common::types::Vector2* release_control1();
  ::kiapi::common::types::Vector2* mutable_control1();
  void set_allocated_control1(::kiapi::common::types::Vector2* control1);
  private:
  const ::kiapi::common::types::Vector2& _internal_control1() const;
  ::kiapi::common::types::Vector2* _internal_mutable_control1();
  public:
  void unsafe_arena_set_allocated_control1(
      ::kiapi::common::types::Vector2* control1);
  ::kiapi::common::types::Vector2* unsafe_arena_release_control1();

  // .kiapi.common.types.Vector2 control2 = 3;
  bool has_control2() const;
  private:
  bool _internal_has_control2() const;
  public:
  void clear_control2();
  const ::kiapi::common::types::Vector2& control2() const;
  PROTOBUF_NODISCARD ::kiapi::common::types::Vector2* release_control2();
  ::kiapi::common::types::Vector2* mutable_control2();
  void set_allocated_control2(::kiapi::common::types::Vector2* control2);
  private:
  const ::kiapi::common::types::Vector2& _internal_control2() const;
  ::kiapi::common::types::Vector2* _internal_mutable_control2();
  public:
  void unsafe_arena_set_allocated_control2(
      ::kiapi::common::types::Vector2* control2);
  ::kiapi::common::types::Vector2* unsafe_arena_release_control2();

  // .kiapi.common.types.Vector2 end = 4;
  bool has_end() const;
  private:
  bool _internal_has_end() const;
  public:
  void clear_end();
  const ::kiapi::common::types::Vector2& end() const;
  PROTOBUF_NODISCARD ::kiapi::common::types::Vector2* release_end();
  ::kiapi::common::types::Vector2* mutable_end();
  void set_allocated_end(::kiapi::common::types::Vector2* end);
  private:
  const ::kiapi::common::types::Vector2& _internal_end() const;
  ::kiapi::common::types::Vector2* _internal_mutable_end();
  public:
  void unsafe_arena_set_allocated_end(
      ::kiapi::common::types::Vector2* end);
  ::kiapi::common::types::Vector2* unsafe_arena_release_end();

  // @@protoc_insertion_point(class_scope:kiapi.common.types.GraphicBezierAttributes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::kiapi::common::types::Vector2* start_;
  ::kiapi::common::types::Vector2* control1_;
  ::kiapi::common::types::Vector2* control2_;
  ::kiapi::common::types::Vector2* end_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2ftypes_2fbase_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class KIAPI_IMPORTEXPORT GraphicShape final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kiapi.common.types.GraphicShape) */ {
 public:
  inline GraphicShape() : GraphicShape(nullptr) {}
  ~GraphicShape() override;
  explicit constexpr GraphicShape(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GraphicShape(const GraphicShape& from);
  GraphicShape(GraphicShape&& from) noexcept
    : GraphicShape() {
    *this = ::std::move(from);
  }

  inline GraphicShape& operator=(const GraphicShape& from) {
    CopyFrom(from);
    return *this;
  }
  inline GraphicShape& operator=(GraphicShape&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GraphicShape& default_instance() {
    return *internal_default_instance();
  }
  enum GeometryCase {
    kSegment = 4,
    kRectangle = 5,
    kArc = 6,
    kCircle = 7,
    kPolygon = 8,
    kBezier = 9,
    GEOMETRY_NOT_SET = 0,
  };

  static inline const GraphicShape* internal_default_instance() {
    return reinterpret_cast<const GraphicShape*>(
               &_GraphicShape_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(GraphicShape& a, GraphicShape& b) {
    a.Swap(&b);
  }
  inline void Swap(GraphicShape* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GraphicShape* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GraphicShape* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GraphicShape>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GraphicShape& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GraphicShape& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GraphicShape* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kiapi.common.types.GraphicShape";
  }
  protected:
  explicit GraphicShape(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttributesFieldNumber = 3,
    kSegmentFieldNumber = 4,
    kRectangleFieldNumber = 5,
    kArcFieldNumber = 6,
    kCircleFieldNumber = 7,
    kPolygonFieldNumber = 8,
    kBezierFieldNumber = 9,
  };
  // .kiapi.common.types.GraphicAttributes attributes = 3;
  bool has_attributes() const;
  private:
  bool _internal_has_attributes() const;
  public:
  void clear_attributes();
  const ::kiapi::common::types::GraphicAttributes& attributes() const;
  PROTOBUF_NODISCARD ::kiapi::common::types::GraphicAttributes* release_attributes();
  ::kiapi::common::types::GraphicAttributes* mutable_attributes();
  void set_allocated_attributes(::kiapi::common::types::GraphicAttributes* attributes);
  private:
  const ::kiapi::common::types::GraphicAttributes& _internal_attributes() const;
  ::kiapi::common::types::GraphicAttributes* _internal_mutable_attributes();
  public:
  void unsafe_arena_set_allocated_attributes(
      ::kiapi::common::types::GraphicAttributes* attributes);
  ::kiapi::common::types::GraphicAttributes* unsafe_arena_release_attributes();

  // .kiapi.common.types.GraphicSegmentAttributes segment = 4;
  bool has_segment() const;
  private:
  bool _internal_has_segment() const;
  public:
  void clear_segment();
  const ::kiapi::common::types::GraphicSegmentAttributes& segment() const;
  PROTOBUF_NODISCARD ::kiapi::common::types::GraphicSegmentAttributes* release_segment();
  ::kiapi::common::types::GraphicSegmentAttributes* mutable_segment();
  void set_allocated_segment(::kiapi::common::types::GraphicSegmentAttributes* segment);
  private:
  const ::kiapi::common::types::GraphicSegmentAttributes& _internal_segment() const;
  ::kiapi::common::types::GraphicSegmentAttributes* _internal_mutable_segment();
  public:
  void unsafe_arena_set_allocated_segment(
      ::kiapi::common::types::GraphicSegmentAttributes* segment);
  ::kiapi::common::types::GraphicSegmentAttributes* unsafe_arena_release_segment();

  // .kiapi.common.types.GraphicRectangleAttributes rectangle = 5;
  bool has_rectangle() const;
  private:
  bool _internal_has_rectangle() const;
  public:
  void clear_rectangle();
  const ::kiapi::common::types::GraphicRectangleAttributes& rectangle() const;
  PROTOBUF_NODISCARD ::kiapi::common::types::GraphicRectangleAttributes* release_rectangle();
  ::kiapi::common::types::GraphicRectangleAttributes* mutable_rectangle();
  void set_allocated_rectangle(::kiapi::common::types::GraphicRectangleAttributes* rectangle);
  private:
  const ::kiapi::common::types::GraphicRectangleAttributes& _internal_rectangle() const;
  ::kiapi::common::types::GraphicRectangleAttributes* _internal_mutable_rectangle();
  public:
  void unsafe_arena_set_allocated_rectangle(
      ::kiapi::common::types::GraphicRectangleAttributes* rectangle);
  ::kiapi::common::types::GraphicRectangleAttributes* unsafe_arena_release_rectangle();

  // .kiapi.common.types.GraphicArcAttributes arc = 6;
  bool has_arc() const;
  private:
  bool _internal_has_arc() const;
  public:
  void clear_arc();
  const ::kiapi::common::types::GraphicArcAttributes& arc() const;
  PROTOBUF_NODISCARD ::kiapi::common::types::GraphicArcAttributes* release_arc();
  ::kiapi::common::types::GraphicArcAttributes* mutable_arc();
  void set_allocated_arc(::kiapi::common::types::GraphicArcAttributes* arc);
  private:
  const ::kiapi::common::types::GraphicArcAttributes& _internal_arc() const;
  ::kiapi::common::types::GraphicArcAttributes* _internal_mutable_arc();
  public:
  void unsafe_arena_set_allocated_arc(
      ::kiapi::common::types::GraphicArcAttributes* arc);
  ::kiapi::common::types::GraphicArcAttributes* unsafe_arena_release_arc();

  // .kiapi.common.types.GraphicCircleAttributes circle = 7;
  bool has_circle() const;
  private:
  bool _internal_has_circle() const;
  public:
  void clear_circle();
  const ::kiapi::common::types::GraphicCircleAttributes& circle() const;
  PROTOBUF_NODISCARD ::kiapi::common::types::GraphicCircleAttributes* release_circle();
  ::kiapi::common::types::GraphicCircleAttributes* mutable_circle();
  void set_allocated_circle(::kiapi::common::types::GraphicCircleAttributes* circle);
  private:
  const ::kiapi::common::types::GraphicCircleAttributes& _internal_circle() const;
  ::kiapi::common::types::GraphicCircleAttributes* _internal_mutable_circle();
  public:
  void unsafe_arena_set_allocated_circle(
      ::kiapi::common::types::GraphicCircleAttributes* circle);
  ::kiapi::common::types::GraphicCircleAttributes* unsafe_arena_release_circle();

  // .kiapi.common.types.PolySet polygon = 8;
  bool has_polygon() const;
  private:
  bool _internal_has_polygon() const;
  public:
  void clear_polygon();
  const ::kiapi::common::types::PolySet& polygon() const;
  PROTOBUF_NODISCARD ::kiapi::common::types::PolySet* release_polygon();
  ::kiapi::common::types::PolySet* mutable_polygon();
  void set_allocated_polygon(::kiapi::common::types::PolySet* polygon);
  private:
  const ::kiapi::common::types::PolySet& _internal_polygon() const;
  ::kiapi::common::types::PolySet* _internal_mutable_polygon();
  public:
  void unsafe_arena_set_allocated_polygon(
      ::kiapi::common::types::PolySet* polygon);
  ::kiapi::common::types::PolySet* unsafe_arena_release_polygon();

  // .kiapi.common.types.GraphicBezierAttributes bezier = 9;
  bool has_bezier() const;
  private:
  bool _internal_has_bezier() const;
  public:
  void clear_bezier();
  const ::kiapi::common::types::GraphicBezierAttributes& bezier() const;
  PROTOBUF_NODISCARD ::kiapi::common::types::GraphicBezierAttributes* release_bezier();
  ::kiapi::common::types::GraphicBezierAttributes* mutable_bezier();
  void set_allocated_bezier(::kiapi::common::types::GraphicBezierAttributes* bezier);
  private:
  const ::kiapi::common::types::GraphicBezierAttributes& _internal_bezier() const;
  ::kiapi::common::types::GraphicBezierAttributes* _internal_mutable_bezier();
  public:
  void unsafe_arena_set_allocated_bezier(
      ::kiapi::common::types::GraphicBezierAttributes* bezier);
  ::kiapi::common::types::GraphicBezierAttributes* unsafe_arena_release_bezier();

  void clear_geometry();
  GeometryCase geometry_case() const;
  // @@protoc_insertion_point(class_scope:kiapi.common.types.GraphicShape)
 private:
  class _Internal;
  void set_has_segment();
  void set_has_rectangle();
  void set_has_arc();
  void set_has_circle();
  void set_has_polygon();
  void set_has_bezier();

  inline bool has_geometry() const;
  inline void clear_has_geometry();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::kiapi::common::types::GraphicAttributes* attributes_;
  union GeometryUnion {
    constexpr GeometryUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::kiapi::common::types::GraphicSegmentAttributes* segment_;
    ::kiapi::common::types::GraphicRectangleAttributes* rectangle_;
    ::kiapi::common::types::GraphicArcAttributes* arc_;
    ::kiapi::common::types::GraphicCircleAttributes* circle_;
    ::kiapi::common::types::PolySet* polygon_;
    ::kiapi::common::types::GraphicBezierAttributes* bezier_;
  } geometry_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_common_2ftypes_2fbase_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class KIAPI_IMPORTEXPORT CompoundShape final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kiapi.common.types.CompoundShape) */ {
 public:
  inline CompoundShape() : CompoundShape(nullptr) {}
  ~CompoundShape() override;
  explicit constexpr CompoundShape(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CompoundShape(const CompoundShape& from);
  CompoundShape(CompoundShape&& from) noexcept
    : CompoundShape() {
    *this = ::std::move(from);
  }

  inline CompoundShape& operator=(const CompoundShape& from) {
    CopyFrom(from);
    return *this;
  }
  inline CompoundShape& operator=(CompoundShape&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CompoundShape& default_instance() {
    return *internal_default_instance();
  }
  static inline const CompoundShape* internal_default_instance() {
    return reinterpret_cast<const CompoundShape*>(
               &_CompoundShape_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(CompoundShape& a, CompoundShape& b) {
    a.Swap(&b);
  }
  inline void Swap(CompoundShape* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CompoundShape* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CompoundShape* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CompoundShape>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CompoundShape& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CompoundShape& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CompoundShape* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kiapi.common.types.CompoundShape";
  }
  protected:
  explicit CompoundShape(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShapesFieldNumber = 1,
  };
  // repeated .kiapi.common.types.GraphicShape shapes = 1;
  int shapes_size() const;
  private:
  int _internal_shapes_size() const;
  public:
  void clear_shapes();
  ::kiapi::common::types::GraphicShape* mutable_shapes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::types::GraphicShape >*
      mutable_shapes();
  private:
  const ::kiapi::common::types::GraphicShape& _internal_shapes(int index) const;
  ::kiapi::common::types::GraphicShape* _internal_add_shapes();
  public:
  const ::kiapi::common::types::GraphicShape& shapes(int index) const;
  ::kiapi::common::types::GraphicShape* add_shapes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::types::GraphicShape >&
      shapes() const;

  // @@protoc_insertion_point(class_scope:kiapi.common.types.CompoundShape)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::types::GraphicShape > shapes_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2ftypes_2fbase_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class KIAPI_IMPORTEXPORT TitleBlockInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kiapi.common.types.TitleBlockInfo) */ {
 public:
  inline TitleBlockInfo() : TitleBlockInfo(nullptr) {}
  ~TitleBlockInfo() override;
  explicit constexpr TitleBlockInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TitleBlockInfo(const TitleBlockInfo& from);
  TitleBlockInfo(TitleBlockInfo&& from) noexcept
    : TitleBlockInfo() {
    *this = ::std::move(from);
  }

  inline TitleBlockInfo& operator=(const TitleBlockInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline TitleBlockInfo& operator=(TitleBlockInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TitleBlockInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const TitleBlockInfo* internal_default_instance() {
    return reinterpret_cast<const TitleBlockInfo*>(
               &_TitleBlockInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(TitleBlockInfo& a, TitleBlockInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(TitleBlockInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TitleBlockInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TitleBlockInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TitleBlockInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TitleBlockInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TitleBlockInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TitleBlockInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kiapi.common.types.TitleBlockInfo";
  }
  protected:
  explicit TitleBlockInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTitleFieldNumber = 1,
    kDateFieldNumber = 2,
    kRevisionFieldNumber = 3,
    kCompanyFieldNumber = 4,
    kComment1FieldNumber = 5,
    kComment2FieldNumber = 6,
    kComment3FieldNumber = 7,
    kComment4FieldNumber = 8,
    kComment5FieldNumber = 9,
    kComment6FieldNumber = 10,
    kComment7FieldNumber = 11,
    kComment8FieldNumber = 12,
    kComment9FieldNumber = 13,
  };
  // string title = 1;
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // string date = 2;
  void clear_date();
  const std::string& date() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_date(ArgT0&& arg0, ArgT... args);
  std::string* mutable_date();
  PROTOBUF_NODISCARD std::string* release_date();
  void set_allocated_date(std::string* date);
  private:
  const std::string& _internal_date() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_date(const std::string& value);
  std::string* _internal_mutable_date();
  public:

  // string revision = 3;
  void clear_revision();
  const std::string& revision() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_revision(ArgT0&& arg0, ArgT... args);
  std::string* mutable_revision();
  PROTOBUF_NODISCARD std::string* release_revision();
  void set_allocated_revision(std::string* revision);
  private:
  const std::string& _internal_revision() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_revision(const std::string& value);
  std::string* _internal_mutable_revision();
  public:

  // string company = 4;
  void clear_company();
  const std::string& company() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_company(ArgT0&& arg0, ArgT... args);
  std::string* mutable_company();
  PROTOBUF_NODISCARD std::string* release_company();
  void set_allocated_company(std::string* company);
  private:
  const std::string& _internal_company() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_company(const std::string& value);
  std::string* _internal_mutable_company();
  public:

  // string comment1 = 5;
  void clear_comment1();
  const std::string& comment1() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_comment1(ArgT0&& arg0, ArgT... args);
  std::string* mutable_comment1();
  PROTOBUF_NODISCARD std::string* release_comment1();
  void set_allocated_comment1(std::string* comment1);
  private:
  const std::string& _internal_comment1() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comment1(const std::string& value);
  std::string* _internal_mutable_comment1();
  public:

  // string comment2 = 6;
  void clear_comment2();
  const std::string& comment2() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_comment2(ArgT0&& arg0, ArgT... args);
  std::string* mutable_comment2();
  PROTOBUF_NODISCARD std::string* release_comment2();
  void set_allocated_comment2(std::string* comment2);
  private:
  const std::string& _internal_comment2() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comment2(const std::string& value);
  std::string* _internal_mutable_comment2();
  public:

  // string comment3 = 7;
  void clear_comment3();
  const std::string& comment3() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_comment3(ArgT0&& arg0, ArgT... args);
  std::string* mutable_comment3();
  PROTOBUF_NODISCARD std::string* release_comment3();
  void set_allocated_comment3(std::string* comment3);
  private:
  const std::string& _internal_comment3() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comment3(const std::string& value);
  std::string* _internal_mutable_comment3();
  public:

  // string comment4 = 8;
  void clear_comment4();
  const std::string& comment4() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_comment4(ArgT0&& arg0, ArgT... args);
  std::string* mutable_comment4();
  PROTOBUF_NODISCARD std::string* release_comment4();
  void set_allocated_comment4(std::string* comment4);
  private:
  const std::string& _internal_comment4() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comment4(const std::string& value);
  std::string* _internal_mutable_comment4();
  public:

  // string comment5 = 9;
  void clear_comment5();
  const std::string& comment5() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_comment5(ArgT0&& arg0, ArgT... args);
  std::string* mutable_comment5();
  PROTOBUF_NODISCARD std::string* release_comment5();
  void set_allocated_comment5(std::string* comment5);
  private:
  const std::string& _internal_comment5() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comment5(const std::string& value);
  std::string* _internal_mutable_comment5();
  public:

  // string comment6 = 10;
  void clear_comment6();
  const std::string& comment6() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_comment6(ArgT0&& arg0, ArgT... args);
  std::string* mutable_comment6();
  PROTOBUF_NODISCARD std::string* release_comment6();
  void set_allocated_comment6(std::string* comment6);
  private:
  const std::string& _internal_comment6() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comment6(const std::string& value);
  std::string* _internal_mutable_comment6();
  public:

  // string comment7 = 11;
  void clear_comment7();
  const std::string& comment7() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_comment7(ArgT0&& arg0, ArgT... args);
  std::string* mutable_comment7();
  PROTOBUF_NODISCARD std::string* release_comment7();
  void set_allocated_comment7(std::string* comment7);
  private:
  const std::string& _internal_comment7() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comment7(const std::string& value);
  std::string* _internal_mutable_comment7();
  public:

  // string comment8 = 12;
  void clear_comment8();
  const std::string& comment8() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_comment8(ArgT0&& arg0, ArgT... args);
  std::string* mutable_comment8();
  PROTOBUF_NODISCARD std::string* release_comment8();
  void set_allocated_comment8(std::string* comment8);
  private:
  const std::string& _internal_comment8() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comment8(const std::string& value);
  std::string* _internal_mutable_comment8();
  public:

  // string comment9 = 13;
  void clear_comment9();
  const std::string& comment9() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_comment9(ArgT0&& arg0, ArgT... args);
  std::string* mutable_comment9();
  PROTOBUF_NODISCARD std::string* release_comment9();
  void set_allocated_comment9(std::string* comment9);
  private:
  const std::string& _internal_comment9() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comment9(const std::string& value);
  std::string* _internal_mutable_comment9();
  public:

  // @@protoc_insertion_point(class_scope:kiapi.common.types.TitleBlockInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr date_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr revision_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr company_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comment1_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comment2_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comment3_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comment4_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comment5_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comment6_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comment7_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comment8_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comment9_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2ftypes_2fbase_5ftypes_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CommandStatusResponse

// .kiapi.common.types.CommandStatus status = 1;
inline void CommandStatusResponse::clear_status() {
  status_ = 0;
}
inline ::kiapi::common::types::CommandStatus CommandStatusResponse::_internal_status() const {
  return static_cast< ::kiapi::common::types::CommandStatus >(status_);
}
inline ::kiapi::common::types::CommandStatus CommandStatusResponse::status() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.CommandStatusResponse.status)
  return _internal_status();
}
inline void CommandStatusResponse::_internal_set_status(::kiapi::common::types::CommandStatus value) {
  
  status_ = value;
}
inline void CommandStatusResponse::set_status(::kiapi::common::types::CommandStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:kiapi.common.types.CommandStatusResponse.status)
}

// -------------------------------------------------------------------

// KiCadVersion

// uint32 major = 1;
inline void KiCadVersion::clear_major() {
  major_ = 0u;
}
inline uint32_t KiCadVersion::_internal_major() const {
  return major_;
}
inline uint32_t KiCadVersion::major() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.KiCadVersion.major)
  return _internal_major();
}
inline void KiCadVersion::_internal_set_major(uint32_t value) {
  
  major_ = value;
}
inline void KiCadVersion::set_major(uint32_t value) {
  _internal_set_major(value);
  // @@protoc_insertion_point(field_set:kiapi.common.types.KiCadVersion.major)
}

// uint32 minor = 2;
inline void KiCadVersion::clear_minor() {
  minor_ = 0u;
}
inline uint32_t KiCadVersion::_internal_minor() const {
  return minor_;
}
inline uint32_t KiCadVersion::minor() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.KiCadVersion.minor)
  return _internal_minor();
}
inline void KiCadVersion::_internal_set_minor(uint32_t value) {
  
  minor_ = value;
}
inline void KiCadVersion::set_minor(uint32_t value) {
  _internal_set_minor(value);
  // @@protoc_insertion_point(field_set:kiapi.common.types.KiCadVersion.minor)
}

// uint32 patch = 3;
inline void KiCadVersion::clear_patch() {
  patch_ = 0u;
}
inline uint32_t KiCadVersion::_internal_patch() const {
  return patch_;
}
inline uint32_t KiCadVersion::patch() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.KiCadVersion.patch)
  return _internal_patch();
}
inline void KiCadVersion::_internal_set_patch(uint32_t value) {
  
  patch_ = value;
}
inline void KiCadVersion::set_patch(uint32_t value) {
  _internal_set_patch(value);
  // @@protoc_insertion_point(field_set:kiapi.common.types.KiCadVersion.patch)
}

// string full_version = 4;
inline void KiCadVersion::clear_full_version() {
  full_version_.ClearToEmpty();
}
inline const std::string& KiCadVersion::full_version() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.KiCadVersion.full_version)
  return _internal_full_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KiCadVersion::set_full_version(ArgT0&& arg0, ArgT... args) {
 
 full_version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kiapi.common.types.KiCadVersion.full_version)
}
inline std::string* KiCadVersion::mutable_full_version() {
  std::string* _s = _internal_mutable_full_version();
  // @@protoc_insertion_point(field_mutable:kiapi.common.types.KiCadVersion.full_version)
  return _s;
}
inline const std::string& KiCadVersion::_internal_full_version() const {
  return full_version_.Get();
}
inline void KiCadVersion::_internal_set_full_version(const std::string& value) {
  
  full_version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* KiCadVersion::_internal_mutable_full_version() {
  
  return full_version_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* KiCadVersion::release_full_version() {
  // @@protoc_insertion_point(field_release:kiapi.common.types.KiCadVersion.full_version)
  return full_version_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void KiCadVersion::set_allocated_full_version(std::string* full_version) {
  if (full_version != nullptr) {
    
  } else {
    
  }
  full_version_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), full_version,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (full_version_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    full_version_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.types.KiCadVersion.full_version)
}

// -------------------------------------------------------------------

// KIID

// string value = 1;
inline void KIID::clear_value() {
  value_.ClearToEmpty();
}
inline const std::string& KIID::value() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.KIID.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KIID::set_value(ArgT0&& arg0, ArgT... args) {
 
 value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kiapi.common.types.KIID.value)
}
inline std::string* KIID::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:kiapi.common.types.KIID.value)
  return _s;
}
inline const std::string& KIID::_internal_value() const {
  return value_.Get();
}
inline void KIID::_internal_set_value(const std::string& value) {
  
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* KIID::_internal_mutable_value() {
  
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* KIID::release_value() {
  // @@protoc_insertion_point(field_release:kiapi.common.types.KIID.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void KIID::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (value_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.types.KIID.value)
}

// -------------------------------------------------------------------

// LibraryIdentifier

// string library_nickname = 1;
inline void LibraryIdentifier::clear_library_nickname() {
  library_nickname_.ClearToEmpty();
}
inline const std::string& LibraryIdentifier::library_nickname() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.LibraryIdentifier.library_nickname)
  return _internal_library_nickname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LibraryIdentifier::set_library_nickname(ArgT0&& arg0, ArgT... args) {
 
 library_nickname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kiapi.common.types.LibraryIdentifier.library_nickname)
}
inline std::string* LibraryIdentifier::mutable_library_nickname() {
  std::string* _s = _internal_mutable_library_nickname();
  // @@protoc_insertion_point(field_mutable:kiapi.common.types.LibraryIdentifier.library_nickname)
  return _s;
}
inline const std::string& LibraryIdentifier::_internal_library_nickname() const {
  return library_nickname_.Get();
}
inline void LibraryIdentifier::_internal_set_library_nickname(const std::string& value) {
  
  library_nickname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LibraryIdentifier::_internal_mutable_library_nickname() {
  
  return library_nickname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LibraryIdentifier::release_library_nickname() {
  // @@protoc_insertion_point(field_release:kiapi.common.types.LibraryIdentifier.library_nickname)
  return library_nickname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void LibraryIdentifier::set_allocated_library_nickname(std::string* library_nickname) {
  if (library_nickname != nullptr) {
    
  } else {
    
  }
  library_nickname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), library_nickname,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (library_nickname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    library_nickname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.types.LibraryIdentifier.library_nickname)
}

// string entry_name = 2;
inline void LibraryIdentifier::clear_entry_name() {
  entry_name_.ClearToEmpty();
}
inline const std::string& LibraryIdentifier::entry_name() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.LibraryIdentifier.entry_name)
  return _internal_entry_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LibraryIdentifier::set_entry_name(ArgT0&& arg0, ArgT... args) {
 
 entry_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kiapi.common.types.LibraryIdentifier.entry_name)
}
inline std::string* LibraryIdentifier::mutable_entry_name() {
  std::string* _s = _internal_mutable_entry_name();
  // @@protoc_insertion_point(field_mutable:kiapi.common.types.LibraryIdentifier.entry_name)
  return _s;
}
inline const std::string& LibraryIdentifier::_internal_entry_name() const {
  return entry_name_.Get();
}
inline void LibraryIdentifier::_internal_set_entry_name(const std::string& value) {
  
  entry_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LibraryIdentifier::_internal_mutable_entry_name() {
  
  return entry_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LibraryIdentifier::release_entry_name() {
  // @@protoc_insertion_point(field_release:kiapi.common.types.LibraryIdentifier.entry_name)
  return entry_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void LibraryIdentifier::set_allocated_entry_name(std::string* entry_name) {
  if (entry_name != nullptr) {
    
  } else {
    
  }
  entry_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), entry_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (entry_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    entry_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.types.LibraryIdentifier.entry_name)
}

// -------------------------------------------------------------------

// SheetPath

// repeated .kiapi.common.types.KIID path = 1;
inline int SheetPath::_internal_path_size() const {
  return path_.size();
}
inline int SheetPath::path_size() const {
  return _internal_path_size();
}
inline void SheetPath::clear_path() {
  path_.Clear();
}
inline ::kiapi::common::types::KIID* SheetPath::mutable_path(int index) {
  // @@protoc_insertion_point(field_mutable:kiapi.common.types.SheetPath.path)
  return path_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::types::KIID >*
SheetPath::mutable_path() {
  // @@protoc_insertion_point(field_mutable_list:kiapi.common.types.SheetPath.path)
  return &path_;
}
inline const ::kiapi::common::types::KIID& SheetPath::_internal_path(int index) const {
  return path_.Get(index);
}
inline const ::kiapi::common::types::KIID& SheetPath::path(int index) const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.SheetPath.path)
  return _internal_path(index);
}
inline ::kiapi::common::types::KIID* SheetPath::_internal_add_path() {
  return path_.Add();
}
inline ::kiapi::common::types::KIID* SheetPath::add_path() {
  ::kiapi::common::types::KIID* _add = _internal_add_path();
  // @@protoc_insertion_point(field_add:kiapi.common.types.SheetPath.path)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::types::KIID >&
SheetPath::path() const {
  // @@protoc_insertion_point(field_list:kiapi.common.types.SheetPath.path)
  return path_;
}

// string path_human_readable = 2;
inline void SheetPath::clear_path_human_readable() {
  path_human_readable_.ClearToEmpty();
}
inline const std::string& SheetPath::path_human_readable() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.SheetPath.path_human_readable)
  return _internal_path_human_readable();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SheetPath::set_path_human_readable(ArgT0&& arg0, ArgT... args) {
 
 path_human_readable_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kiapi.common.types.SheetPath.path_human_readable)
}
inline std::string* SheetPath::mutable_path_human_readable() {
  std::string* _s = _internal_mutable_path_human_readable();
  // @@protoc_insertion_point(field_mutable:kiapi.common.types.SheetPath.path_human_readable)
  return _s;
}
inline const std::string& SheetPath::_internal_path_human_readable() const {
  return path_human_readable_.Get();
}
inline void SheetPath::_internal_set_path_human_readable(const std::string& value) {
  
  path_human_readable_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SheetPath::_internal_mutable_path_human_readable() {
  
  return path_human_readable_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SheetPath::release_path_human_readable() {
  // @@protoc_insertion_point(field_release:kiapi.common.types.SheetPath.path_human_readable)
  return path_human_readable_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SheetPath::set_allocated_path_human_readable(std::string* path_human_readable) {
  if (path_human_readable != nullptr) {
    
  } else {
    
  }
  path_human_readable_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), path_human_readable,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (path_human_readable_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    path_human_readable_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.types.SheetPath.path_human_readable)
}

// -------------------------------------------------------------------

// ProjectSpecifier

// string name = 1;
inline void ProjectSpecifier::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& ProjectSpecifier::name() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.ProjectSpecifier.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProjectSpecifier::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kiapi.common.types.ProjectSpecifier.name)
}
inline std::string* ProjectSpecifier::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:kiapi.common.types.ProjectSpecifier.name)
  return _s;
}
inline const std::string& ProjectSpecifier::_internal_name() const {
  return name_.Get();
}
inline void ProjectSpecifier::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ProjectSpecifier::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ProjectSpecifier::release_name() {
  // @@protoc_insertion_point(field_release:kiapi.common.types.ProjectSpecifier.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ProjectSpecifier::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.types.ProjectSpecifier.name)
}

// string path = 2;
inline void ProjectSpecifier::clear_path() {
  path_.ClearToEmpty();
}
inline const std::string& ProjectSpecifier::path() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.ProjectSpecifier.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProjectSpecifier::set_path(ArgT0&& arg0, ArgT... args) {
 
 path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kiapi.common.types.ProjectSpecifier.path)
}
inline std::string* ProjectSpecifier::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:kiapi.common.types.ProjectSpecifier.path)
  return _s;
}
inline const std::string& ProjectSpecifier::_internal_path() const {
  return path_.Get();
}
inline void ProjectSpecifier::_internal_set_path(const std::string& value) {
  
  path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ProjectSpecifier::_internal_mutable_path() {
  
  return path_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ProjectSpecifier::release_path() {
  // @@protoc_insertion_point(field_release:kiapi.common.types.ProjectSpecifier.path)
  return path_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ProjectSpecifier::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), path,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (path_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.types.ProjectSpecifier.path)
}

// -------------------------------------------------------------------

// DocumentSpecifier

// .kiapi.common.types.DocumentType type = 1;
inline void DocumentSpecifier::clear_type() {
  type_ = 0;
}
inline ::kiapi::common::types::DocumentType DocumentSpecifier::_internal_type() const {
  return static_cast< ::kiapi::common::types::DocumentType >(type_);
}
inline ::kiapi::common::types::DocumentType DocumentSpecifier::type() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.DocumentSpecifier.type)
  return _internal_type();
}
inline void DocumentSpecifier::_internal_set_type(::kiapi::common::types::DocumentType value) {
  
  type_ = value;
}
inline void DocumentSpecifier::set_type(::kiapi::common::types::DocumentType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:kiapi.common.types.DocumentSpecifier.type)
}

// .kiapi.common.types.LibraryIdentifier lib_id = 2;
inline bool DocumentSpecifier::_internal_has_lib_id() const {
  return identifier_case() == kLibId;
}
inline bool DocumentSpecifier::has_lib_id() const {
  return _internal_has_lib_id();
}
inline void DocumentSpecifier::set_has_lib_id() {
  _oneof_case_[0] = kLibId;
}
inline void DocumentSpecifier::clear_lib_id() {
  if (_internal_has_lib_id()) {
    if (GetArenaForAllocation() == nullptr) {
      delete identifier_.lib_id_;
    }
    clear_has_identifier();
  }
}
inline ::kiapi::common::types::LibraryIdentifier* DocumentSpecifier::release_lib_id() {
  // @@protoc_insertion_point(field_release:kiapi.common.types.DocumentSpecifier.lib_id)
  if (_internal_has_lib_id()) {
    clear_has_identifier();
      ::kiapi::common::types::LibraryIdentifier* temp = identifier_.lib_id_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    identifier_.lib_id_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kiapi::common::types::LibraryIdentifier& DocumentSpecifier::_internal_lib_id() const {
  return _internal_has_lib_id()
      ? *identifier_.lib_id_
      : reinterpret_cast< ::kiapi::common::types::LibraryIdentifier&>(::kiapi::common::types::_LibraryIdentifier_default_instance_);
}
inline const ::kiapi::common::types::LibraryIdentifier& DocumentSpecifier::lib_id() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.DocumentSpecifier.lib_id)
  return _internal_lib_id();
}
inline ::kiapi::common::types::LibraryIdentifier* DocumentSpecifier::unsafe_arena_release_lib_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kiapi.common.types.DocumentSpecifier.lib_id)
  if (_internal_has_lib_id()) {
    clear_has_identifier();
    ::kiapi::common::types::LibraryIdentifier* temp = identifier_.lib_id_;
    identifier_.lib_id_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DocumentSpecifier::unsafe_arena_set_allocated_lib_id(::kiapi::common::types::LibraryIdentifier* lib_id) {
  clear_identifier();
  if (lib_id) {
    set_has_lib_id();
    identifier_.lib_id_ = lib_id;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kiapi.common.types.DocumentSpecifier.lib_id)
}
inline ::kiapi::common::types::LibraryIdentifier* DocumentSpecifier::_internal_mutable_lib_id() {
  if (!_internal_has_lib_id()) {
    clear_identifier();
    set_has_lib_id();
    identifier_.lib_id_ = CreateMaybeMessage< ::kiapi::common::types::LibraryIdentifier >(GetArenaForAllocation());
  }
  return identifier_.lib_id_;
}
inline ::kiapi::common::types::LibraryIdentifier* DocumentSpecifier::mutable_lib_id() {
  ::kiapi::common::types::LibraryIdentifier* _msg = _internal_mutable_lib_id();
  // @@protoc_insertion_point(field_mutable:kiapi.common.types.DocumentSpecifier.lib_id)
  return _msg;
}

// .kiapi.common.types.SheetPath sheet_path = 3;
inline bool DocumentSpecifier::_internal_has_sheet_path() const {
  return identifier_case() == kSheetPath;
}
inline bool DocumentSpecifier::has_sheet_path() const {
  return _internal_has_sheet_path();
}
inline void DocumentSpecifier::set_has_sheet_path() {
  _oneof_case_[0] = kSheetPath;
}
inline void DocumentSpecifier::clear_sheet_path() {
  if (_internal_has_sheet_path()) {
    if (GetArenaForAllocation() == nullptr) {
      delete identifier_.sheet_path_;
    }
    clear_has_identifier();
  }
}
inline ::kiapi::common::types::SheetPath* DocumentSpecifier::release_sheet_path() {
  // @@protoc_insertion_point(field_release:kiapi.common.types.DocumentSpecifier.sheet_path)
  if (_internal_has_sheet_path()) {
    clear_has_identifier();
      ::kiapi::common::types::SheetPath* temp = identifier_.sheet_path_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    identifier_.sheet_path_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kiapi::common::types::SheetPath& DocumentSpecifier::_internal_sheet_path() const {
  return _internal_has_sheet_path()
      ? *identifier_.sheet_path_
      : reinterpret_cast< ::kiapi::common::types::SheetPath&>(::kiapi::common::types::_SheetPath_default_instance_);
}
inline const ::kiapi::common::types::SheetPath& DocumentSpecifier::sheet_path() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.DocumentSpecifier.sheet_path)
  return _internal_sheet_path();
}
inline ::kiapi::common::types::SheetPath* DocumentSpecifier::unsafe_arena_release_sheet_path() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kiapi.common.types.DocumentSpecifier.sheet_path)
  if (_internal_has_sheet_path()) {
    clear_has_identifier();
    ::kiapi::common::types::SheetPath* temp = identifier_.sheet_path_;
    identifier_.sheet_path_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DocumentSpecifier::unsafe_arena_set_allocated_sheet_path(::kiapi::common::types::SheetPath* sheet_path) {
  clear_identifier();
  if (sheet_path) {
    set_has_sheet_path();
    identifier_.sheet_path_ = sheet_path;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kiapi.common.types.DocumentSpecifier.sheet_path)
}
inline ::kiapi::common::types::SheetPath* DocumentSpecifier::_internal_mutable_sheet_path() {
  if (!_internal_has_sheet_path()) {
    clear_identifier();
    set_has_sheet_path();
    identifier_.sheet_path_ = CreateMaybeMessage< ::kiapi::common::types::SheetPath >(GetArenaForAllocation());
  }
  return identifier_.sheet_path_;
}
inline ::kiapi::common::types::SheetPath* DocumentSpecifier::mutable_sheet_path() {
  ::kiapi::common::types::SheetPath* _msg = _internal_mutable_sheet_path();
  // @@protoc_insertion_point(field_mutable:kiapi.common.types.DocumentSpecifier.sheet_path)
  return _msg;
}

// string board_filename = 4;
inline bool DocumentSpecifier::_internal_has_board_filename() const {
  return identifier_case() == kBoardFilename;
}
inline bool DocumentSpecifier::has_board_filename() const {
  return _internal_has_board_filename();
}
inline void DocumentSpecifier::set_has_board_filename() {
  _oneof_case_[0] = kBoardFilename;
}
inline void DocumentSpecifier::clear_board_filename() {
  if (_internal_has_board_filename()) {
    identifier_.board_filename_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_identifier();
  }
}
inline const std::string& DocumentSpecifier::board_filename() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.DocumentSpecifier.board_filename)
  return _internal_board_filename();
}
template <typename ArgT0, typename... ArgT>
inline void DocumentSpecifier::set_board_filename(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_board_filename()) {
    clear_identifier();
    set_has_board_filename();
    identifier_.board_filename_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  identifier_.board_filename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kiapi.common.types.DocumentSpecifier.board_filename)
}
inline std::string* DocumentSpecifier::mutable_board_filename() {
  std::string* _s = _internal_mutable_board_filename();
  // @@protoc_insertion_point(field_mutable:kiapi.common.types.DocumentSpecifier.board_filename)
  return _s;
}
inline const std::string& DocumentSpecifier::_internal_board_filename() const {
  if (_internal_has_board_filename()) {
    return identifier_.board_filename_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void DocumentSpecifier::_internal_set_board_filename(const std::string& value) {
  if (!_internal_has_board_filename()) {
    clear_identifier();
    set_has_board_filename();
    identifier_.board_filename_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  identifier_.board_filename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DocumentSpecifier::_internal_mutable_board_filename() {
  if (!_internal_has_board_filename()) {
    clear_identifier();
    set_has_board_filename();
    identifier_.board_filename_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return identifier_.board_filename_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DocumentSpecifier::release_board_filename() {
  // @@protoc_insertion_point(field_release:kiapi.common.types.DocumentSpecifier.board_filename)
  if (_internal_has_board_filename()) {
    clear_has_identifier();
    return identifier_.board_filename_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void DocumentSpecifier::set_allocated_board_filename(std::string* board_filename) {
  if (has_identifier()) {
    clear_identifier();
  }
  if (board_filename != nullptr) {
    set_has_board_filename();
    identifier_.board_filename_.UnsafeSetDefault(board_filename);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(board_filename);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.types.DocumentSpecifier.board_filename)
}

// .kiapi.common.types.ProjectSpecifier project = 5;
inline bool DocumentSpecifier::_internal_has_project() const {
  return this != internal_default_instance() && project_ != nullptr;
}
inline bool DocumentSpecifier::has_project() const {
  return _internal_has_project();
}
inline void DocumentSpecifier::clear_project() {
  if (GetArenaForAllocation() == nullptr && project_ != nullptr) {
    delete project_;
  }
  project_ = nullptr;
}
inline const ::kiapi::common::types::ProjectSpecifier& DocumentSpecifier::_internal_project() const {
  const ::kiapi::common::types::ProjectSpecifier* p = project_;
  return p != nullptr ? *p : reinterpret_cast<const ::kiapi::common::types::ProjectSpecifier&>(
      ::kiapi::common::types::_ProjectSpecifier_default_instance_);
}
inline const ::kiapi::common::types::ProjectSpecifier& DocumentSpecifier::project() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.DocumentSpecifier.project)
  return _internal_project();
}
inline void DocumentSpecifier::unsafe_arena_set_allocated_project(
    ::kiapi::common::types::ProjectSpecifier* project) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(project_);
  }
  project_ = project;
  if (project) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kiapi.common.types.DocumentSpecifier.project)
}
inline ::kiapi::common::types::ProjectSpecifier* DocumentSpecifier::release_project() {
  
  ::kiapi::common::types::ProjectSpecifier* temp = project_;
  project_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kiapi::common::types::ProjectSpecifier* DocumentSpecifier::unsafe_arena_release_project() {
  // @@protoc_insertion_point(field_release:kiapi.common.types.DocumentSpecifier.project)
  
  ::kiapi::common::types::ProjectSpecifier* temp = project_;
  project_ = nullptr;
  return temp;
}
inline ::kiapi::common::types::ProjectSpecifier* DocumentSpecifier::_internal_mutable_project() {
  
  if (project_ == nullptr) {
    auto* p = CreateMaybeMessage<::kiapi::common::types::ProjectSpecifier>(GetArenaForAllocation());
    project_ = p;
  }
  return project_;
}
inline ::kiapi::common::types::ProjectSpecifier* DocumentSpecifier::mutable_project() {
  ::kiapi::common::types::ProjectSpecifier* _msg = _internal_mutable_project();
  // @@protoc_insertion_point(field_mutable:kiapi.common.types.DocumentSpecifier.project)
  return _msg;
}
inline void DocumentSpecifier::set_allocated_project(::kiapi::common::types::ProjectSpecifier* project) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete project_;
  }
  if (project) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::kiapi::common::types::ProjectSpecifier>::GetOwningArena(project);
    if (message_arena != submessage_arena) {
      project = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, project, submessage_arena);
    }
    
  } else {
    
  }
  project_ = project;
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.types.DocumentSpecifier.project)
}

inline bool DocumentSpecifier::has_identifier() const {
  return identifier_case() != IDENTIFIER_NOT_SET;
}
inline void DocumentSpecifier::clear_has_identifier() {
  _oneof_case_[0] = IDENTIFIER_NOT_SET;
}
inline DocumentSpecifier::IdentifierCase DocumentSpecifier::identifier_case() const {
  return DocumentSpecifier::IdentifierCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ItemHeader

// .kiapi.common.types.DocumentSpecifier document = 1;
inline bool ItemHeader::_internal_has_document() const {
  return this != internal_default_instance() && document_ != nullptr;
}
inline bool ItemHeader::has_document() const {
  return _internal_has_document();
}
inline void ItemHeader::clear_document() {
  if (GetArenaForAllocation() == nullptr && document_ != nullptr) {
    delete document_;
  }
  document_ = nullptr;
}
inline const ::kiapi::common::types::DocumentSpecifier& ItemHeader::_internal_document() const {
  const ::kiapi::common::types::DocumentSpecifier* p = document_;
  return p != nullptr ? *p : reinterpret_cast<const ::kiapi::common::types::DocumentSpecifier&>(
      ::kiapi::common::types::_DocumentSpecifier_default_instance_);
}
inline const ::kiapi::common::types::DocumentSpecifier& ItemHeader::document() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.ItemHeader.document)
  return _internal_document();
}
inline void ItemHeader::unsafe_arena_set_allocated_document(
    ::kiapi::common::types::DocumentSpecifier* document) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(document_);
  }
  document_ = document;
  if (document) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kiapi.common.types.ItemHeader.document)
}
inline ::kiapi::common::types::DocumentSpecifier* ItemHeader::release_document() {
  
  ::kiapi::common::types::DocumentSpecifier* temp = document_;
  document_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kiapi::common::types::DocumentSpecifier* ItemHeader::unsafe_arena_release_document() {
  // @@protoc_insertion_point(field_release:kiapi.common.types.ItemHeader.document)
  
  ::kiapi::common::types::DocumentSpecifier* temp = document_;
  document_ = nullptr;
  return temp;
}
inline ::kiapi::common::types::DocumentSpecifier* ItemHeader::_internal_mutable_document() {
  
  if (document_ == nullptr) {
    auto* p = CreateMaybeMessage<::kiapi::common::types::DocumentSpecifier>(GetArenaForAllocation());
    document_ = p;
  }
  return document_;
}
inline ::kiapi::common::types::DocumentSpecifier* ItemHeader::mutable_document() {
  ::kiapi::common::types::DocumentSpecifier* _msg = _internal_mutable_document();
  // @@protoc_insertion_point(field_mutable:kiapi.common.types.ItemHeader.document)
  return _msg;
}
inline void ItemHeader::set_allocated_document(::kiapi::common::types::DocumentSpecifier* document) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete document_;
  }
  if (document) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::kiapi::common::types::DocumentSpecifier>::GetOwningArena(document);
    if (message_arena != submessage_arena) {
      document = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, document, submessage_arena);
    }
    
  } else {
    
  }
  document_ = document;
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.types.ItemHeader.document)
}

// .kiapi.common.types.KIID container = 2;
inline bool ItemHeader::_internal_has_container() const {
  return this != internal_default_instance() && container_ != nullptr;
}
inline bool ItemHeader::has_container() const {
  return _internal_has_container();
}
inline void ItemHeader::clear_container() {
  if (GetArenaForAllocation() == nullptr && container_ != nullptr) {
    delete container_;
  }
  container_ = nullptr;
}
inline const ::kiapi::common::types::KIID& ItemHeader::_internal_container() const {
  const ::kiapi::common::types::KIID* p = container_;
  return p != nullptr ? *p : reinterpret_cast<const ::kiapi::common::types::KIID&>(
      ::kiapi::common::types::_KIID_default_instance_);
}
inline const ::kiapi::common::types::KIID& ItemHeader::container() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.ItemHeader.container)
  return _internal_container();
}
inline void ItemHeader::unsafe_arena_set_allocated_container(
    ::kiapi::common::types::KIID* container) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(container_);
  }
  container_ = container;
  if (container) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kiapi.common.types.ItemHeader.container)
}
inline ::kiapi::common::types::KIID* ItemHeader::release_container() {
  
  ::kiapi::common::types::KIID* temp = container_;
  container_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kiapi::common::types::KIID* ItemHeader::unsafe_arena_release_container() {
  // @@protoc_insertion_point(field_release:kiapi.common.types.ItemHeader.container)
  
  ::kiapi::common::types::KIID* temp = container_;
  container_ = nullptr;
  return temp;
}
inline ::kiapi::common::types::KIID* ItemHeader::_internal_mutable_container() {
  
  if (container_ == nullptr) {
    auto* p = CreateMaybeMessage<::kiapi::common::types::KIID>(GetArenaForAllocation());
    container_ = p;
  }
  return container_;
}
inline ::kiapi::common::types::KIID* ItemHeader::mutable_container() {
  ::kiapi::common::types::KIID* _msg = _internal_mutable_container();
  // @@protoc_insertion_point(field_mutable:kiapi.common.types.ItemHeader.container)
  return _msg;
}
inline void ItemHeader::set_allocated_container(::kiapi::common::types::KIID* container) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete container_;
  }
  if (container) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::kiapi::common::types::KIID>::GetOwningArena(container);
    if (message_arena != submessage_arena) {
      container = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, container, submessage_arena);
    }
    
  } else {
    
  }
  container_ = container;
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.types.ItemHeader.container)
}

// .google.protobuf.FieldMask field_mask = 3;
inline bool ItemHeader::_internal_has_field_mask() const {
  return this != internal_default_instance() && field_mask_ != nullptr;
}
inline bool ItemHeader::has_field_mask() const {
  return _internal_has_field_mask();
}
inline const ::PROTOBUF_NAMESPACE_ID::FieldMask& ItemHeader::_internal_field_mask() const {
  const ::PROTOBUF_NAMESPACE_ID::FieldMask* p = field_mask_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::FieldMask&>(
      ::PROTOBUF_NAMESPACE_ID::_FieldMask_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::FieldMask& ItemHeader::field_mask() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.ItemHeader.field_mask)
  return _internal_field_mask();
}
inline void ItemHeader::unsafe_arena_set_allocated_field_mask(
    ::PROTOBUF_NAMESPACE_ID::FieldMask* field_mask) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(field_mask_);
  }
  field_mask_ = field_mask;
  if (field_mask) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kiapi.common.types.ItemHeader.field_mask)
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* ItemHeader::release_field_mask() {
  
  ::PROTOBUF_NAMESPACE_ID::FieldMask* temp = field_mask_;
  field_mask_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* ItemHeader::unsafe_arena_release_field_mask() {
  // @@protoc_insertion_point(field_release:kiapi.common.types.ItemHeader.field_mask)
  
  ::PROTOBUF_NAMESPACE_ID::FieldMask* temp = field_mask_;
  field_mask_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* ItemHeader::_internal_mutable_field_mask() {
  
  if (field_mask_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::FieldMask>(GetArenaForAllocation());
    field_mask_ = p;
  }
  return field_mask_;
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* ItemHeader::mutable_field_mask() {
  ::PROTOBUF_NAMESPACE_ID::FieldMask* _msg = _internal_mutable_field_mask();
  // @@protoc_insertion_point(field_mutable:kiapi.common.types.ItemHeader.field_mask)
  return _msg;
}
inline void ItemHeader::set_allocated_field_mask(::PROTOBUF_NAMESPACE_ID::FieldMask* field_mask) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(field_mask_);
  }
  if (field_mask) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(field_mask));
    if (message_arena != submessage_arena) {
      field_mask = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, field_mask, submessage_arena);
    }
    
  } else {
    
  }
  field_mask_ = field_mask;
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.types.ItemHeader.field_mask)
}

// -------------------------------------------------------------------

// Vector2

// int64 x_nm = 1;
inline void Vector2::clear_x_nm() {
  x_nm_ = int64_t{0};
}
inline int64_t Vector2::_internal_x_nm() const {
  return x_nm_;
}
inline int64_t Vector2::x_nm() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.Vector2.x_nm)
  return _internal_x_nm();
}
inline void Vector2::_internal_set_x_nm(int64_t value) {
  
  x_nm_ = value;
}
inline void Vector2::set_x_nm(int64_t value) {
  _internal_set_x_nm(value);
  // @@protoc_insertion_point(field_set:kiapi.common.types.Vector2.x_nm)
}

// int64 y_nm = 2;
inline void Vector2::clear_y_nm() {
  y_nm_ = int64_t{0};
}
inline int64_t Vector2::_internal_y_nm() const {
  return y_nm_;
}
inline int64_t Vector2::y_nm() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.Vector2.y_nm)
  return _internal_y_nm();
}
inline void Vector2::_internal_set_y_nm(int64_t value) {
  
  y_nm_ = value;
}
inline void Vector2::set_y_nm(int64_t value) {
  _internal_set_y_nm(value);
  // @@protoc_insertion_point(field_set:kiapi.common.types.Vector2.y_nm)
}

// -------------------------------------------------------------------

// Vector3

// int64 x_nm = 1;
inline void Vector3::clear_x_nm() {
  x_nm_ = int64_t{0};
}
inline int64_t Vector3::_internal_x_nm() const {
  return x_nm_;
}
inline int64_t Vector3::x_nm() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.Vector3.x_nm)
  return _internal_x_nm();
}
inline void Vector3::_internal_set_x_nm(int64_t value) {
  
  x_nm_ = value;
}
inline void Vector3::set_x_nm(int64_t value) {
  _internal_set_x_nm(value);
  // @@protoc_insertion_point(field_set:kiapi.common.types.Vector3.x_nm)
}

// int64 y_nm = 2;
inline void Vector3::clear_y_nm() {
  y_nm_ = int64_t{0};
}
inline int64_t Vector3::_internal_y_nm() const {
  return y_nm_;
}
inline int64_t Vector3::y_nm() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.Vector3.y_nm)
  return _internal_y_nm();
}
inline void Vector3::_internal_set_y_nm(int64_t value) {
  
  y_nm_ = value;
}
inline void Vector3::set_y_nm(int64_t value) {
  _internal_set_y_nm(value);
  // @@protoc_insertion_point(field_set:kiapi.common.types.Vector3.y_nm)
}

// int64 z_nm = 3;
inline void Vector3::clear_z_nm() {
  z_nm_ = int64_t{0};
}
inline int64_t Vector3::_internal_z_nm() const {
  return z_nm_;
}
inline int64_t Vector3::z_nm() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.Vector3.z_nm)
  return _internal_z_nm();
}
inline void Vector3::_internal_set_z_nm(int64_t value) {
  
  z_nm_ = value;
}
inline void Vector3::set_z_nm(int64_t value) {
  _internal_set_z_nm(value);
  // @@protoc_insertion_point(field_set:kiapi.common.types.Vector3.z_nm)
}

// -------------------------------------------------------------------

// Vector3D

// double x_nm = 1;
inline void Vector3D::clear_x_nm() {
  x_nm_ = 0;
}
inline double Vector3D::_internal_x_nm() const {
  return x_nm_;
}
inline double Vector3D::x_nm() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.Vector3D.x_nm)
  return _internal_x_nm();
}
inline void Vector3D::_internal_set_x_nm(double value) {
  
  x_nm_ = value;
}
inline void Vector3D::set_x_nm(double value) {
  _internal_set_x_nm(value);
  // @@protoc_insertion_point(field_set:kiapi.common.types.Vector3D.x_nm)
}

// double y_nm = 2;
inline void Vector3D::clear_y_nm() {
  y_nm_ = 0;
}
inline double Vector3D::_internal_y_nm() const {
  return y_nm_;
}
inline double Vector3D::y_nm() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.Vector3D.y_nm)
  return _internal_y_nm();
}
inline void Vector3D::_internal_set_y_nm(double value) {
  
  y_nm_ = value;
}
inline void Vector3D::set_y_nm(double value) {
  _internal_set_y_nm(value);
  // @@protoc_insertion_point(field_set:kiapi.common.types.Vector3D.y_nm)
}

// double z_nm = 3;
inline void Vector3D::clear_z_nm() {
  z_nm_ = 0;
}
inline double Vector3D::_internal_z_nm() const {
  return z_nm_;
}
inline double Vector3D::z_nm() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.Vector3D.z_nm)
  return _internal_z_nm();
}
inline void Vector3D::_internal_set_z_nm(double value) {
  
  z_nm_ = value;
}
inline void Vector3D::set_z_nm(double value) {
  _internal_set_z_nm(value);
  // @@protoc_insertion_point(field_set:kiapi.common.types.Vector3D.z_nm)
}

// -------------------------------------------------------------------

// Box2

// .kiapi.common.types.Vector2 position = 1;
inline bool Box2::_internal_has_position() const {
  return this != internal_default_instance() && position_ != nullptr;
}
inline bool Box2::has_position() const {
  return _internal_has_position();
}
inline void Box2::clear_position() {
  if (GetArenaForAllocation() == nullptr && position_ != nullptr) {
    delete position_;
  }
  position_ = nullptr;
}
inline const ::kiapi::common::types::Vector2& Box2::_internal_position() const {
  const ::kiapi::common::types::Vector2* p = position_;
  return p != nullptr ? *p : reinterpret_cast<const ::kiapi::common::types::Vector2&>(
      ::kiapi::common::types::_Vector2_default_instance_);
}
inline const ::kiapi::common::types::Vector2& Box2::position() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.Box2.position)
  return _internal_position();
}
inline void Box2::unsafe_arena_set_allocated_position(
    ::kiapi::common::types::Vector2* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(position_);
  }
  position_ = position;
  if (position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kiapi.common.types.Box2.position)
}
inline ::kiapi::common::types::Vector2* Box2::release_position() {
  
  ::kiapi::common::types::Vector2* temp = position_;
  position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kiapi::common::types::Vector2* Box2::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:kiapi.common.types.Box2.position)
  
  ::kiapi::common::types::Vector2* temp = position_;
  position_ = nullptr;
  return temp;
}
inline ::kiapi::common::types::Vector2* Box2::_internal_mutable_position() {
  
  if (position_ == nullptr) {
    auto* p = CreateMaybeMessage<::kiapi::common::types::Vector2>(GetArenaForAllocation());
    position_ = p;
  }
  return position_;
}
inline ::kiapi::common::types::Vector2* Box2::mutable_position() {
  ::kiapi::common::types::Vector2* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:kiapi.common.types.Box2.position)
  return _msg;
}
inline void Box2::set_allocated_position(::kiapi::common::types::Vector2* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::kiapi::common::types::Vector2>::GetOwningArena(position);
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.types.Box2.position)
}

// .kiapi.common.types.Vector2 size = 2;
inline bool Box2::_internal_has_size() const {
  return this != internal_default_instance() && size_ != nullptr;
}
inline bool Box2::has_size() const {
  return _internal_has_size();
}
inline void Box2::clear_size() {
  if (GetArenaForAllocation() == nullptr && size_ != nullptr) {
    delete size_;
  }
  size_ = nullptr;
}
inline const ::kiapi::common::types::Vector2& Box2::_internal_size() const {
  const ::kiapi::common::types::Vector2* p = size_;
  return p != nullptr ? *p : reinterpret_cast<const ::kiapi::common::types::Vector2&>(
      ::kiapi::common::types::_Vector2_default_instance_);
}
inline const ::kiapi::common::types::Vector2& Box2::size() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.Box2.size)
  return _internal_size();
}
inline void Box2::unsafe_arena_set_allocated_size(
    ::kiapi::common::types::Vector2* size) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(size_);
  }
  size_ = size;
  if (size) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kiapi.common.types.Box2.size)
}
inline ::kiapi::common::types::Vector2* Box2::release_size() {
  
  ::kiapi::common::types::Vector2* temp = size_;
  size_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kiapi::common::types::Vector2* Box2::unsafe_arena_release_size() {
  // @@protoc_insertion_point(field_release:kiapi.common.types.Box2.size)
  
  ::kiapi::common::types::Vector2* temp = size_;
  size_ = nullptr;
  return temp;
}
inline ::kiapi::common::types::Vector2* Box2::_internal_mutable_size() {
  
  if (size_ == nullptr) {
    auto* p = CreateMaybeMessage<::kiapi::common::types::Vector2>(GetArenaForAllocation());
    size_ = p;
  }
  return size_;
}
inline ::kiapi::common::types::Vector2* Box2::mutable_size() {
  ::kiapi::common::types::Vector2* _msg = _internal_mutable_size();
  // @@protoc_insertion_point(field_mutable:kiapi.common.types.Box2.size)
  return _msg;
}
inline void Box2::set_allocated_size(::kiapi::common::types::Vector2* size) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete size_;
  }
  if (size) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::kiapi::common::types::Vector2>::GetOwningArena(size);
    if (message_arena != submessage_arena) {
      size = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, size, submessage_arena);
    }
    
  } else {
    
  }
  size_ = size;
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.types.Box2.size)
}

// -------------------------------------------------------------------

// Distance

// int64 value_nm = 1;
inline void Distance::clear_value_nm() {
  value_nm_ = int64_t{0};
}
inline int64_t Distance::_internal_value_nm() const {
  return value_nm_;
}
inline int64_t Distance::value_nm() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.Distance.value_nm)
  return _internal_value_nm();
}
inline void Distance::_internal_set_value_nm(int64_t value) {
  
  value_nm_ = value;
}
inline void Distance::set_value_nm(int64_t value) {
  _internal_set_value_nm(value);
  // @@protoc_insertion_point(field_set:kiapi.common.types.Distance.value_nm)
}

// -------------------------------------------------------------------

// Angle

// double value_degrees = 1;
inline void Angle::clear_value_degrees() {
  value_degrees_ = 0;
}
inline double Angle::_internal_value_degrees() const {
  return value_degrees_;
}
inline double Angle::value_degrees() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.Angle.value_degrees)
  return _internal_value_degrees();
}
inline void Angle::_internal_set_value_degrees(double value) {
  
  value_degrees_ = value;
}
inline void Angle::set_value_degrees(double value) {
  _internal_set_value_degrees(value);
  // @@protoc_insertion_point(field_set:kiapi.common.types.Angle.value_degrees)
}

// -------------------------------------------------------------------

// Ratio

// double value = 1;
inline void Ratio::clear_value() {
  value_ = 0;
}
inline double Ratio::_internal_value() const {
  return value_;
}
inline double Ratio::value() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.Ratio.value)
  return _internal_value();
}
inline void Ratio::_internal_set_value(double value) {
  
  value_ = value;
}
inline void Ratio::set_value(double value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:kiapi.common.types.Ratio.value)
}

// -------------------------------------------------------------------

// Color

// double r = 1;
inline void Color::clear_r() {
  r_ = 0;
}
inline double Color::_internal_r() const {
  return r_;
}
inline double Color::r() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.Color.r)
  return _internal_r();
}
inline void Color::_internal_set_r(double value) {
  
  r_ = value;
}
inline void Color::set_r(double value) {
  _internal_set_r(value);
  // @@protoc_insertion_point(field_set:kiapi.common.types.Color.r)
}

// double g = 2;
inline void Color::clear_g() {
  g_ = 0;
}
inline double Color::_internal_g() const {
  return g_;
}
inline double Color::g() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.Color.g)
  return _internal_g();
}
inline void Color::_internal_set_g(double value) {
  
  g_ = value;
}
inline void Color::set_g(double value) {
  _internal_set_g(value);
  // @@protoc_insertion_point(field_set:kiapi.common.types.Color.g)
}

// double b = 3;
inline void Color::clear_b() {
  b_ = 0;
}
inline double Color::_internal_b() const {
  return b_;
}
inline double Color::b() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.Color.b)
  return _internal_b();
}
inline void Color::_internal_set_b(double value) {
  
  b_ = value;
}
inline void Color::set_b(double value) {
  _internal_set_b(value);
  // @@protoc_insertion_point(field_set:kiapi.common.types.Color.b)
}

// double a = 4;
inline void Color::clear_a() {
  a_ = 0;
}
inline double Color::_internal_a() const {
  return a_;
}
inline double Color::a() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.Color.a)
  return _internal_a();
}
inline void Color::_internal_set_a(double value) {
  
  a_ = value;
}
inline void Color::set_a(double value) {
  _internal_set_a(value);
  // @@protoc_insertion_point(field_set:kiapi.common.types.Color.a)
}

// -------------------------------------------------------------------

// ArcStartMidEnd

// .kiapi.common.types.Vector2 start = 1;
inline bool ArcStartMidEnd::_internal_has_start() const {
  return this != internal_default_instance() && start_ != nullptr;
}
inline bool ArcStartMidEnd::has_start() const {
  return _internal_has_start();
}
inline void ArcStartMidEnd::clear_start() {
  if (GetArenaForAllocation() == nullptr && start_ != nullptr) {
    delete start_;
  }
  start_ = nullptr;
}
inline const ::kiapi::common::types::Vector2& ArcStartMidEnd::_internal_start() const {
  const ::kiapi::common::types::Vector2* p = start_;
  return p != nullptr ? *p : reinterpret_cast<const ::kiapi::common::types::Vector2&>(
      ::kiapi::common::types::_Vector2_default_instance_);
}
inline const ::kiapi::common::types::Vector2& ArcStartMidEnd::start() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.ArcStartMidEnd.start)
  return _internal_start();
}
inline void ArcStartMidEnd::unsafe_arena_set_allocated_start(
    ::kiapi::common::types::Vector2* start) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_);
  }
  start_ = start;
  if (start) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kiapi.common.types.ArcStartMidEnd.start)
}
inline ::kiapi::common::types::Vector2* ArcStartMidEnd::release_start() {
  
  ::kiapi::common::types::Vector2* temp = start_;
  start_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kiapi::common::types::Vector2* ArcStartMidEnd::unsafe_arena_release_start() {
  // @@protoc_insertion_point(field_release:kiapi.common.types.ArcStartMidEnd.start)
  
  ::kiapi::common::types::Vector2* temp = start_;
  start_ = nullptr;
  return temp;
}
inline ::kiapi::common::types::Vector2* ArcStartMidEnd::_internal_mutable_start() {
  
  if (start_ == nullptr) {
    auto* p = CreateMaybeMessage<::kiapi::common::types::Vector2>(GetArenaForAllocation());
    start_ = p;
  }
  return start_;
}
inline ::kiapi::common::types::Vector2* ArcStartMidEnd::mutable_start() {
  ::kiapi::common::types::Vector2* _msg = _internal_mutable_start();
  // @@protoc_insertion_point(field_mutable:kiapi.common.types.ArcStartMidEnd.start)
  return _msg;
}
inline void ArcStartMidEnd::set_allocated_start(::kiapi::common::types::Vector2* start) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete start_;
  }
  if (start) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::kiapi::common::types::Vector2>::GetOwningArena(start);
    if (message_arena != submessage_arena) {
      start = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, start, submessage_arena);
    }
    
  } else {
    
  }
  start_ = start;
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.types.ArcStartMidEnd.start)
}

// .kiapi.common.types.Vector2 mid = 2;
inline bool ArcStartMidEnd::_internal_has_mid() const {
  return this != internal_default_instance() && mid_ != nullptr;
}
inline bool ArcStartMidEnd::has_mid() const {
  return _internal_has_mid();
}
inline void ArcStartMidEnd::clear_mid() {
  if (GetArenaForAllocation() == nullptr && mid_ != nullptr) {
    delete mid_;
  }
  mid_ = nullptr;
}
inline const ::kiapi::common::types::Vector2& ArcStartMidEnd::_internal_mid() const {
  const ::kiapi::common::types::Vector2* p = mid_;
  return p != nullptr ? *p : reinterpret_cast<const ::kiapi::common::types::Vector2&>(
      ::kiapi::common::types::_Vector2_default_instance_);
}
inline const ::kiapi::common::types::Vector2& ArcStartMidEnd::mid() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.ArcStartMidEnd.mid)
  return _internal_mid();
}
inline void ArcStartMidEnd::unsafe_arena_set_allocated_mid(
    ::kiapi::common::types::Vector2* mid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(mid_);
  }
  mid_ = mid;
  if (mid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kiapi.common.types.ArcStartMidEnd.mid)
}
inline ::kiapi::common::types::Vector2* ArcStartMidEnd::release_mid() {
  
  ::kiapi::common::types::Vector2* temp = mid_;
  mid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kiapi::common::types::Vector2* ArcStartMidEnd::unsafe_arena_release_mid() {
  // @@protoc_insertion_point(field_release:kiapi.common.types.ArcStartMidEnd.mid)
  
  ::kiapi::common::types::Vector2* temp = mid_;
  mid_ = nullptr;
  return temp;
}
inline ::kiapi::common::types::Vector2* ArcStartMidEnd::_internal_mutable_mid() {
  
  if (mid_ == nullptr) {
    auto* p = CreateMaybeMessage<::kiapi::common::types::Vector2>(GetArenaForAllocation());
    mid_ = p;
  }
  return mid_;
}
inline ::kiapi::common::types::Vector2* ArcStartMidEnd::mutable_mid() {
  ::kiapi::common::types::Vector2* _msg = _internal_mutable_mid();
  // @@protoc_insertion_point(field_mutable:kiapi.common.types.ArcStartMidEnd.mid)
  return _msg;
}
inline void ArcStartMidEnd::set_allocated_mid(::kiapi::common::types::Vector2* mid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete mid_;
  }
  if (mid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::kiapi::common::types::Vector2>::GetOwningArena(mid);
    if (message_arena != submessage_arena) {
      mid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mid, submessage_arena);
    }
    
  } else {
    
  }
  mid_ = mid;
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.types.ArcStartMidEnd.mid)
}

// .kiapi.common.types.Vector2 end = 3;
inline bool ArcStartMidEnd::_internal_has_end() const {
  return this != internal_default_instance() && end_ != nullptr;
}
inline bool ArcStartMidEnd::has_end() const {
  return _internal_has_end();
}
inline void ArcStartMidEnd::clear_end() {
  if (GetArenaForAllocation() == nullptr && end_ != nullptr) {
    delete end_;
  }
  end_ = nullptr;
}
inline const ::kiapi::common::types::Vector2& ArcStartMidEnd::_internal_end() const {
  const ::kiapi::common::types::Vector2* p = end_;
  return p != nullptr ? *p : reinterpret_cast<const ::kiapi::common::types::Vector2&>(
      ::kiapi::common::types::_Vector2_default_instance_);
}
inline const ::kiapi::common::types::Vector2& ArcStartMidEnd::end() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.ArcStartMidEnd.end)
  return _internal_end();
}
inline void ArcStartMidEnd::unsafe_arena_set_allocated_end(
    ::kiapi::common::types::Vector2* end) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(end_);
  }
  end_ = end;
  if (end) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kiapi.common.types.ArcStartMidEnd.end)
}
inline ::kiapi::common::types::Vector2* ArcStartMidEnd::release_end() {
  
  ::kiapi::common::types::Vector2* temp = end_;
  end_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kiapi::common::types::Vector2* ArcStartMidEnd::unsafe_arena_release_end() {
  // @@protoc_insertion_point(field_release:kiapi.common.types.ArcStartMidEnd.end)
  
  ::kiapi::common::types::Vector2* temp = end_;
  end_ = nullptr;
  return temp;
}
inline ::kiapi::common::types::Vector2* ArcStartMidEnd::_internal_mutable_end() {
  
  if (end_ == nullptr) {
    auto* p = CreateMaybeMessage<::kiapi::common::types::Vector2>(GetArenaForAllocation());
    end_ = p;
  }
  return end_;
}
inline ::kiapi::common::types::Vector2* ArcStartMidEnd::mutable_end() {
  ::kiapi::common::types::Vector2* _msg = _internal_mutable_end();
  // @@protoc_insertion_point(field_mutable:kiapi.common.types.ArcStartMidEnd.end)
  return _msg;
}
inline void ArcStartMidEnd::set_allocated_end(::kiapi::common::types::Vector2* end) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete end_;
  }
  if (end) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::kiapi::common::types::Vector2>::GetOwningArena(end);
    if (message_arena != submessage_arena) {
      end = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, end, submessage_arena);
    }
    
  } else {
    
  }
  end_ = end;
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.types.ArcStartMidEnd.end)
}

// -------------------------------------------------------------------

// PolyLineNode

// .kiapi.common.types.Vector2 point = 1;
inline bool PolyLineNode::_internal_has_point() const {
  return geometry_case() == kPoint;
}
inline bool PolyLineNode::has_point() const {
  return _internal_has_point();
}
inline void PolyLineNode::set_has_point() {
  _oneof_case_[0] = kPoint;
}
inline void PolyLineNode::clear_point() {
  if (_internal_has_point()) {
    if (GetArenaForAllocation() == nullptr) {
      delete geometry_.point_;
    }
    clear_has_geometry();
  }
}
inline ::kiapi::common::types::Vector2* PolyLineNode::release_point() {
  // @@protoc_insertion_point(field_release:kiapi.common.types.PolyLineNode.point)
  if (_internal_has_point()) {
    clear_has_geometry();
      ::kiapi::common::types::Vector2* temp = geometry_.point_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    geometry_.point_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kiapi::common::types::Vector2& PolyLineNode::_internal_point() const {
  return _internal_has_point()
      ? *geometry_.point_
      : reinterpret_cast< ::kiapi::common::types::Vector2&>(::kiapi::common::types::_Vector2_default_instance_);
}
inline const ::kiapi::common::types::Vector2& PolyLineNode::point() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.PolyLineNode.point)
  return _internal_point();
}
inline ::kiapi::common::types::Vector2* PolyLineNode::unsafe_arena_release_point() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kiapi.common.types.PolyLineNode.point)
  if (_internal_has_point()) {
    clear_has_geometry();
    ::kiapi::common::types::Vector2* temp = geometry_.point_;
    geometry_.point_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PolyLineNode::unsafe_arena_set_allocated_point(::kiapi::common::types::Vector2* point) {
  clear_geometry();
  if (point) {
    set_has_point();
    geometry_.point_ = point;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kiapi.common.types.PolyLineNode.point)
}
inline ::kiapi::common::types::Vector2* PolyLineNode::_internal_mutable_point() {
  if (!_internal_has_point()) {
    clear_geometry();
    set_has_point();
    geometry_.point_ = CreateMaybeMessage< ::kiapi::common::types::Vector2 >(GetArenaForAllocation());
  }
  return geometry_.point_;
}
inline ::kiapi::common::types::Vector2* PolyLineNode::mutable_point() {
  ::kiapi::common::types::Vector2* _msg = _internal_mutable_point();
  // @@protoc_insertion_point(field_mutable:kiapi.common.types.PolyLineNode.point)
  return _msg;
}

// .kiapi.common.types.ArcStartMidEnd arc = 2;
inline bool PolyLineNode::_internal_has_arc() const {
  return geometry_case() == kArc;
}
inline bool PolyLineNode::has_arc() const {
  return _internal_has_arc();
}
inline void PolyLineNode::set_has_arc() {
  _oneof_case_[0] = kArc;
}
inline void PolyLineNode::clear_arc() {
  if (_internal_has_arc()) {
    if (GetArenaForAllocation() == nullptr) {
      delete geometry_.arc_;
    }
    clear_has_geometry();
  }
}
inline ::kiapi::common::types::ArcStartMidEnd* PolyLineNode::release_arc() {
  // @@protoc_insertion_point(field_release:kiapi.common.types.PolyLineNode.arc)
  if (_internal_has_arc()) {
    clear_has_geometry();
      ::kiapi::common::types::ArcStartMidEnd* temp = geometry_.arc_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    geometry_.arc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kiapi::common::types::ArcStartMidEnd& PolyLineNode::_internal_arc() const {
  return _internal_has_arc()
      ? *geometry_.arc_
      : reinterpret_cast< ::kiapi::common::types::ArcStartMidEnd&>(::kiapi::common::types::_ArcStartMidEnd_default_instance_);
}
inline const ::kiapi::common::types::ArcStartMidEnd& PolyLineNode::arc() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.PolyLineNode.arc)
  return _internal_arc();
}
inline ::kiapi::common::types::ArcStartMidEnd* PolyLineNode::unsafe_arena_release_arc() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kiapi.common.types.PolyLineNode.arc)
  if (_internal_has_arc()) {
    clear_has_geometry();
    ::kiapi::common::types::ArcStartMidEnd* temp = geometry_.arc_;
    geometry_.arc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PolyLineNode::unsafe_arena_set_allocated_arc(::kiapi::common::types::ArcStartMidEnd* arc) {
  clear_geometry();
  if (arc) {
    set_has_arc();
    geometry_.arc_ = arc;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kiapi.common.types.PolyLineNode.arc)
}
inline ::kiapi::common::types::ArcStartMidEnd* PolyLineNode::_internal_mutable_arc() {
  if (!_internal_has_arc()) {
    clear_geometry();
    set_has_arc();
    geometry_.arc_ = CreateMaybeMessage< ::kiapi::common::types::ArcStartMidEnd >(GetArenaForAllocation());
  }
  return geometry_.arc_;
}
inline ::kiapi::common::types::ArcStartMidEnd* PolyLineNode::mutable_arc() {
  ::kiapi::common::types::ArcStartMidEnd* _msg = _internal_mutable_arc();
  // @@protoc_insertion_point(field_mutable:kiapi.common.types.PolyLineNode.arc)
  return _msg;
}

inline bool PolyLineNode::has_geometry() const {
  return geometry_case() != GEOMETRY_NOT_SET;
}
inline void PolyLineNode::clear_has_geometry() {
  _oneof_case_[0] = GEOMETRY_NOT_SET;
}
inline PolyLineNode::GeometryCase PolyLineNode::geometry_case() const {
  return PolyLineNode::GeometryCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// PolyLine

// repeated .kiapi.common.types.PolyLineNode nodes = 1;
inline int PolyLine::_internal_nodes_size() const {
  return nodes_.size();
}
inline int PolyLine::nodes_size() const {
  return _internal_nodes_size();
}
inline void PolyLine::clear_nodes() {
  nodes_.Clear();
}
inline ::kiapi::common::types::PolyLineNode* PolyLine::mutable_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:kiapi.common.types.PolyLine.nodes)
  return nodes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::types::PolyLineNode >*
PolyLine::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:kiapi.common.types.PolyLine.nodes)
  return &nodes_;
}
inline const ::kiapi::common::types::PolyLineNode& PolyLine::_internal_nodes(int index) const {
  return nodes_.Get(index);
}
inline const ::kiapi::common::types::PolyLineNode& PolyLine::nodes(int index) const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.PolyLine.nodes)
  return _internal_nodes(index);
}
inline ::kiapi::common::types::PolyLineNode* PolyLine::_internal_add_nodes() {
  return nodes_.Add();
}
inline ::kiapi::common::types::PolyLineNode* PolyLine::add_nodes() {
  ::kiapi::common::types::PolyLineNode* _add = _internal_add_nodes();
  // @@protoc_insertion_point(field_add:kiapi.common.types.PolyLine.nodes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::types::PolyLineNode >&
PolyLine::nodes() const {
  // @@protoc_insertion_point(field_list:kiapi.common.types.PolyLine.nodes)
  return nodes_;
}

// bool closed = 2;
inline void PolyLine::clear_closed() {
  closed_ = false;
}
inline bool PolyLine::_internal_closed() const {
  return closed_;
}
inline bool PolyLine::closed() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.PolyLine.closed)
  return _internal_closed();
}
inline void PolyLine::_internal_set_closed(bool value) {
  
  closed_ = value;
}
inline void PolyLine::set_closed(bool value) {
  _internal_set_closed(value);
  // @@protoc_insertion_point(field_set:kiapi.common.types.PolyLine.closed)
}

// -------------------------------------------------------------------

// PolygonWithHoles

// .kiapi.common.types.PolyLine outline = 1;
inline bool PolygonWithHoles::_internal_has_outline() const {
  return this != internal_default_instance() && outline_ != nullptr;
}
inline bool PolygonWithHoles::has_outline() const {
  return _internal_has_outline();
}
inline void PolygonWithHoles::clear_outline() {
  if (GetArenaForAllocation() == nullptr && outline_ != nullptr) {
    delete outline_;
  }
  outline_ = nullptr;
}
inline const ::kiapi::common::types::PolyLine& PolygonWithHoles::_internal_outline() const {
  const ::kiapi::common::types::PolyLine* p = outline_;
  return p != nullptr ? *p : reinterpret_cast<const ::kiapi::common::types::PolyLine&>(
      ::kiapi::common::types::_PolyLine_default_instance_);
}
inline const ::kiapi::common::types::PolyLine& PolygonWithHoles::outline() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.PolygonWithHoles.outline)
  return _internal_outline();
}
inline void PolygonWithHoles::unsafe_arena_set_allocated_outline(
    ::kiapi::common::types::PolyLine* outline) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(outline_);
  }
  outline_ = outline;
  if (outline) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kiapi.common.types.PolygonWithHoles.outline)
}
inline ::kiapi::common::types::PolyLine* PolygonWithHoles::release_outline() {
  
  ::kiapi::common::types::PolyLine* temp = outline_;
  outline_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kiapi::common::types::PolyLine* PolygonWithHoles::unsafe_arena_release_outline() {
  // @@protoc_insertion_point(field_release:kiapi.common.types.PolygonWithHoles.outline)
  
  ::kiapi::common::types::PolyLine* temp = outline_;
  outline_ = nullptr;
  return temp;
}
inline ::kiapi::common::types::PolyLine* PolygonWithHoles::_internal_mutable_outline() {
  
  if (outline_ == nullptr) {
    auto* p = CreateMaybeMessage<::kiapi::common::types::PolyLine>(GetArenaForAllocation());
    outline_ = p;
  }
  return outline_;
}
inline ::kiapi::common::types::PolyLine* PolygonWithHoles::mutable_outline() {
  ::kiapi::common::types::PolyLine* _msg = _internal_mutable_outline();
  // @@protoc_insertion_point(field_mutable:kiapi.common.types.PolygonWithHoles.outline)
  return _msg;
}
inline void PolygonWithHoles::set_allocated_outline(::kiapi::common::types::PolyLine* outline) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete outline_;
  }
  if (outline) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::kiapi::common::types::PolyLine>::GetOwningArena(outline);
    if (message_arena != submessage_arena) {
      outline = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, outline, submessage_arena);
    }
    
  } else {
    
  }
  outline_ = outline;
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.types.PolygonWithHoles.outline)
}

// repeated .kiapi.common.types.PolyLine holes = 2;
inline int PolygonWithHoles::_internal_holes_size() const {
  return holes_.size();
}
inline int PolygonWithHoles::holes_size() const {
  return _internal_holes_size();
}
inline void PolygonWithHoles::clear_holes() {
  holes_.Clear();
}
inline ::kiapi::common::types::PolyLine* PolygonWithHoles::mutable_holes(int index) {
  // @@protoc_insertion_point(field_mutable:kiapi.common.types.PolygonWithHoles.holes)
  return holes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::types::PolyLine >*
PolygonWithHoles::mutable_holes() {
  // @@protoc_insertion_point(field_mutable_list:kiapi.common.types.PolygonWithHoles.holes)
  return &holes_;
}
inline const ::kiapi::common::types::PolyLine& PolygonWithHoles::_internal_holes(int index) const {
  return holes_.Get(index);
}
inline const ::kiapi::common::types::PolyLine& PolygonWithHoles::holes(int index) const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.PolygonWithHoles.holes)
  return _internal_holes(index);
}
inline ::kiapi::common::types::PolyLine* PolygonWithHoles::_internal_add_holes() {
  return holes_.Add();
}
inline ::kiapi::common::types::PolyLine* PolygonWithHoles::add_holes() {
  ::kiapi::common::types::PolyLine* _add = _internal_add_holes();
  // @@protoc_insertion_point(field_add:kiapi.common.types.PolygonWithHoles.holes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::types::PolyLine >&
PolygonWithHoles::holes() const {
  // @@protoc_insertion_point(field_list:kiapi.common.types.PolygonWithHoles.holes)
  return holes_;
}

// -------------------------------------------------------------------

// PolySet

// repeated .kiapi.common.types.PolygonWithHoles polygons = 1;
inline int PolySet::_internal_polygons_size() const {
  return polygons_.size();
}
inline int PolySet::polygons_size() const {
  return _internal_polygons_size();
}
inline void PolySet::clear_polygons() {
  polygons_.Clear();
}
inline ::kiapi::common::types::PolygonWithHoles* PolySet::mutable_polygons(int index) {
  // @@protoc_insertion_point(field_mutable:kiapi.common.types.PolySet.polygons)
  return polygons_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::types::PolygonWithHoles >*
PolySet::mutable_polygons() {
  // @@protoc_insertion_point(field_mutable_list:kiapi.common.types.PolySet.polygons)
  return &polygons_;
}
inline const ::kiapi::common::types::PolygonWithHoles& PolySet::_internal_polygons(int index) const {
  return polygons_.Get(index);
}
inline const ::kiapi::common::types::PolygonWithHoles& PolySet::polygons(int index) const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.PolySet.polygons)
  return _internal_polygons(index);
}
inline ::kiapi::common::types::PolygonWithHoles* PolySet::_internal_add_polygons() {
  return polygons_.Add();
}
inline ::kiapi::common::types::PolygonWithHoles* PolySet::add_polygons() {
  ::kiapi::common::types::PolygonWithHoles* _add = _internal_add_polygons();
  // @@protoc_insertion_point(field_add:kiapi.common.types.PolySet.polygons)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::types::PolygonWithHoles >&
PolySet::polygons() const {
  // @@protoc_insertion_point(field_list:kiapi.common.types.PolySet.polygons)
  return polygons_;
}

// -------------------------------------------------------------------

// TextAttributes

// string font_name = 1;
inline void TextAttributes::clear_font_name() {
  font_name_.ClearToEmpty();
}
inline const std::string& TextAttributes::font_name() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.TextAttributes.font_name)
  return _internal_font_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TextAttributes::set_font_name(ArgT0&& arg0, ArgT... args) {
 
 font_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kiapi.common.types.TextAttributes.font_name)
}
inline std::string* TextAttributes::mutable_font_name() {
  std::string* _s = _internal_mutable_font_name();
  // @@protoc_insertion_point(field_mutable:kiapi.common.types.TextAttributes.font_name)
  return _s;
}
inline const std::string& TextAttributes::_internal_font_name() const {
  return font_name_.Get();
}
inline void TextAttributes::_internal_set_font_name(const std::string& value) {
  
  font_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TextAttributes::_internal_mutable_font_name() {
  
  return font_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TextAttributes::release_font_name() {
  // @@protoc_insertion_point(field_release:kiapi.common.types.TextAttributes.font_name)
  return font_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TextAttributes::set_allocated_font_name(std::string* font_name) {
  if (font_name != nullptr) {
    
  } else {
    
  }
  font_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), font_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (font_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    font_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.types.TextAttributes.font_name)
}

// .kiapi.common.types.HorizontalAlignment horizontal_alignment = 2;
inline void TextAttributes::clear_horizontal_alignment() {
  horizontal_alignment_ = 0;
}
inline ::kiapi::common::types::HorizontalAlignment TextAttributes::_internal_horizontal_alignment() const {
  return static_cast< ::kiapi::common::types::HorizontalAlignment >(horizontal_alignment_);
}
inline ::kiapi::common::types::HorizontalAlignment TextAttributes::horizontal_alignment() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.TextAttributes.horizontal_alignment)
  return _internal_horizontal_alignment();
}
inline void TextAttributes::_internal_set_horizontal_alignment(::kiapi::common::types::HorizontalAlignment value) {
  
  horizontal_alignment_ = value;
}
inline void TextAttributes::set_horizontal_alignment(::kiapi::common::types::HorizontalAlignment value) {
  _internal_set_horizontal_alignment(value);
  // @@protoc_insertion_point(field_set:kiapi.common.types.TextAttributes.horizontal_alignment)
}

// .kiapi.common.types.VerticalAlignment vertical_alignment = 3;
inline void TextAttributes::clear_vertical_alignment() {
  vertical_alignment_ = 0;
}
inline ::kiapi::common::types::VerticalAlignment TextAttributes::_internal_vertical_alignment() const {
  return static_cast< ::kiapi::common::types::VerticalAlignment >(vertical_alignment_);
}
inline ::kiapi::common::types::VerticalAlignment TextAttributes::vertical_alignment() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.TextAttributes.vertical_alignment)
  return _internal_vertical_alignment();
}
inline void TextAttributes::_internal_set_vertical_alignment(::kiapi::common::types::VerticalAlignment value) {
  
  vertical_alignment_ = value;
}
inline void TextAttributes::set_vertical_alignment(::kiapi::common::types::VerticalAlignment value) {
  _internal_set_vertical_alignment(value);
  // @@protoc_insertion_point(field_set:kiapi.common.types.TextAttributes.vertical_alignment)
}

// .kiapi.common.types.Angle angle = 4;
inline bool TextAttributes::_internal_has_angle() const {
  return this != internal_default_instance() && angle_ != nullptr;
}
inline bool TextAttributes::has_angle() const {
  return _internal_has_angle();
}
inline void TextAttributes::clear_angle() {
  if (GetArenaForAllocation() == nullptr && angle_ != nullptr) {
    delete angle_;
  }
  angle_ = nullptr;
}
inline const ::kiapi::common::types::Angle& TextAttributes::_internal_angle() const {
  const ::kiapi::common::types::Angle* p = angle_;
  return p != nullptr ? *p : reinterpret_cast<const ::kiapi::common::types::Angle&>(
      ::kiapi::common::types::_Angle_default_instance_);
}
inline const ::kiapi::common::types::Angle& TextAttributes::angle() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.TextAttributes.angle)
  return _internal_angle();
}
inline void TextAttributes::unsafe_arena_set_allocated_angle(
    ::kiapi::common::types::Angle* angle) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(angle_);
  }
  angle_ = angle;
  if (angle) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kiapi.common.types.TextAttributes.angle)
}
inline ::kiapi::common::types::Angle* TextAttributes::release_angle() {
  
  ::kiapi::common::types::Angle* temp = angle_;
  angle_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kiapi::common::types::Angle* TextAttributes::unsafe_arena_release_angle() {
  // @@protoc_insertion_point(field_release:kiapi.common.types.TextAttributes.angle)
  
  ::kiapi::common::types::Angle* temp = angle_;
  angle_ = nullptr;
  return temp;
}
inline ::kiapi::common::types::Angle* TextAttributes::_internal_mutable_angle() {
  
  if (angle_ == nullptr) {
    auto* p = CreateMaybeMessage<::kiapi::common::types::Angle>(GetArenaForAllocation());
    angle_ = p;
  }
  return angle_;
}
inline ::kiapi::common::types::Angle* TextAttributes::mutable_angle() {
  ::kiapi::common::types::Angle* _msg = _internal_mutable_angle();
  // @@protoc_insertion_point(field_mutable:kiapi.common.types.TextAttributes.angle)
  return _msg;
}
inline void TextAttributes::set_allocated_angle(::kiapi::common::types::Angle* angle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete angle_;
  }
  if (angle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::kiapi::common::types::Angle>::GetOwningArena(angle);
    if (message_arena != submessage_arena) {
      angle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, angle, submessage_arena);
    }
    
  } else {
    
  }
  angle_ = angle;
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.types.TextAttributes.angle)
}

// double line_spacing = 5;
inline void TextAttributes::clear_line_spacing() {
  line_spacing_ = 0;
}
inline double TextAttributes::_internal_line_spacing() const {
  return line_spacing_;
}
inline double TextAttributes::line_spacing() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.TextAttributes.line_spacing)
  return _internal_line_spacing();
}
inline void TextAttributes::_internal_set_line_spacing(double value) {
  
  line_spacing_ = value;
}
inline void TextAttributes::set_line_spacing(double value) {
  _internal_set_line_spacing(value);
  // @@protoc_insertion_point(field_set:kiapi.common.types.TextAttributes.line_spacing)
}

// .kiapi.common.types.Distance stroke_width = 6;
inline bool TextAttributes::_internal_has_stroke_width() const {
  return this != internal_default_instance() && stroke_width_ != nullptr;
}
inline bool TextAttributes::has_stroke_width() const {
  return _internal_has_stroke_width();
}
inline void TextAttributes::clear_stroke_width() {
  if (GetArenaForAllocation() == nullptr && stroke_width_ != nullptr) {
    delete stroke_width_;
  }
  stroke_width_ = nullptr;
}
inline const ::kiapi::common::types::Distance& TextAttributes::_internal_stroke_width() const {
  const ::kiapi::common::types::Distance* p = stroke_width_;
  return p != nullptr ? *p : reinterpret_cast<const ::kiapi::common::types::Distance&>(
      ::kiapi::common::types::_Distance_default_instance_);
}
inline const ::kiapi::common::types::Distance& TextAttributes::stroke_width() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.TextAttributes.stroke_width)
  return _internal_stroke_width();
}
inline void TextAttributes::unsafe_arena_set_allocated_stroke_width(
    ::kiapi::common::types::Distance* stroke_width) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stroke_width_);
  }
  stroke_width_ = stroke_width;
  if (stroke_width) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kiapi.common.types.TextAttributes.stroke_width)
}
inline ::kiapi::common::types::Distance* TextAttributes::release_stroke_width() {
  
  ::kiapi::common::types::Distance* temp = stroke_width_;
  stroke_width_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kiapi::common::types::Distance* TextAttributes::unsafe_arena_release_stroke_width() {
  // @@protoc_insertion_point(field_release:kiapi.common.types.TextAttributes.stroke_width)
  
  ::kiapi::common::types::Distance* temp = stroke_width_;
  stroke_width_ = nullptr;
  return temp;
}
inline ::kiapi::common::types::Distance* TextAttributes::_internal_mutable_stroke_width() {
  
  if (stroke_width_ == nullptr) {
    auto* p = CreateMaybeMessage<::kiapi::common::types::Distance>(GetArenaForAllocation());
    stroke_width_ = p;
  }
  return stroke_width_;
}
inline ::kiapi::common::types::Distance* TextAttributes::mutable_stroke_width() {
  ::kiapi::common::types::Distance* _msg = _internal_mutable_stroke_width();
  // @@protoc_insertion_point(field_mutable:kiapi.common.types.TextAttributes.stroke_width)
  return _msg;
}
inline void TextAttributes::set_allocated_stroke_width(::kiapi::common::types::Distance* stroke_width) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete stroke_width_;
  }
  if (stroke_width) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::kiapi::common::types::Distance>::GetOwningArena(stroke_width);
    if (message_arena != submessage_arena) {
      stroke_width = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stroke_width, submessage_arena);
    }
    
  } else {
    
  }
  stroke_width_ = stroke_width;
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.types.TextAttributes.stroke_width)
}

// bool italic = 7;
inline void TextAttributes::clear_italic() {
  italic_ = false;
}
inline bool TextAttributes::_internal_italic() const {
  return italic_;
}
inline bool TextAttributes::italic() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.TextAttributes.italic)
  return _internal_italic();
}
inline void TextAttributes::_internal_set_italic(bool value) {
  
  italic_ = value;
}
inline void TextAttributes::set_italic(bool value) {
  _internal_set_italic(value);
  // @@protoc_insertion_point(field_set:kiapi.common.types.TextAttributes.italic)
}

// bool bold = 8;
inline void TextAttributes::clear_bold() {
  bold_ = false;
}
inline bool TextAttributes::_internal_bold() const {
  return bold_;
}
inline bool TextAttributes::bold() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.TextAttributes.bold)
  return _internal_bold();
}
inline void TextAttributes::_internal_set_bold(bool value) {
  
  bold_ = value;
}
inline void TextAttributes::set_bold(bool value) {
  _internal_set_bold(value);
  // @@protoc_insertion_point(field_set:kiapi.common.types.TextAttributes.bold)
}

// bool underlined = 9;
inline void TextAttributes::clear_underlined() {
  underlined_ = false;
}
inline bool TextAttributes::_internal_underlined() const {
  return underlined_;
}
inline bool TextAttributes::underlined() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.TextAttributes.underlined)
  return _internal_underlined();
}
inline void TextAttributes::_internal_set_underlined(bool value) {
  
  underlined_ = value;
}
inline void TextAttributes::set_underlined(bool value) {
  _internal_set_underlined(value);
  // @@protoc_insertion_point(field_set:kiapi.common.types.TextAttributes.underlined)
}

// bool visible = 10;
inline void TextAttributes::clear_visible() {
  visible_ = false;
}
inline bool TextAttributes::_internal_visible() const {
  return visible_;
}
inline bool TextAttributes::visible() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.TextAttributes.visible)
  return _internal_visible();
}
inline void TextAttributes::_internal_set_visible(bool value) {
  
  visible_ = value;
}
inline void TextAttributes::set_visible(bool value) {
  _internal_set_visible(value);
  // @@protoc_insertion_point(field_set:kiapi.common.types.TextAttributes.visible)
}

// bool mirrored = 11;
inline void TextAttributes::clear_mirrored() {
  mirrored_ = false;
}
inline bool TextAttributes::_internal_mirrored() const {
  return mirrored_;
}
inline bool TextAttributes::mirrored() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.TextAttributes.mirrored)
  return _internal_mirrored();
}
inline void TextAttributes::_internal_set_mirrored(bool value) {
  
  mirrored_ = value;
}
inline void TextAttributes::set_mirrored(bool value) {
  _internal_set_mirrored(value);
  // @@protoc_insertion_point(field_set:kiapi.common.types.TextAttributes.mirrored)
}

// bool multiline = 12;
inline void TextAttributes::clear_multiline() {
  multiline_ = false;
}
inline bool TextAttributes::_internal_multiline() const {
  return multiline_;
}
inline bool TextAttributes::multiline() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.TextAttributes.multiline)
  return _internal_multiline();
}
inline void TextAttributes::_internal_set_multiline(bool value) {
  
  multiline_ = value;
}
inline void TextAttributes::set_multiline(bool value) {
  _internal_set_multiline(value);
  // @@protoc_insertion_point(field_set:kiapi.common.types.TextAttributes.multiline)
}

// bool keep_upright = 13;
inline void TextAttributes::clear_keep_upright() {
  keep_upright_ = false;
}
inline bool TextAttributes::_internal_keep_upright() const {
  return keep_upright_;
}
inline bool TextAttributes::keep_upright() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.TextAttributes.keep_upright)
  return _internal_keep_upright();
}
inline void TextAttributes::_internal_set_keep_upright(bool value) {
  
  keep_upright_ = value;
}
inline void TextAttributes::set_keep_upright(bool value) {
  _internal_set_keep_upright(value);
  // @@protoc_insertion_point(field_set:kiapi.common.types.TextAttributes.keep_upright)
}

// .kiapi.common.types.Vector2 size = 14;
inline bool TextAttributes::_internal_has_size() const {
  return this != internal_default_instance() && size_ != nullptr;
}
inline bool TextAttributes::has_size() const {
  return _internal_has_size();
}
inline void TextAttributes::clear_size() {
  if (GetArenaForAllocation() == nullptr && size_ != nullptr) {
    delete size_;
  }
  size_ = nullptr;
}
inline const ::kiapi::common::types::Vector2& TextAttributes::_internal_size() const {
  const ::kiapi::common::types::Vector2* p = size_;
  return p != nullptr ? *p : reinterpret_cast<const ::kiapi::common::types::Vector2&>(
      ::kiapi::common::types::_Vector2_default_instance_);
}
inline const ::kiapi::common::types::Vector2& TextAttributes::size() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.TextAttributes.size)
  return _internal_size();
}
inline void TextAttributes::unsafe_arena_set_allocated_size(
    ::kiapi::common::types::Vector2* size) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(size_);
  }
  size_ = size;
  if (size) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kiapi.common.types.TextAttributes.size)
}
inline ::kiapi::common::types::Vector2* TextAttributes::release_size() {
  
  ::kiapi::common::types::Vector2* temp = size_;
  size_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kiapi::common::types::Vector2* TextAttributes::unsafe_arena_release_size() {
  // @@protoc_insertion_point(field_release:kiapi.common.types.TextAttributes.size)
  
  ::kiapi::common::types::Vector2* temp = size_;
  size_ = nullptr;
  return temp;
}
inline ::kiapi::common::types::Vector2* TextAttributes::_internal_mutable_size() {
  
  if (size_ == nullptr) {
    auto* p = CreateMaybeMessage<::kiapi::common::types::Vector2>(GetArenaForAllocation());
    size_ = p;
  }
  return size_;
}
inline ::kiapi::common::types::Vector2* TextAttributes::mutable_size() {
  ::kiapi::common::types::Vector2* _msg = _internal_mutable_size();
  // @@protoc_insertion_point(field_mutable:kiapi.common.types.TextAttributes.size)
  return _msg;
}
inline void TextAttributes::set_allocated_size(::kiapi::common::types::Vector2* size) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete size_;
  }
  if (size) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::kiapi::common::types::Vector2>::GetOwningArena(size);
    if (message_arena != submessage_arena) {
      size = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, size, submessage_arena);
    }
    
  } else {
    
  }
  size_ = size;
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.types.TextAttributes.size)
}

// -------------------------------------------------------------------

// Text

// .kiapi.common.types.Vector2 position = 2;
inline bool Text::_internal_has_position() const {
  return this != internal_default_instance() && position_ != nullptr;
}
inline bool Text::has_position() const {
  return _internal_has_position();
}
inline void Text::clear_position() {
  if (GetArenaForAllocation() == nullptr && position_ != nullptr) {
    delete position_;
  }
  position_ = nullptr;
}
inline const ::kiapi::common::types::Vector2& Text::_internal_position() const {
  const ::kiapi::common::types::Vector2* p = position_;
  return p != nullptr ? *p : reinterpret_cast<const ::kiapi::common::types::Vector2&>(
      ::kiapi::common::types::_Vector2_default_instance_);
}
inline const ::kiapi::common::types::Vector2& Text::position() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.Text.position)
  return _internal_position();
}
inline void Text::unsafe_arena_set_allocated_position(
    ::kiapi::common::types::Vector2* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(position_);
  }
  position_ = position;
  if (position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kiapi.common.types.Text.position)
}
inline ::kiapi::common::types::Vector2* Text::release_position() {
  
  ::kiapi::common::types::Vector2* temp = position_;
  position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kiapi::common::types::Vector2* Text::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:kiapi.common.types.Text.position)
  
  ::kiapi::common::types::Vector2* temp = position_;
  position_ = nullptr;
  return temp;
}
inline ::kiapi::common::types::Vector2* Text::_internal_mutable_position() {
  
  if (position_ == nullptr) {
    auto* p = CreateMaybeMessage<::kiapi::common::types::Vector2>(GetArenaForAllocation());
    position_ = p;
  }
  return position_;
}
inline ::kiapi::common::types::Vector2* Text::mutable_position() {
  ::kiapi::common::types::Vector2* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:kiapi.common.types.Text.position)
  return _msg;
}
inline void Text::set_allocated_position(::kiapi::common::types::Vector2* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::kiapi::common::types::Vector2>::GetOwningArena(position);
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.types.Text.position)
}

// .kiapi.common.types.TextAttributes attributes = 3;
inline bool Text::_internal_has_attributes() const {
  return this != internal_default_instance() && attributes_ != nullptr;
}
inline bool Text::has_attributes() const {
  return _internal_has_attributes();
}
inline void Text::clear_attributes() {
  if (GetArenaForAllocation() == nullptr && attributes_ != nullptr) {
    delete attributes_;
  }
  attributes_ = nullptr;
}
inline const ::kiapi::common::types::TextAttributes& Text::_internal_attributes() const {
  const ::kiapi::common::types::TextAttributes* p = attributes_;
  return p != nullptr ? *p : reinterpret_cast<const ::kiapi::common::types::TextAttributes&>(
      ::kiapi::common::types::_TextAttributes_default_instance_);
}
inline const ::kiapi::common::types::TextAttributes& Text::attributes() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.Text.attributes)
  return _internal_attributes();
}
inline void Text::unsafe_arena_set_allocated_attributes(
    ::kiapi::common::types::TextAttributes* attributes) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(attributes_);
  }
  attributes_ = attributes;
  if (attributes) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kiapi.common.types.Text.attributes)
}
inline ::kiapi::common::types::TextAttributes* Text::release_attributes() {
  
  ::kiapi::common::types::TextAttributes* temp = attributes_;
  attributes_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kiapi::common::types::TextAttributes* Text::unsafe_arena_release_attributes() {
  // @@protoc_insertion_point(field_release:kiapi.common.types.Text.attributes)
  
  ::kiapi::common::types::TextAttributes* temp = attributes_;
  attributes_ = nullptr;
  return temp;
}
inline ::kiapi::common::types::TextAttributes* Text::_internal_mutable_attributes() {
  
  if (attributes_ == nullptr) {
    auto* p = CreateMaybeMessage<::kiapi::common::types::TextAttributes>(GetArenaForAllocation());
    attributes_ = p;
  }
  return attributes_;
}
inline ::kiapi::common::types::TextAttributes* Text::mutable_attributes() {
  ::kiapi::common::types::TextAttributes* _msg = _internal_mutable_attributes();
  // @@protoc_insertion_point(field_mutable:kiapi.common.types.Text.attributes)
  return _msg;
}
inline void Text::set_allocated_attributes(::kiapi::common::types::TextAttributes* attributes) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete attributes_;
  }
  if (attributes) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::kiapi::common::types::TextAttributes>::GetOwningArena(attributes);
    if (message_arena != submessage_arena) {
      attributes = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, attributes, submessage_arena);
    }
    
  } else {
    
  }
  attributes_ = attributes;
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.types.Text.attributes)
}

// string text = 5;
inline void Text::clear_text() {
  text_.ClearToEmpty();
}
inline const std::string& Text::text() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.Text.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Text::set_text(ArgT0&& arg0, ArgT... args) {
 
 text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kiapi.common.types.Text.text)
}
inline std::string* Text::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:kiapi.common.types.Text.text)
  return _s;
}
inline const std::string& Text::_internal_text() const {
  return text_.Get();
}
inline void Text::_internal_set_text(const std::string& value) {
  
  text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Text::_internal_mutable_text() {
  
  return text_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Text::release_text() {
  // @@protoc_insertion_point(field_release:kiapi.common.types.Text.text)
  return text_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Text::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  text_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), text,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (text_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    text_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.types.Text.text)
}

// string hyperlink = 6;
inline void Text::clear_hyperlink() {
  hyperlink_.ClearToEmpty();
}
inline const std::string& Text::hyperlink() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.Text.hyperlink)
  return _internal_hyperlink();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Text::set_hyperlink(ArgT0&& arg0, ArgT... args) {
 
 hyperlink_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kiapi.common.types.Text.hyperlink)
}
inline std::string* Text::mutable_hyperlink() {
  std::string* _s = _internal_mutable_hyperlink();
  // @@protoc_insertion_point(field_mutable:kiapi.common.types.Text.hyperlink)
  return _s;
}
inline const std::string& Text::_internal_hyperlink() const {
  return hyperlink_.Get();
}
inline void Text::_internal_set_hyperlink(const std::string& value) {
  
  hyperlink_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Text::_internal_mutable_hyperlink() {
  
  return hyperlink_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Text::release_hyperlink() {
  // @@protoc_insertion_point(field_release:kiapi.common.types.Text.hyperlink)
  return hyperlink_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Text::set_allocated_hyperlink(std::string* hyperlink) {
  if (hyperlink != nullptr) {
    
  } else {
    
  }
  hyperlink_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), hyperlink,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (hyperlink_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    hyperlink_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.types.Text.hyperlink)
}

// -------------------------------------------------------------------

// TextBox

// .kiapi.common.types.Vector2 top_left = 2;
inline bool TextBox::_internal_has_top_left() const {
  return this != internal_default_instance() && top_left_ != nullptr;
}
inline bool TextBox::has_top_left() const {
  return _internal_has_top_left();
}
inline void TextBox::clear_top_left() {
  if (GetArenaForAllocation() == nullptr && top_left_ != nullptr) {
    delete top_left_;
  }
  top_left_ = nullptr;
}
inline const ::kiapi::common::types::Vector2& TextBox::_internal_top_left() const {
  const ::kiapi::common::types::Vector2* p = top_left_;
  return p != nullptr ? *p : reinterpret_cast<const ::kiapi::common::types::Vector2&>(
      ::kiapi::common::types::_Vector2_default_instance_);
}
inline const ::kiapi::common::types::Vector2& TextBox::top_left() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.TextBox.top_left)
  return _internal_top_left();
}
inline void TextBox::unsafe_arena_set_allocated_top_left(
    ::kiapi::common::types::Vector2* top_left) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(top_left_);
  }
  top_left_ = top_left;
  if (top_left) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kiapi.common.types.TextBox.top_left)
}
inline ::kiapi::common::types::Vector2* TextBox::release_top_left() {
  
  ::kiapi::common::types::Vector2* temp = top_left_;
  top_left_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kiapi::common::types::Vector2* TextBox::unsafe_arena_release_top_left() {
  // @@protoc_insertion_point(field_release:kiapi.common.types.TextBox.top_left)
  
  ::kiapi::common::types::Vector2* temp = top_left_;
  top_left_ = nullptr;
  return temp;
}
inline ::kiapi::common::types::Vector2* TextBox::_internal_mutable_top_left() {
  
  if (top_left_ == nullptr) {
    auto* p = CreateMaybeMessage<::kiapi::common::types::Vector2>(GetArenaForAllocation());
    top_left_ = p;
  }
  return top_left_;
}
inline ::kiapi::common::types::Vector2* TextBox::mutable_top_left() {
  ::kiapi::common::types::Vector2* _msg = _internal_mutable_top_left();
  // @@protoc_insertion_point(field_mutable:kiapi.common.types.TextBox.top_left)
  return _msg;
}
inline void TextBox::set_allocated_top_left(::kiapi::common::types::Vector2* top_left) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete top_left_;
  }
  if (top_left) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::kiapi::common::types::Vector2>::GetOwningArena(top_left);
    if (message_arena != submessage_arena) {
      top_left = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, top_left, submessage_arena);
    }
    
  } else {
    
  }
  top_left_ = top_left;
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.types.TextBox.top_left)
}

// .kiapi.common.types.Vector2 bottom_right = 3;
inline bool TextBox::_internal_has_bottom_right() const {
  return this != internal_default_instance() && bottom_right_ != nullptr;
}
inline bool TextBox::has_bottom_right() const {
  return _internal_has_bottom_right();
}
inline void TextBox::clear_bottom_right() {
  if (GetArenaForAllocation() == nullptr && bottom_right_ != nullptr) {
    delete bottom_right_;
  }
  bottom_right_ = nullptr;
}
inline const ::kiapi::common::types::Vector2& TextBox::_internal_bottom_right() const {
  const ::kiapi::common::types::Vector2* p = bottom_right_;
  return p != nullptr ? *p : reinterpret_cast<const ::kiapi::common::types::Vector2&>(
      ::kiapi::common::types::_Vector2_default_instance_);
}
inline const ::kiapi::common::types::Vector2& TextBox::bottom_right() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.TextBox.bottom_right)
  return _internal_bottom_right();
}
inline void TextBox::unsafe_arena_set_allocated_bottom_right(
    ::kiapi::common::types::Vector2* bottom_right) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bottom_right_);
  }
  bottom_right_ = bottom_right;
  if (bottom_right) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kiapi.common.types.TextBox.bottom_right)
}
inline ::kiapi::common::types::Vector2* TextBox::release_bottom_right() {
  
  ::kiapi::common::types::Vector2* temp = bottom_right_;
  bottom_right_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kiapi::common::types::Vector2* TextBox::unsafe_arena_release_bottom_right() {
  // @@protoc_insertion_point(field_release:kiapi.common.types.TextBox.bottom_right)
  
  ::kiapi::common::types::Vector2* temp = bottom_right_;
  bottom_right_ = nullptr;
  return temp;
}
inline ::kiapi::common::types::Vector2* TextBox::_internal_mutable_bottom_right() {
  
  if (bottom_right_ == nullptr) {
    auto* p = CreateMaybeMessage<::kiapi::common::types::Vector2>(GetArenaForAllocation());
    bottom_right_ = p;
  }
  return bottom_right_;
}
inline ::kiapi::common::types::Vector2* TextBox::mutable_bottom_right() {
  ::kiapi::common::types::Vector2* _msg = _internal_mutable_bottom_right();
  // @@protoc_insertion_point(field_mutable:kiapi.common.types.TextBox.bottom_right)
  return _msg;
}
inline void TextBox::set_allocated_bottom_right(::kiapi::common::types::Vector2* bottom_right) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete bottom_right_;
  }
  if (bottom_right) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::kiapi::common::types::Vector2>::GetOwningArena(bottom_right);
    if (message_arena != submessage_arena) {
      bottom_right = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bottom_right, submessage_arena);
    }
    
  } else {
    
  }
  bottom_right_ = bottom_right;
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.types.TextBox.bottom_right)
}

// .kiapi.common.types.TextAttributes attributes = 4;
inline bool TextBox::_internal_has_attributes() const {
  return this != internal_default_instance() && attributes_ != nullptr;
}
inline bool TextBox::has_attributes() const {
  return _internal_has_attributes();
}
inline void TextBox::clear_attributes() {
  if (GetArenaForAllocation() == nullptr && attributes_ != nullptr) {
    delete attributes_;
  }
  attributes_ = nullptr;
}
inline const ::kiapi::common::types::TextAttributes& TextBox::_internal_attributes() const {
  const ::kiapi::common::types::TextAttributes* p = attributes_;
  return p != nullptr ? *p : reinterpret_cast<const ::kiapi::common::types::TextAttributes&>(
      ::kiapi::common::types::_TextAttributes_default_instance_);
}
inline const ::kiapi::common::types::TextAttributes& TextBox::attributes() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.TextBox.attributes)
  return _internal_attributes();
}
inline void TextBox::unsafe_arena_set_allocated_attributes(
    ::kiapi::common::types::TextAttributes* attributes) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(attributes_);
  }
  attributes_ = attributes;
  if (attributes) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kiapi.common.types.TextBox.attributes)
}
inline ::kiapi::common::types::TextAttributes* TextBox::release_attributes() {
  
  ::kiapi::common::types::TextAttributes* temp = attributes_;
  attributes_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kiapi::common::types::TextAttributes* TextBox::unsafe_arena_release_attributes() {
  // @@protoc_insertion_point(field_release:kiapi.common.types.TextBox.attributes)
  
  ::kiapi::common::types::TextAttributes* temp = attributes_;
  attributes_ = nullptr;
  return temp;
}
inline ::kiapi::common::types::TextAttributes* TextBox::_internal_mutable_attributes() {
  
  if (attributes_ == nullptr) {
    auto* p = CreateMaybeMessage<::kiapi::common::types::TextAttributes>(GetArenaForAllocation());
    attributes_ = p;
  }
  return attributes_;
}
inline ::kiapi::common::types::TextAttributes* TextBox::mutable_attributes() {
  ::kiapi::common::types::TextAttributes* _msg = _internal_mutable_attributes();
  // @@protoc_insertion_point(field_mutable:kiapi.common.types.TextBox.attributes)
  return _msg;
}
inline void TextBox::set_allocated_attributes(::kiapi::common::types::TextAttributes* attributes) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete attributes_;
  }
  if (attributes) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::kiapi::common::types::TextAttributes>::GetOwningArena(attributes);
    if (message_arena != submessage_arena) {
      attributes = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, attributes, submessage_arena);
    }
    
  } else {
    
  }
  attributes_ = attributes;
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.types.TextBox.attributes)
}

// string text = 6;
inline void TextBox::clear_text() {
  text_.ClearToEmpty();
}
inline const std::string& TextBox::text() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.TextBox.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TextBox::set_text(ArgT0&& arg0, ArgT... args) {
 
 text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kiapi.common.types.TextBox.text)
}
inline std::string* TextBox::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:kiapi.common.types.TextBox.text)
  return _s;
}
inline const std::string& TextBox::_internal_text() const {
  return text_.Get();
}
inline void TextBox::_internal_set_text(const std::string& value) {
  
  text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TextBox::_internal_mutable_text() {
  
  return text_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TextBox::release_text() {
  // @@protoc_insertion_point(field_release:kiapi.common.types.TextBox.text)
  return text_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TextBox::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  text_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), text,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (text_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    text_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.types.TextBox.text)
}

// -------------------------------------------------------------------

// StrokeAttributes

// .kiapi.common.types.Distance width = 1;
inline bool StrokeAttributes::_internal_has_width() const {
  return this != internal_default_instance() && width_ != nullptr;
}
inline bool StrokeAttributes::has_width() const {
  return _internal_has_width();
}
inline void StrokeAttributes::clear_width() {
  if (GetArenaForAllocation() == nullptr && width_ != nullptr) {
    delete width_;
  }
  width_ = nullptr;
}
inline const ::kiapi::common::types::Distance& StrokeAttributes::_internal_width() const {
  const ::kiapi::common::types::Distance* p = width_;
  return p != nullptr ? *p : reinterpret_cast<const ::kiapi::common::types::Distance&>(
      ::kiapi::common::types::_Distance_default_instance_);
}
inline const ::kiapi::common::types::Distance& StrokeAttributes::width() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.StrokeAttributes.width)
  return _internal_width();
}
inline void StrokeAttributes::unsafe_arena_set_allocated_width(
    ::kiapi::common::types::Distance* width) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(width_);
  }
  width_ = width;
  if (width) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kiapi.common.types.StrokeAttributes.width)
}
inline ::kiapi::common::types::Distance* StrokeAttributes::release_width() {
  
  ::kiapi::common::types::Distance* temp = width_;
  width_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kiapi::common::types::Distance* StrokeAttributes::unsafe_arena_release_width() {
  // @@protoc_insertion_point(field_release:kiapi.common.types.StrokeAttributes.width)
  
  ::kiapi::common::types::Distance* temp = width_;
  width_ = nullptr;
  return temp;
}
inline ::kiapi::common::types::Distance* StrokeAttributes::_internal_mutable_width() {
  
  if (width_ == nullptr) {
    auto* p = CreateMaybeMessage<::kiapi::common::types::Distance>(GetArenaForAllocation());
    width_ = p;
  }
  return width_;
}
inline ::kiapi::common::types::Distance* StrokeAttributes::mutable_width() {
  ::kiapi::common::types::Distance* _msg = _internal_mutable_width();
  // @@protoc_insertion_point(field_mutable:kiapi.common.types.StrokeAttributes.width)
  return _msg;
}
inline void StrokeAttributes::set_allocated_width(::kiapi::common::types::Distance* width) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete width_;
  }
  if (width) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::kiapi::common::types::Distance>::GetOwningArena(width);
    if (message_arena != submessage_arena) {
      width = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, width, submessage_arena);
    }
    
  } else {
    
  }
  width_ = width;
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.types.StrokeAttributes.width)
}

// .kiapi.common.types.StrokeLineStyle style = 2;
inline void StrokeAttributes::clear_style() {
  style_ = 0;
}
inline ::kiapi::common::types::StrokeLineStyle StrokeAttributes::_internal_style() const {
  return static_cast< ::kiapi::common::types::StrokeLineStyle >(style_);
}
inline ::kiapi::common::types::StrokeLineStyle StrokeAttributes::style() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.StrokeAttributes.style)
  return _internal_style();
}
inline void StrokeAttributes::_internal_set_style(::kiapi::common::types::StrokeLineStyle value) {
  
  style_ = value;
}
inline void StrokeAttributes::set_style(::kiapi::common::types::StrokeLineStyle value) {
  _internal_set_style(value);
  // @@protoc_insertion_point(field_set:kiapi.common.types.StrokeAttributes.style)
}

// .kiapi.common.types.Color color = 3;
inline bool StrokeAttributes::_internal_has_color() const {
  return this != internal_default_instance() && color_ != nullptr;
}
inline bool StrokeAttributes::has_color() const {
  return _internal_has_color();
}
inline void StrokeAttributes::clear_color() {
  if (GetArenaForAllocation() == nullptr && color_ != nullptr) {
    delete color_;
  }
  color_ = nullptr;
}
inline const ::kiapi::common::types::Color& StrokeAttributes::_internal_color() const {
  const ::kiapi::common::types::Color* p = color_;
  return p != nullptr ? *p : reinterpret_cast<const ::kiapi::common::types::Color&>(
      ::kiapi::common::types::_Color_default_instance_);
}
inline const ::kiapi::common::types::Color& StrokeAttributes::color() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.StrokeAttributes.color)
  return _internal_color();
}
inline void StrokeAttributes::unsafe_arena_set_allocated_color(
    ::kiapi::common::types::Color* color) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(color_);
  }
  color_ = color;
  if (color) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kiapi.common.types.StrokeAttributes.color)
}
inline ::kiapi::common::types::Color* StrokeAttributes::release_color() {
  
  ::kiapi::common::types::Color* temp = color_;
  color_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kiapi::common::types::Color* StrokeAttributes::unsafe_arena_release_color() {
  // @@protoc_insertion_point(field_release:kiapi.common.types.StrokeAttributes.color)
  
  ::kiapi::common::types::Color* temp = color_;
  color_ = nullptr;
  return temp;
}
inline ::kiapi::common::types::Color* StrokeAttributes::_internal_mutable_color() {
  
  if (color_ == nullptr) {
    auto* p = CreateMaybeMessage<::kiapi::common::types::Color>(GetArenaForAllocation());
    color_ = p;
  }
  return color_;
}
inline ::kiapi::common::types::Color* StrokeAttributes::mutable_color() {
  ::kiapi::common::types::Color* _msg = _internal_mutable_color();
  // @@protoc_insertion_point(field_mutable:kiapi.common.types.StrokeAttributes.color)
  return _msg;
}
inline void StrokeAttributes::set_allocated_color(::kiapi::common::types::Color* color) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete color_;
  }
  if (color) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::kiapi::common::types::Color>::GetOwningArena(color);
    if (message_arena != submessage_arena) {
      color = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, color, submessage_arena);
    }
    
  } else {
    
  }
  color_ = color;
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.types.StrokeAttributes.color)
}

// -------------------------------------------------------------------

// GraphicFillAttributes

// .kiapi.common.types.GraphicFillType fill_type = 1;
inline void GraphicFillAttributes::clear_fill_type() {
  fill_type_ = 0;
}
inline ::kiapi::common::types::GraphicFillType GraphicFillAttributes::_internal_fill_type() const {
  return static_cast< ::kiapi::common::types::GraphicFillType >(fill_type_);
}
inline ::kiapi::common::types::GraphicFillType GraphicFillAttributes::fill_type() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.GraphicFillAttributes.fill_type)
  return _internal_fill_type();
}
inline void GraphicFillAttributes::_internal_set_fill_type(::kiapi::common::types::GraphicFillType value) {
  
  fill_type_ = value;
}
inline void GraphicFillAttributes::set_fill_type(::kiapi::common::types::GraphicFillType value) {
  _internal_set_fill_type(value);
  // @@protoc_insertion_point(field_set:kiapi.common.types.GraphicFillAttributes.fill_type)
}

// .kiapi.common.types.Color color = 2;
inline bool GraphicFillAttributes::_internal_has_color() const {
  return this != internal_default_instance() && color_ != nullptr;
}
inline bool GraphicFillAttributes::has_color() const {
  return _internal_has_color();
}
inline void GraphicFillAttributes::clear_color() {
  if (GetArenaForAllocation() == nullptr && color_ != nullptr) {
    delete color_;
  }
  color_ = nullptr;
}
inline const ::kiapi::common::types::Color& GraphicFillAttributes::_internal_color() const {
  const ::kiapi::common::types::Color* p = color_;
  return p != nullptr ? *p : reinterpret_cast<const ::kiapi::common::types::Color&>(
      ::kiapi::common::types::_Color_default_instance_);
}
inline const ::kiapi::common::types::Color& GraphicFillAttributes::color() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.GraphicFillAttributes.color)
  return _internal_color();
}
inline void GraphicFillAttributes::unsafe_arena_set_allocated_color(
    ::kiapi::common::types::Color* color) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(color_);
  }
  color_ = color;
  if (color) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kiapi.common.types.GraphicFillAttributes.color)
}
inline ::kiapi::common::types::Color* GraphicFillAttributes::release_color() {
  
  ::kiapi::common::types::Color* temp = color_;
  color_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kiapi::common::types::Color* GraphicFillAttributes::unsafe_arena_release_color() {
  // @@protoc_insertion_point(field_release:kiapi.common.types.GraphicFillAttributes.color)
  
  ::kiapi::common::types::Color* temp = color_;
  color_ = nullptr;
  return temp;
}
inline ::kiapi::common::types::Color* GraphicFillAttributes::_internal_mutable_color() {
  
  if (color_ == nullptr) {
    auto* p = CreateMaybeMessage<::kiapi::common::types::Color>(GetArenaForAllocation());
    color_ = p;
  }
  return color_;
}
inline ::kiapi::common::types::Color* GraphicFillAttributes::mutable_color() {
  ::kiapi::common::types::Color* _msg = _internal_mutable_color();
  // @@protoc_insertion_point(field_mutable:kiapi.common.types.GraphicFillAttributes.color)
  return _msg;
}
inline void GraphicFillAttributes::set_allocated_color(::kiapi::common::types::Color* color) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete color_;
  }
  if (color) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::kiapi::common::types::Color>::GetOwningArena(color);
    if (message_arena != submessage_arena) {
      color = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, color, submessage_arena);
    }
    
  } else {
    
  }
  color_ = color;
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.types.GraphicFillAttributes.color)
}

// -------------------------------------------------------------------

// GraphicAttributes

// .kiapi.common.types.StrokeAttributes stroke = 1;
inline bool GraphicAttributes::_internal_has_stroke() const {
  return this != internal_default_instance() && stroke_ != nullptr;
}
inline bool GraphicAttributes::has_stroke() const {
  return _internal_has_stroke();
}
inline void GraphicAttributes::clear_stroke() {
  if (GetArenaForAllocation() == nullptr && stroke_ != nullptr) {
    delete stroke_;
  }
  stroke_ = nullptr;
}
inline const ::kiapi::common::types::StrokeAttributes& GraphicAttributes::_internal_stroke() const {
  const ::kiapi::common::types::StrokeAttributes* p = stroke_;
  return p != nullptr ? *p : reinterpret_cast<const ::kiapi::common::types::StrokeAttributes&>(
      ::kiapi::common::types::_StrokeAttributes_default_instance_);
}
inline const ::kiapi::common::types::StrokeAttributes& GraphicAttributes::stroke() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.GraphicAttributes.stroke)
  return _internal_stroke();
}
inline void GraphicAttributes::unsafe_arena_set_allocated_stroke(
    ::kiapi::common::types::StrokeAttributes* stroke) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stroke_);
  }
  stroke_ = stroke;
  if (stroke) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kiapi.common.types.GraphicAttributes.stroke)
}
inline ::kiapi::common::types::StrokeAttributes* GraphicAttributes::release_stroke() {
  
  ::kiapi::common::types::StrokeAttributes* temp = stroke_;
  stroke_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kiapi::common::types::StrokeAttributes* GraphicAttributes::unsafe_arena_release_stroke() {
  // @@protoc_insertion_point(field_release:kiapi.common.types.GraphicAttributes.stroke)
  
  ::kiapi::common::types::StrokeAttributes* temp = stroke_;
  stroke_ = nullptr;
  return temp;
}
inline ::kiapi::common::types::StrokeAttributes* GraphicAttributes::_internal_mutable_stroke() {
  
  if (stroke_ == nullptr) {
    auto* p = CreateMaybeMessage<::kiapi::common::types::StrokeAttributes>(GetArenaForAllocation());
    stroke_ = p;
  }
  return stroke_;
}
inline ::kiapi::common::types::StrokeAttributes* GraphicAttributes::mutable_stroke() {
  ::kiapi::common::types::StrokeAttributes* _msg = _internal_mutable_stroke();
  // @@protoc_insertion_point(field_mutable:kiapi.common.types.GraphicAttributes.stroke)
  return _msg;
}
inline void GraphicAttributes::set_allocated_stroke(::kiapi::common::types::StrokeAttributes* stroke) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete stroke_;
  }
  if (stroke) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::kiapi::common::types::StrokeAttributes>::GetOwningArena(stroke);
    if (message_arena != submessage_arena) {
      stroke = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stroke, submessage_arena);
    }
    
  } else {
    
  }
  stroke_ = stroke;
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.types.GraphicAttributes.stroke)
}

// .kiapi.common.types.GraphicFillAttributes fill = 2;
inline bool GraphicAttributes::_internal_has_fill() const {
  return this != internal_default_instance() && fill_ != nullptr;
}
inline bool GraphicAttributes::has_fill() const {
  return _internal_has_fill();
}
inline void GraphicAttributes::clear_fill() {
  if (GetArenaForAllocation() == nullptr && fill_ != nullptr) {
    delete fill_;
  }
  fill_ = nullptr;
}
inline const ::kiapi::common::types::GraphicFillAttributes& GraphicAttributes::_internal_fill() const {
  const ::kiapi::common::types::GraphicFillAttributes* p = fill_;
  return p != nullptr ? *p : reinterpret_cast<const ::kiapi::common::types::GraphicFillAttributes&>(
      ::kiapi::common::types::_GraphicFillAttributes_default_instance_);
}
inline const ::kiapi::common::types::GraphicFillAttributes& GraphicAttributes::fill() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.GraphicAttributes.fill)
  return _internal_fill();
}
inline void GraphicAttributes::unsafe_arena_set_allocated_fill(
    ::kiapi::common::types::GraphicFillAttributes* fill) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fill_);
  }
  fill_ = fill;
  if (fill) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kiapi.common.types.GraphicAttributes.fill)
}
inline ::kiapi::common::types::GraphicFillAttributes* GraphicAttributes::release_fill() {
  
  ::kiapi::common::types::GraphicFillAttributes* temp = fill_;
  fill_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kiapi::common::types::GraphicFillAttributes* GraphicAttributes::unsafe_arena_release_fill() {
  // @@protoc_insertion_point(field_release:kiapi.common.types.GraphicAttributes.fill)
  
  ::kiapi::common::types::GraphicFillAttributes* temp = fill_;
  fill_ = nullptr;
  return temp;
}
inline ::kiapi::common::types::GraphicFillAttributes* GraphicAttributes::_internal_mutable_fill() {
  
  if (fill_ == nullptr) {
    auto* p = CreateMaybeMessage<::kiapi::common::types::GraphicFillAttributes>(GetArenaForAllocation());
    fill_ = p;
  }
  return fill_;
}
inline ::kiapi::common::types::GraphicFillAttributes* GraphicAttributes::mutable_fill() {
  ::kiapi::common::types::GraphicFillAttributes* _msg = _internal_mutable_fill();
  // @@protoc_insertion_point(field_mutable:kiapi.common.types.GraphicAttributes.fill)
  return _msg;
}
inline void GraphicAttributes::set_allocated_fill(::kiapi::common::types::GraphicFillAttributes* fill) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete fill_;
  }
  if (fill) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::kiapi::common::types::GraphicFillAttributes>::GetOwningArena(fill);
    if (message_arena != submessage_arena) {
      fill = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fill, submessage_arena);
    }
    
  } else {
    
  }
  fill_ = fill;
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.types.GraphicAttributes.fill)
}

// -------------------------------------------------------------------

// GraphicSegmentAttributes

// .kiapi.common.types.Vector2 start = 1;
inline bool GraphicSegmentAttributes::_internal_has_start() const {
  return this != internal_default_instance() && start_ != nullptr;
}
inline bool GraphicSegmentAttributes::has_start() const {
  return _internal_has_start();
}
inline void GraphicSegmentAttributes::clear_start() {
  if (GetArenaForAllocation() == nullptr && start_ != nullptr) {
    delete start_;
  }
  start_ = nullptr;
}
inline const ::kiapi::common::types::Vector2& GraphicSegmentAttributes::_internal_start() const {
  const ::kiapi::common::types::Vector2* p = start_;
  return p != nullptr ? *p : reinterpret_cast<const ::kiapi::common::types::Vector2&>(
      ::kiapi::common::types::_Vector2_default_instance_);
}
inline const ::kiapi::common::types::Vector2& GraphicSegmentAttributes::start() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.GraphicSegmentAttributes.start)
  return _internal_start();
}
inline void GraphicSegmentAttributes::unsafe_arena_set_allocated_start(
    ::kiapi::common::types::Vector2* start) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_);
  }
  start_ = start;
  if (start) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kiapi.common.types.GraphicSegmentAttributes.start)
}
inline ::kiapi::common::types::Vector2* GraphicSegmentAttributes::release_start() {
  
  ::kiapi::common::types::Vector2* temp = start_;
  start_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kiapi::common::types::Vector2* GraphicSegmentAttributes::unsafe_arena_release_start() {
  // @@protoc_insertion_point(field_release:kiapi.common.types.GraphicSegmentAttributes.start)
  
  ::kiapi::common::types::Vector2* temp = start_;
  start_ = nullptr;
  return temp;
}
inline ::kiapi::common::types::Vector2* GraphicSegmentAttributes::_internal_mutable_start() {
  
  if (start_ == nullptr) {
    auto* p = CreateMaybeMessage<::kiapi::common::types::Vector2>(GetArenaForAllocation());
    start_ = p;
  }
  return start_;
}
inline ::kiapi::common::types::Vector2* GraphicSegmentAttributes::mutable_start() {
  ::kiapi::common::types::Vector2* _msg = _internal_mutable_start();
  // @@protoc_insertion_point(field_mutable:kiapi.common.types.GraphicSegmentAttributes.start)
  return _msg;
}
inline void GraphicSegmentAttributes::set_allocated_start(::kiapi::common::types::Vector2* start) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete start_;
  }
  if (start) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::kiapi::common::types::Vector2>::GetOwningArena(start);
    if (message_arena != submessage_arena) {
      start = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, start, submessage_arena);
    }
    
  } else {
    
  }
  start_ = start;
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.types.GraphicSegmentAttributes.start)
}

// .kiapi.common.types.Vector2 end = 2;
inline bool GraphicSegmentAttributes::_internal_has_end() const {
  return this != internal_default_instance() && end_ != nullptr;
}
inline bool GraphicSegmentAttributes::has_end() const {
  return _internal_has_end();
}
inline void GraphicSegmentAttributes::clear_end() {
  if (GetArenaForAllocation() == nullptr && end_ != nullptr) {
    delete end_;
  }
  end_ = nullptr;
}
inline const ::kiapi::common::types::Vector2& GraphicSegmentAttributes::_internal_end() const {
  const ::kiapi::common::types::Vector2* p = end_;
  return p != nullptr ? *p : reinterpret_cast<const ::kiapi::common::types::Vector2&>(
      ::kiapi::common::types::_Vector2_default_instance_);
}
inline const ::kiapi::common::types::Vector2& GraphicSegmentAttributes::end() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.GraphicSegmentAttributes.end)
  return _internal_end();
}
inline void GraphicSegmentAttributes::unsafe_arena_set_allocated_end(
    ::kiapi::common::types::Vector2* end) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(end_);
  }
  end_ = end;
  if (end) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kiapi.common.types.GraphicSegmentAttributes.end)
}
inline ::kiapi::common::types::Vector2* GraphicSegmentAttributes::release_end() {
  
  ::kiapi::common::types::Vector2* temp = end_;
  end_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kiapi::common::types::Vector2* GraphicSegmentAttributes::unsafe_arena_release_end() {
  // @@protoc_insertion_point(field_release:kiapi.common.types.GraphicSegmentAttributes.end)
  
  ::kiapi::common::types::Vector2* temp = end_;
  end_ = nullptr;
  return temp;
}
inline ::kiapi::common::types::Vector2* GraphicSegmentAttributes::_internal_mutable_end() {
  
  if (end_ == nullptr) {
    auto* p = CreateMaybeMessage<::kiapi::common::types::Vector2>(GetArenaForAllocation());
    end_ = p;
  }
  return end_;
}
inline ::kiapi::common::types::Vector2* GraphicSegmentAttributes::mutable_end() {
  ::kiapi::common::types::Vector2* _msg = _internal_mutable_end();
  // @@protoc_insertion_point(field_mutable:kiapi.common.types.GraphicSegmentAttributes.end)
  return _msg;
}
inline void GraphicSegmentAttributes::set_allocated_end(::kiapi::common::types::Vector2* end) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete end_;
  }
  if (end) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::kiapi::common::types::Vector2>::GetOwningArena(end);
    if (message_arena != submessage_arena) {
      end = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, end, submessage_arena);
    }
    
  } else {
    
  }
  end_ = end;
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.types.GraphicSegmentAttributes.end)
}

// -------------------------------------------------------------------

// GraphicRectangleAttributes

// .kiapi.common.types.Vector2 top_left = 1;
inline bool GraphicRectangleAttributes::_internal_has_top_left() const {
  return this != internal_default_instance() && top_left_ != nullptr;
}
inline bool GraphicRectangleAttributes::has_top_left() const {
  return _internal_has_top_left();
}
inline void GraphicRectangleAttributes::clear_top_left() {
  if (GetArenaForAllocation() == nullptr && top_left_ != nullptr) {
    delete top_left_;
  }
  top_left_ = nullptr;
}
inline const ::kiapi::common::types::Vector2& GraphicRectangleAttributes::_internal_top_left() const {
  const ::kiapi::common::types::Vector2* p = top_left_;
  return p != nullptr ? *p : reinterpret_cast<const ::kiapi::common::types::Vector2&>(
      ::kiapi::common::types::_Vector2_default_instance_);
}
inline const ::kiapi::common::types::Vector2& GraphicRectangleAttributes::top_left() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.GraphicRectangleAttributes.top_left)
  return _internal_top_left();
}
inline void GraphicRectangleAttributes::unsafe_arena_set_allocated_top_left(
    ::kiapi::common::types::Vector2* top_left) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(top_left_);
  }
  top_left_ = top_left;
  if (top_left) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kiapi.common.types.GraphicRectangleAttributes.top_left)
}
inline ::kiapi::common::types::Vector2* GraphicRectangleAttributes::release_top_left() {
  
  ::kiapi::common::types::Vector2* temp = top_left_;
  top_left_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kiapi::common::types::Vector2* GraphicRectangleAttributes::unsafe_arena_release_top_left() {
  // @@protoc_insertion_point(field_release:kiapi.common.types.GraphicRectangleAttributes.top_left)
  
  ::kiapi::common::types::Vector2* temp = top_left_;
  top_left_ = nullptr;
  return temp;
}
inline ::kiapi::common::types::Vector2* GraphicRectangleAttributes::_internal_mutable_top_left() {
  
  if (top_left_ == nullptr) {
    auto* p = CreateMaybeMessage<::kiapi::common::types::Vector2>(GetArenaForAllocation());
    top_left_ = p;
  }
  return top_left_;
}
inline ::kiapi::common::types::Vector2* GraphicRectangleAttributes::mutable_top_left() {
  ::kiapi::common::types::Vector2* _msg = _internal_mutable_top_left();
  // @@protoc_insertion_point(field_mutable:kiapi.common.types.GraphicRectangleAttributes.top_left)
  return _msg;
}
inline void GraphicRectangleAttributes::set_allocated_top_left(::kiapi::common::types::Vector2* top_left) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete top_left_;
  }
  if (top_left) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::kiapi::common::types::Vector2>::GetOwningArena(top_left);
    if (message_arena != submessage_arena) {
      top_left = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, top_left, submessage_arena);
    }
    
  } else {
    
  }
  top_left_ = top_left;
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.types.GraphicRectangleAttributes.top_left)
}

// .kiapi.common.types.Vector2 bottom_right = 2;
inline bool GraphicRectangleAttributes::_internal_has_bottom_right() const {
  return this != internal_default_instance() && bottom_right_ != nullptr;
}
inline bool GraphicRectangleAttributes::has_bottom_right() const {
  return _internal_has_bottom_right();
}
inline void GraphicRectangleAttributes::clear_bottom_right() {
  if (GetArenaForAllocation() == nullptr && bottom_right_ != nullptr) {
    delete bottom_right_;
  }
  bottom_right_ = nullptr;
}
inline const ::kiapi::common::types::Vector2& GraphicRectangleAttributes::_internal_bottom_right() const {
  const ::kiapi::common::types::Vector2* p = bottom_right_;
  return p != nullptr ? *p : reinterpret_cast<const ::kiapi::common::types::Vector2&>(
      ::kiapi::common::types::_Vector2_default_instance_);
}
inline const ::kiapi::common::types::Vector2& GraphicRectangleAttributes::bottom_right() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.GraphicRectangleAttributes.bottom_right)
  return _internal_bottom_right();
}
inline void GraphicRectangleAttributes::unsafe_arena_set_allocated_bottom_right(
    ::kiapi::common::types::Vector2* bottom_right) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bottom_right_);
  }
  bottom_right_ = bottom_right;
  if (bottom_right) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kiapi.common.types.GraphicRectangleAttributes.bottom_right)
}
inline ::kiapi::common::types::Vector2* GraphicRectangleAttributes::release_bottom_right() {
  
  ::kiapi::common::types::Vector2* temp = bottom_right_;
  bottom_right_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kiapi::common::types::Vector2* GraphicRectangleAttributes::unsafe_arena_release_bottom_right() {
  // @@protoc_insertion_point(field_release:kiapi.common.types.GraphicRectangleAttributes.bottom_right)
  
  ::kiapi::common::types::Vector2* temp = bottom_right_;
  bottom_right_ = nullptr;
  return temp;
}
inline ::kiapi::common::types::Vector2* GraphicRectangleAttributes::_internal_mutable_bottom_right() {
  
  if (bottom_right_ == nullptr) {
    auto* p = CreateMaybeMessage<::kiapi::common::types::Vector2>(GetArenaForAllocation());
    bottom_right_ = p;
  }
  return bottom_right_;
}
inline ::kiapi::common::types::Vector2* GraphicRectangleAttributes::mutable_bottom_right() {
  ::kiapi::common::types::Vector2* _msg = _internal_mutable_bottom_right();
  // @@protoc_insertion_point(field_mutable:kiapi.common.types.GraphicRectangleAttributes.bottom_right)
  return _msg;
}
inline void GraphicRectangleAttributes::set_allocated_bottom_right(::kiapi::common::types::Vector2* bottom_right) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete bottom_right_;
  }
  if (bottom_right) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::kiapi::common::types::Vector2>::GetOwningArena(bottom_right);
    if (message_arena != submessage_arena) {
      bottom_right = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bottom_right, submessage_arena);
    }
    
  } else {
    
  }
  bottom_right_ = bottom_right;
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.types.GraphicRectangleAttributes.bottom_right)
}

// -------------------------------------------------------------------

// GraphicArcAttributes

// .kiapi.common.types.Vector2 start = 1;
inline bool GraphicArcAttributes::_internal_has_start() const {
  return this != internal_default_instance() && start_ != nullptr;
}
inline bool GraphicArcAttributes::has_start() const {
  return _internal_has_start();
}
inline void GraphicArcAttributes::clear_start() {
  if (GetArenaForAllocation() == nullptr && start_ != nullptr) {
    delete start_;
  }
  start_ = nullptr;
}
inline const ::kiapi::common::types::Vector2& GraphicArcAttributes::_internal_start() const {
  const ::kiapi::common::types::Vector2* p = start_;
  return p != nullptr ? *p : reinterpret_cast<const ::kiapi::common::types::Vector2&>(
      ::kiapi::common::types::_Vector2_default_instance_);
}
inline const ::kiapi::common::types::Vector2& GraphicArcAttributes::start() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.GraphicArcAttributes.start)
  return _internal_start();
}
inline void GraphicArcAttributes::unsafe_arena_set_allocated_start(
    ::kiapi::common::types::Vector2* start) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_);
  }
  start_ = start;
  if (start) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kiapi.common.types.GraphicArcAttributes.start)
}
inline ::kiapi::common::types::Vector2* GraphicArcAttributes::release_start() {
  
  ::kiapi::common::types::Vector2* temp = start_;
  start_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kiapi::common::types::Vector2* GraphicArcAttributes::unsafe_arena_release_start() {
  // @@protoc_insertion_point(field_release:kiapi.common.types.GraphicArcAttributes.start)
  
  ::kiapi::common::types::Vector2* temp = start_;
  start_ = nullptr;
  return temp;
}
inline ::kiapi::common::types::Vector2* GraphicArcAttributes::_internal_mutable_start() {
  
  if (start_ == nullptr) {
    auto* p = CreateMaybeMessage<::kiapi::common::types::Vector2>(GetArenaForAllocation());
    start_ = p;
  }
  return start_;
}
inline ::kiapi::common::types::Vector2* GraphicArcAttributes::mutable_start() {
  ::kiapi::common::types::Vector2* _msg = _internal_mutable_start();
  // @@protoc_insertion_point(field_mutable:kiapi.common.types.GraphicArcAttributes.start)
  return _msg;
}
inline void GraphicArcAttributes::set_allocated_start(::kiapi::common::types::Vector2* start) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete start_;
  }
  if (start) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::kiapi::common::types::Vector2>::GetOwningArena(start);
    if (message_arena != submessage_arena) {
      start = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, start, submessage_arena);
    }
    
  } else {
    
  }
  start_ = start;
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.types.GraphicArcAttributes.start)
}

// .kiapi.common.types.Vector2 mid = 2;
inline bool GraphicArcAttributes::_internal_has_mid() const {
  return this != internal_default_instance() && mid_ != nullptr;
}
inline bool GraphicArcAttributes::has_mid() const {
  return _internal_has_mid();
}
inline void GraphicArcAttributes::clear_mid() {
  if (GetArenaForAllocation() == nullptr && mid_ != nullptr) {
    delete mid_;
  }
  mid_ = nullptr;
}
inline const ::kiapi::common::types::Vector2& GraphicArcAttributes::_internal_mid() const {
  const ::kiapi::common::types::Vector2* p = mid_;
  return p != nullptr ? *p : reinterpret_cast<const ::kiapi::common::types::Vector2&>(
      ::kiapi::common::types::_Vector2_default_instance_);
}
inline const ::kiapi::common::types::Vector2& GraphicArcAttributes::mid() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.GraphicArcAttributes.mid)
  return _internal_mid();
}
inline void GraphicArcAttributes::unsafe_arena_set_allocated_mid(
    ::kiapi::common::types::Vector2* mid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(mid_);
  }
  mid_ = mid;
  if (mid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kiapi.common.types.GraphicArcAttributes.mid)
}
inline ::kiapi::common::types::Vector2* GraphicArcAttributes::release_mid() {
  
  ::kiapi::common::types::Vector2* temp = mid_;
  mid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kiapi::common::types::Vector2* GraphicArcAttributes::unsafe_arena_release_mid() {
  // @@protoc_insertion_point(field_release:kiapi.common.types.GraphicArcAttributes.mid)
  
  ::kiapi::common::types::Vector2* temp = mid_;
  mid_ = nullptr;
  return temp;
}
inline ::kiapi::common::types::Vector2* GraphicArcAttributes::_internal_mutable_mid() {
  
  if (mid_ == nullptr) {
    auto* p = CreateMaybeMessage<::kiapi::common::types::Vector2>(GetArenaForAllocation());
    mid_ = p;
  }
  return mid_;
}
inline ::kiapi::common::types::Vector2* GraphicArcAttributes::mutable_mid() {
  ::kiapi::common::types::Vector2* _msg = _internal_mutable_mid();
  // @@protoc_insertion_point(field_mutable:kiapi.common.types.GraphicArcAttributes.mid)
  return _msg;
}
inline void GraphicArcAttributes::set_allocated_mid(::kiapi::common::types::Vector2* mid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete mid_;
  }
  if (mid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::kiapi::common::types::Vector2>::GetOwningArena(mid);
    if (message_arena != submessage_arena) {
      mid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mid, submessage_arena);
    }
    
  } else {
    
  }
  mid_ = mid;
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.types.GraphicArcAttributes.mid)
}

// .kiapi.common.types.Vector2 end = 3;
inline bool GraphicArcAttributes::_internal_has_end() const {
  return this != internal_default_instance() && end_ != nullptr;
}
inline bool GraphicArcAttributes::has_end() const {
  return _internal_has_end();
}
inline void GraphicArcAttributes::clear_end() {
  if (GetArenaForAllocation() == nullptr && end_ != nullptr) {
    delete end_;
  }
  end_ = nullptr;
}
inline const ::kiapi::common::types::Vector2& GraphicArcAttributes::_internal_end() const {
  const ::kiapi::common::types::Vector2* p = end_;
  return p != nullptr ? *p : reinterpret_cast<const ::kiapi::common::types::Vector2&>(
      ::kiapi::common::types::_Vector2_default_instance_);
}
inline const ::kiapi::common::types::Vector2& GraphicArcAttributes::end() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.GraphicArcAttributes.end)
  return _internal_end();
}
inline void GraphicArcAttributes::unsafe_arena_set_allocated_end(
    ::kiapi::common::types::Vector2* end) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(end_);
  }
  end_ = end;
  if (end) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kiapi.common.types.GraphicArcAttributes.end)
}
inline ::kiapi::common::types::Vector2* GraphicArcAttributes::release_end() {
  
  ::kiapi::common::types::Vector2* temp = end_;
  end_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kiapi::common::types::Vector2* GraphicArcAttributes::unsafe_arena_release_end() {
  // @@protoc_insertion_point(field_release:kiapi.common.types.GraphicArcAttributes.end)
  
  ::kiapi::common::types::Vector2* temp = end_;
  end_ = nullptr;
  return temp;
}
inline ::kiapi::common::types::Vector2* GraphicArcAttributes::_internal_mutable_end() {
  
  if (end_ == nullptr) {
    auto* p = CreateMaybeMessage<::kiapi::common::types::Vector2>(GetArenaForAllocation());
    end_ = p;
  }
  return end_;
}
inline ::kiapi::common::types::Vector2* GraphicArcAttributes::mutable_end() {
  ::kiapi::common::types::Vector2* _msg = _internal_mutable_end();
  // @@protoc_insertion_point(field_mutable:kiapi.common.types.GraphicArcAttributes.end)
  return _msg;
}
inline void GraphicArcAttributes::set_allocated_end(::kiapi::common::types::Vector2* end) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete end_;
  }
  if (end) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::kiapi::common::types::Vector2>::GetOwningArena(end);
    if (message_arena != submessage_arena) {
      end = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, end, submessage_arena);
    }
    
  } else {
    
  }
  end_ = end;
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.types.GraphicArcAttributes.end)
}

// -------------------------------------------------------------------

// GraphicCircleAttributes

// .kiapi.common.types.Vector2 center = 1;
inline bool GraphicCircleAttributes::_internal_has_center() const {
  return this != internal_default_instance() && center_ != nullptr;
}
inline bool GraphicCircleAttributes::has_center() const {
  return _internal_has_center();
}
inline void GraphicCircleAttributes::clear_center() {
  if (GetArenaForAllocation() == nullptr && center_ != nullptr) {
    delete center_;
  }
  center_ = nullptr;
}
inline const ::kiapi::common::types::Vector2& GraphicCircleAttributes::_internal_center() const {
  const ::kiapi::common::types::Vector2* p = center_;
  return p != nullptr ? *p : reinterpret_cast<const ::kiapi::common::types::Vector2&>(
      ::kiapi::common::types::_Vector2_default_instance_);
}
inline const ::kiapi::common::types::Vector2& GraphicCircleAttributes::center() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.GraphicCircleAttributes.center)
  return _internal_center();
}
inline void GraphicCircleAttributes::unsafe_arena_set_allocated_center(
    ::kiapi::common::types::Vector2* center) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(center_);
  }
  center_ = center;
  if (center) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kiapi.common.types.GraphicCircleAttributes.center)
}
inline ::kiapi::common::types::Vector2* GraphicCircleAttributes::release_center() {
  
  ::kiapi::common::types::Vector2* temp = center_;
  center_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kiapi::common::types::Vector2* GraphicCircleAttributes::unsafe_arena_release_center() {
  // @@protoc_insertion_point(field_release:kiapi.common.types.GraphicCircleAttributes.center)
  
  ::kiapi::common::types::Vector2* temp = center_;
  center_ = nullptr;
  return temp;
}
inline ::kiapi::common::types::Vector2* GraphicCircleAttributes::_internal_mutable_center() {
  
  if (center_ == nullptr) {
    auto* p = CreateMaybeMessage<::kiapi::common::types::Vector2>(GetArenaForAllocation());
    center_ = p;
  }
  return center_;
}
inline ::kiapi::common::types::Vector2* GraphicCircleAttributes::mutable_center() {
  ::kiapi::common::types::Vector2* _msg = _internal_mutable_center();
  // @@protoc_insertion_point(field_mutable:kiapi.common.types.GraphicCircleAttributes.center)
  return _msg;
}
inline void GraphicCircleAttributes::set_allocated_center(::kiapi::common::types::Vector2* center) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete center_;
  }
  if (center) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::kiapi::common::types::Vector2>::GetOwningArena(center);
    if (message_arena != submessage_arena) {
      center = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, center, submessage_arena);
    }
    
  } else {
    
  }
  center_ = center;
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.types.GraphicCircleAttributes.center)
}

// .kiapi.common.types.Vector2 radius_point = 2;
inline bool GraphicCircleAttributes::_internal_has_radius_point() const {
  return this != internal_default_instance() && radius_point_ != nullptr;
}
inline bool GraphicCircleAttributes::has_radius_point() const {
  return _internal_has_radius_point();
}
inline void GraphicCircleAttributes::clear_radius_point() {
  if (GetArenaForAllocation() == nullptr && radius_point_ != nullptr) {
    delete radius_point_;
  }
  radius_point_ = nullptr;
}
inline const ::kiapi::common::types::Vector2& GraphicCircleAttributes::_internal_radius_point() const {
  const ::kiapi::common::types::Vector2* p = radius_point_;
  return p != nullptr ? *p : reinterpret_cast<const ::kiapi::common::types::Vector2&>(
      ::kiapi::common::types::_Vector2_default_instance_);
}
inline const ::kiapi::common::types::Vector2& GraphicCircleAttributes::radius_point() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.GraphicCircleAttributes.radius_point)
  return _internal_radius_point();
}
inline void GraphicCircleAttributes::unsafe_arena_set_allocated_radius_point(
    ::kiapi::common::types::Vector2* radius_point) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(radius_point_);
  }
  radius_point_ = radius_point;
  if (radius_point) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kiapi.common.types.GraphicCircleAttributes.radius_point)
}
inline ::kiapi::common::types::Vector2* GraphicCircleAttributes::release_radius_point() {
  
  ::kiapi::common::types::Vector2* temp = radius_point_;
  radius_point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kiapi::common::types::Vector2* GraphicCircleAttributes::unsafe_arena_release_radius_point() {
  // @@protoc_insertion_point(field_release:kiapi.common.types.GraphicCircleAttributes.radius_point)
  
  ::kiapi::common::types::Vector2* temp = radius_point_;
  radius_point_ = nullptr;
  return temp;
}
inline ::kiapi::common::types::Vector2* GraphicCircleAttributes::_internal_mutable_radius_point() {
  
  if (radius_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::kiapi::common::types::Vector2>(GetArenaForAllocation());
    radius_point_ = p;
  }
  return radius_point_;
}
inline ::kiapi::common::types::Vector2* GraphicCircleAttributes::mutable_radius_point() {
  ::kiapi::common::types::Vector2* _msg = _internal_mutable_radius_point();
  // @@protoc_insertion_point(field_mutable:kiapi.common.types.GraphicCircleAttributes.radius_point)
  return _msg;
}
inline void GraphicCircleAttributes::set_allocated_radius_point(::kiapi::common::types::Vector2* radius_point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete radius_point_;
  }
  if (radius_point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::kiapi::common::types::Vector2>::GetOwningArena(radius_point);
    if (message_arena != submessage_arena) {
      radius_point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, radius_point, submessage_arena);
    }
    
  } else {
    
  }
  radius_point_ = radius_point;
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.types.GraphicCircleAttributes.radius_point)
}

// -------------------------------------------------------------------

// GraphicBezierAttributes

// .kiapi.common.types.Vector2 start = 1;
inline bool GraphicBezierAttributes::_internal_has_start() const {
  return this != internal_default_instance() && start_ != nullptr;
}
inline bool GraphicBezierAttributes::has_start() const {
  return _internal_has_start();
}
inline void GraphicBezierAttributes::clear_start() {
  if (GetArenaForAllocation() == nullptr && start_ != nullptr) {
    delete start_;
  }
  start_ = nullptr;
}
inline const ::kiapi::common::types::Vector2& GraphicBezierAttributes::_internal_start() const {
  const ::kiapi::common::types::Vector2* p = start_;
  return p != nullptr ? *p : reinterpret_cast<const ::kiapi::common::types::Vector2&>(
      ::kiapi::common::types::_Vector2_default_instance_);
}
inline const ::kiapi::common::types::Vector2& GraphicBezierAttributes::start() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.GraphicBezierAttributes.start)
  return _internal_start();
}
inline void GraphicBezierAttributes::unsafe_arena_set_allocated_start(
    ::kiapi::common::types::Vector2* start) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_);
  }
  start_ = start;
  if (start) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kiapi.common.types.GraphicBezierAttributes.start)
}
inline ::kiapi::common::types::Vector2* GraphicBezierAttributes::release_start() {
  
  ::kiapi::common::types::Vector2* temp = start_;
  start_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kiapi::common::types::Vector2* GraphicBezierAttributes::unsafe_arena_release_start() {
  // @@protoc_insertion_point(field_release:kiapi.common.types.GraphicBezierAttributes.start)
  
  ::kiapi::common::types::Vector2* temp = start_;
  start_ = nullptr;
  return temp;
}
inline ::kiapi::common::types::Vector2* GraphicBezierAttributes::_internal_mutable_start() {
  
  if (start_ == nullptr) {
    auto* p = CreateMaybeMessage<::kiapi::common::types::Vector2>(GetArenaForAllocation());
    start_ = p;
  }
  return start_;
}
inline ::kiapi::common::types::Vector2* GraphicBezierAttributes::mutable_start() {
  ::kiapi::common::types::Vector2* _msg = _internal_mutable_start();
  // @@protoc_insertion_point(field_mutable:kiapi.common.types.GraphicBezierAttributes.start)
  return _msg;
}
inline void GraphicBezierAttributes::set_allocated_start(::kiapi::common::types::Vector2* start) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete start_;
  }
  if (start) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::kiapi::common::types::Vector2>::GetOwningArena(start);
    if (message_arena != submessage_arena) {
      start = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, start, submessage_arena);
    }
    
  } else {
    
  }
  start_ = start;
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.types.GraphicBezierAttributes.start)
}

// .kiapi.common.types.Vector2 control1 = 2;
inline bool GraphicBezierAttributes::_internal_has_control1() const {
  return this != internal_default_instance() && control1_ != nullptr;
}
inline bool GraphicBezierAttributes::has_control1() const {
  return _internal_has_control1();
}
inline void GraphicBezierAttributes::clear_control1() {
  if (GetArenaForAllocation() == nullptr && control1_ != nullptr) {
    delete control1_;
  }
  control1_ = nullptr;
}
inline const ::kiapi::common::types::Vector2& GraphicBezierAttributes::_internal_control1() const {
  const ::kiapi::common::types::Vector2* p = control1_;
  return p != nullptr ? *p : reinterpret_cast<const ::kiapi::common::types::Vector2&>(
      ::kiapi::common::types::_Vector2_default_instance_);
}
inline const ::kiapi::common::types::Vector2& GraphicBezierAttributes::control1() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.GraphicBezierAttributes.control1)
  return _internal_control1();
}
inline void GraphicBezierAttributes::unsafe_arena_set_allocated_control1(
    ::kiapi::common::types::Vector2* control1) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(control1_);
  }
  control1_ = control1;
  if (control1) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kiapi.common.types.GraphicBezierAttributes.control1)
}
inline ::kiapi::common::types::Vector2* GraphicBezierAttributes::release_control1() {
  
  ::kiapi::common::types::Vector2* temp = control1_;
  control1_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kiapi::common::types::Vector2* GraphicBezierAttributes::unsafe_arena_release_control1() {
  // @@protoc_insertion_point(field_release:kiapi.common.types.GraphicBezierAttributes.control1)
  
  ::kiapi::common::types::Vector2* temp = control1_;
  control1_ = nullptr;
  return temp;
}
inline ::kiapi::common::types::Vector2* GraphicBezierAttributes::_internal_mutable_control1() {
  
  if (control1_ == nullptr) {
    auto* p = CreateMaybeMessage<::kiapi::common::types::Vector2>(GetArenaForAllocation());
    control1_ = p;
  }
  return control1_;
}
inline ::kiapi::common::types::Vector2* GraphicBezierAttributes::mutable_control1() {
  ::kiapi::common::types::Vector2* _msg = _internal_mutable_control1();
  // @@protoc_insertion_point(field_mutable:kiapi.common.types.GraphicBezierAttributes.control1)
  return _msg;
}
inline void GraphicBezierAttributes::set_allocated_control1(::kiapi::common::types::Vector2* control1) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete control1_;
  }
  if (control1) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::kiapi::common::types::Vector2>::GetOwningArena(control1);
    if (message_arena != submessage_arena) {
      control1 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, control1, submessage_arena);
    }
    
  } else {
    
  }
  control1_ = control1;
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.types.GraphicBezierAttributes.control1)
}

// .kiapi.common.types.Vector2 control2 = 3;
inline bool GraphicBezierAttributes::_internal_has_control2() const {
  return this != internal_default_instance() && control2_ != nullptr;
}
inline bool GraphicBezierAttributes::has_control2() const {
  return _internal_has_control2();
}
inline void GraphicBezierAttributes::clear_control2() {
  if (GetArenaForAllocation() == nullptr && control2_ != nullptr) {
    delete control2_;
  }
  control2_ = nullptr;
}
inline const ::kiapi::common::types::Vector2& GraphicBezierAttributes::_internal_control2() const {
  const ::kiapi::common::types::Vector2* p = control2_;
  return p != nullptr ? *p : reinterpret_cast<const ::kiapi::common::types::Vector2&>(
      ::kiapi::common::types::_Vector2_default_instance_);
}
inline const ::kiapi::common::types::Vector2& GraphicBezierAttributes::control2() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.GraphicBezierAttributes.control2)
  return _internal_control2();
}
inline void GraphicBezierAttributes::unsafe_arena_set_allocated_control2(
    ::kiapi::common::types::Vector2* control2) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(control2_);
  }
  control2_ = control2;
  if (control2) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kiapi.common.types.GraphicBezierAttributes.control2)
}
inline ::kiapi::common::types::Vector2* GraphicBezierAttributes::release_control2() {
  
  ::kiapi::common::types::Vector2* temp = control2_;
  control2_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kiapi::common::types::Vector2* GraphicBezierAttributes::unsafe_arena_release_control2() {
  // @@protoc_insertion_point(field_release:kiapi.common.types.GraphicBezierAttributes.control2)
  
  ::kiapi::common::types::Vector2* temp = control2_;
  control2_ = nullptr;
  return temp;
}
inline ::kiapi::common::types::Vector2* GraphicBezierAttributes::_internal_mutable_control2() {
  
  if (control2_ == nullptr) {
    auto* p = CreateMaybeMessage<::kiapi::common::types::Vector2>(GetArenaForAllocation());
    control2_ = p;
  }
  return control2_;
}
inline ::kiapi::common::types::Vector2* GraphicBezierAttributes::mutable_control2() {
  ::kiapi::common::types::Vector2* _msg = _internal_mutable_control2();
  // @@protoc_insertion_point(field_mutable:kiapi.common.types.GraphicBezierAttributes.control2)
  return _msg;
}
inline void GraphicBezierAttributes::set_allocated_control2(::kiapi::common::types::Vector2* control2) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete control2_;
  }
  if (control2) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::kiapi::common::types::Vector2>::GetOwningArena(control2);
    if (message_arena != submessage_arena) {
      control2 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, control2, submessage_arena);
    }
    
  } else {
    
  }
  control2_ = control2;
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.types.GraphicBezierAttributes.control2)
}

// .kiapi.common.types.Vector2 end = 4;
inline bool GraphicBezierAttributes::_internal_has_end() const {
  return this != internal_default_instance() && end_ != nullptr;
}
inline bool GraphicBezierAttributes::has_end() const {
  return _internal_has_end();
}
inline void GraphicBezierAttributes::clear_end() {
  if (GetArenaForAllocation() == nullptr && end_ != nullptr) {
    delete end_;
  }
  end_ = nullptr;
}
inline const ::kiapi::common::types::Vector2& GraphicBezierAttributes::_internal_end() const {
  const ::kiapi::common::types::Vector2* p = end_;
  return p != nullptr ? *p : reinterpret_cast<const ::kiapi::common::types::Vector2&>(
      ::kiapi::common::types::_Vector2_default_instance_);
}
inline const ::kiapi::common::types::Vector2& GraphicBezierAttributes::end() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.GraphicBezierAttributes.end)
  return _internal_end();
}
inline void GraphicBezierAttributes::unsafe_arena_set_allocated_end(
    ::kiapi::common::types::Vector2* end) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(end_);
  }
  end_ = end;
  if (end) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kiapi.common.types.GraphicBezierAttributes.end)
}
inline ::kiapi::common::types::Vector2* GraphicBezierAttributes::release_end() {
  
  ::kiapi::common::types::Vector2* temp = end_;
  end_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kiapi::common::types::Vector2* GraphicBezierAttributes::unsafe_arena_release_end() {
  // @@protoc_insertion_point(field_release:kiapi.common.types.GraphicBezierAttributes.end)
  
  ::kiapi::common::types::Vector2* temp = end_;
  end_ = nullptr;
  return temp;
}
inline ::kiapi::common::types::Vector2* GraphicBezierAttributes::_internal_mutable_end() {
  
  if (end_ == nullptr) {
    auto* p = CreateMaybeMessage<::kiapi::common::types::Vector2>(GetArenaForAllocation());
    end_ = p;
  }
  return end_;
}
inline ::kiapi::common::types::Vector2* GraphicBezierAttributes::mutable_end() {
  ::kiapi::common::types::Vector2* _msg = _internal_mutable_end();
  // @@protoc_insertion_point(field_mutable:kiapi.common.types.GraphicBezierAttributes.end)
  return _msg;
}
inline void GraphicBezierAttributes::set_allocated_end(::kiapi::common::types::Vector2* end) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete end_;
  }
  if (end) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::kiapi::common::types::Vector2>::GetOwningArena(end);
    if (message_arena != submessage_arena) {
      end = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, end, submessage_arena);
    }
    
  } else {
    
  }
  end_ = end;
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.types.GraphicBezierAttributes.end)
}

// -------------------------------------------------------------------

// GraphicShape

// .kiapi.common.types.GraphicAttributes attributes = 3;
inline bool GraphicShape::_internal_has_attributes() const {
  return this != internal_default_instance() && attributes_ != nullptr;
}
inline bool GraphicShape::has_attributes() const {
  return _internal_has_attributes();
}
inline void GraphicShape::clear_attributes() {
  if (GetArenaForAllocation() == nullptr && attributes_ != nullptr) {
    delete attributes_;
  }
  attributes_ = nullptr;
}
inline const ::kiapi::common::types::GraphicAttributes& GraphicShape::_internal_attributes() const {
  const ::kiapi::common::types::GraphicAttributes* p = attributes_;
  return p != nullptr ? *p : reinterpret_cast<const ::kiapi::common::types::GraphicAttributes&>(
      ::kiapi::common::types::_GraphicAttributes_default_instance_);
}
inline const ::kiapi::common::types::GraphicAttributes& GraphicShape::attributes() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.GraphicShape.attributes)
  return _internal_attributes();
}
inline void GraphicShape::unsafe_arena_set_allocated_attributes(
    ::kiapi::common::types::GraphicAttributes* attributes) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(attributes_);
  }
  attributes_ = attributes;
  if (attributes) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kiapi.common.types.GraphicShape.attributes)
}
inline ::kiapi::common::types::GraphicAttributes* GraphicShape::release_attributes() {
  
  ::kiapi::common::types::GraphicAttributes* temp = attributes_;
  attributes_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kiapi::common::types::GraphicAttributes* GraphicShape::unsafe_arena_release_attributes() {
  // @@protoc_insertion_point(field_release:kiapi.common.types.GraphicShape.attributes)
  
  ::kiapi::common::types::GraphicAttributes* temp = attributes_;
  attributes_ = nullptr;
  return temp;
}
inline ::kiapi::common::types::GraphicAttributes* GraphicShape::_internal_mutable_attributes() {
  
  if (attributes_ == nullptr) {
    auto* p = CreateMaybeMessage<::kiapi::common::types::GraphicAttributes>(GetArenaForAllocation());
    attributes_ = p;
  }
  return attributes_;
}
inline ::kiapi::common::types::GraphicAttributes* GraphicShape::mutable_attributes() {
  ::kiapi::common::types::GraphicAttributes* _msg = _internal_mutable_attributes();
  // @@protoc_insertion_point(field_mutable:kiapi.common.types.GraphicShape.attributes)
  return _msg;
}
inline void GraphicShape::set_allocated_attributes(::kiapi::common::types::GraphicAttributes* attributes) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete attributes_;
  }
  if (attributes) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::kiapi::common::types::GraphicAttributes>::GetOwningArena(attributes);
    if (message_arena != submessage_arena) {
      attributes = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, attributes, submessage_arena);
    }
    
  } else {
    
  }
  attributes_ = attributes;
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.types.GraphicShape.attributes)
}

// .kiapi.common.types.GraphicSegmentAttributes segment = 4;
inline bool GraphicShape::_internal_has_segment() const {
  return geometry_case() == kSegment;
}
inline bool GraphicShape::has_segment() const {
  return _internal_has_segment();
}
inline void GraphicShape::set_has_segment() {
  _oneof_case_[0] = kSegment;
}
inline void GraphicShape::clear_segment() {
  if (_internal_has_segment()) {
    if (GetArenaForAllocation() == nullptr) {
      delete geometry_.segment_;
    }
    clear_has_geometry();
  }
}
inline ::kiapi::common::types::GraphicSegmentAttributes* GraphicShape::release_segment() {
  // @@protoc_insertion_point(field_release:kiapi.common.types.GraphicShape.segment)
  if (_internal_has_segment()) {
    clear_has_geometry();
      ::kiapi::common::types::GraphicSegmentAttributes* temp = geometry_.segment_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    geometry_.segment_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kiapi::common::types::GraphicSegmentAttributes& GraphicShape::_internal_segment() const {
  return _internal_has_segment()
      ? *geometry_.segment_
      : reinterpret_cast< ::kiapi::common::types::GraphicSegmentAttributes&>(::kiapi::common::types::_GraphicSegmentAttributes_default_instance_);
}
inline const ::kiapi::common::types::GraphicSegmentAttributes& GraphicShape::segment() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.GraphicShape.segment)
  return _internal_segment();
}
inline ::kiapi::common::types::GraphicSegmentAttributes* GraphicShape::unsafe_arena_release_segment() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kiapi.common.types.GraphicShape.segment)
  if (_internal_has_segment()) {
    clear_has_geometry();
    ::kiapi::common::types::GraphicSegmentAttributes* temp = geometry_.segment_;
    geometry_.segment_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GraphicShape::unsafe_arena_set_allocated_segment(::kiapi::common::types::GraphicSegmentAttributes* segment) {
  clear_geometry();
  if (segment) {
    set_has_segment();
    geometry_.segment_ = segment;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kiapi.common.types.GraphicShape.segment)
}
inline ::kiapi::common::types::GraphicSegmentAttributes* GraphicShape::_internal_mutable_segment() {
  if (!_internal_has_segment()) {
    clear_geometry();
    set_has_segment();
    geometry_.segment_ = CreateMaybeMessage< ::kiapi::common::types::GraphicSegmentAttributes >(GetArenaForAllocation());
  }
  return geometry_.segment_;
}
inline ::kiapi::common::types::GraphicSegmentAttributes* GraphicShape::mutable_segment() {
  ::kiapi::common::types::GraphicSegmentAttributes* _msg = _internal_mutable_segment();
  // @@protoc_insertion_point(field_mutable:kiapi.common.types.GraphicShape.segment)
  return _msg;
}

// .kiapi.common.types.GraphicRectangleAttributes rectangle = 5;
inline bool GraphicShape::_internal_has_rectangle() const {
  return geometry_case() == kRectangle;
}
inline bool GraphicShape::has_rectangle() const {
  return _internal_has_rectangle();
}
inline void GraphicShape::set_has_rectangle() {
  _oneof_case_[0] = kRectangle;
}
inline void GraphicShape::clear_rectangle() {
  if (_internal_has_rectangle()) {
    if (GetArenaForAllocation() == nullptr) {
      delete geometry_.rectangle_;
    }
    clear_has_geometry();
  }
}
inline ::kiapi::common::types::GraphicRectangleAttributes* GraphicShape::release_rectangle() {
  // @@protoc_insertion_point(field_release:kiapi.common.types.GraphicShape.rectangle)
  if (_internal_has_rectangle()) {
    clear_has_geometry();
      ::kiapi::common::types::GraphicRectangleAttributes* temp = geometry_.rectangle_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    geometry_.rectangle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kiapi::common::types::GraphicRectangleAttributes& GraphicShape::_internal_rectangle() const {
  return _internal_has_rectangle()
      ? *geometry_.rectangle_
      : reinterpret_cast< ::kiapi::common::types::GraphicRectangleAttributes&>(::kiapi::common::types::_GraphicRectangleAttributes_default_instance_);
}
inline const ::kiapi::common::types::GraphicRectangleAttributes& GraphicShape::rectangle() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.GraphicShape.rectangle)
  return _internal_rectangle();
}
inline ::kiapi::common::types::GraphicRectangleAttributes* GraphicShape::unsafe_arena_release_rectangle() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kiapi.common.types.GraphicShape.rectangle)
  if (_internal_has_rectangle()) {
    clear_has_geometry();
    ::kiapi::common::types::GraphicRectangleAttributes* temp = geometry_.rectangle_;
    geometry_.rectangle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GraphicShape::unsafe_arena_set_allocated_rectangle(::kiapi::common::types::GraphicRectangleAttributes* rectangle) {
  clear_geometry();
  if (rectangle) {
    set_has_rectangle();
    geometry_.rectangle_ = rectangle;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kiapi.common.types.GraphicShape.rectangle)
}
inline ::kiapi::common::types::GraphicRectangleAttributes* GraphicShape::_internal_mutable_rectangle() {
  if (!_internal_has_rectangle()) {
    clear_geometry();
    set_has_rectangle();
    geometry_.rectangle_ = CreateMaybeMessage< ::kiapi::common::types::GraphicRectangleAttributes >(GetArenaForAllocation());
  }
  return geometry_.rectangle_;
}
inline ::kiapi::common::types::GraphicRectangleAttributes* GraphicShape::mutable_rectangle() {
  ::kiapi::common::types::GraphicRectangleAttributes* _msg = _internal_mutable_rectangle();
  // @@protoc_insertion_point(field_mutable:kiapi.common.types.GraphicShape.rectangle)
  return _msg;
}

// .kiapi.common.types.GraphicArcAttributes arc = 6;
inline bool GraphicShape::_internal_has_arc() const {
  return geometry_case() == kArc;
}
inline bool GraphicShape::has_arc() const {
  return _internal_has_arc();
}
inline void GraphicShape::set_has_arc() {
  _oneof_case_[0] = kArc;
}
inline void GraphicShape::clear_arc() {
  if (_internal_has_arc()) {
    if (GetArenaForAllocation() == nullptr) {
      delete geometry_.arc_;
    }
    clear_has_geometry();
  }
}
inline ::kiapi::common::types::GraphicArcAttributes* GraphicShape::release_arc() {
  // @@protoc_insertion_point(field_release:kiapi.common.types.GraphicShape.arc)
  if (_internal_has_arc()) {
    clear_has_geometry();
      ::kiapi::common::types::GraphicArcAttributes* temp = geometry_.arc_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    geometry_.arc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kiapi::common::types::GraphicArcAttributes& GraphicShape::_internal_arc() const {
  return _internal_has_arc()
      ? *geometry_.arc_
      : reinterpret_cast< ::kiapi::common::types::GraphicArcAttributes&>(::kiapi::common::types::_GraphicArcAttributes_default_instance_);
}
inline const ::kiapi::common::types::GraphicArcAttributes& GraphicShape::arc() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.GraphicShape.arc)
  return _internal_arc();
}
inline ::kiapi::common::types::GraphicArcAttributes* GraphicShape::unsafe_arena_release_arc() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kiapi.common.types.GraphicShape.arc)
  if (_internal_has_arc()) {
    clear_has_geometry();
    ::kiapi::common::types::GraphicArcAttributes* temp = geometry_.arc_;
    geometry_.arc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GraphicShape::unsafe_arena_set_allocated_arc(::kiapi::common::types::GraphicArcAttributes* arc) {
  clear_geometry();
  if (arc) {
    set_has_arc();
    geometry_.arc_ = arc;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kiapi.common.types.GraphicShape.arc)
}
inline ::kiapi::common::types::GraphicArcAttributes* GraphicShape::_internal_mutable_arc() {
  if (!_internal_has_arc()) {
    clear_geometry();
    set_has_arc();
    geometry_.arc_ = CreateMaybeMessage< ::kiapi::common::types::GraphicArcAttributes >(GetArenaForAllocation());
  }
  return geometry_.arc_;
}
inline ::kiapi::common::types::GraphicArcAttributes* GraphicShape::mutable_arc() {
  ::kiapi::common::types::GraphicArcAttributes* _msg = _internal_mutable_arc();
  // @@protoc_insertion_point(field_mutable:kiapi.common.types.GraphicShape.arc)
  return _msg;
}

// .kiapi.common.types.GraphicCircleAttributes circle = 7;
inline bool GraphicShape::_internal_has_circle() const {
  return geometry_case() == kCircle;
}
inline bool GraphicShape::has_circle() const {
  return _internal_has_circle();
}
inline void GraphicShape::set_has_circle() {
  _oneof_case_[0] = kCircle;
}
inline void GraphicShape::clear_circle() {
  if (_internal_has_circle()) {
    if (GetArenaForAllocation() == nullptr) {
      delete geometry_.circle_;
    }
    clear_has_geometry();
  }
}
inline ::kiapi::common::types::GraphicCircleAttributes* GraphicShape::release_circle() {
  // @@protoc_insertion_point(field_release:kiapi.common.types.GraphicShape.circle)
  if (_internal_has_circle()) {
    clear_has_geometry();
      ::kiapi::common::types::GraphicCircleAttributes* temp = geometry_.circle_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    geometry_.circle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kiapi::common::types::GraphicCircleAttributes& GraphicShape::_internal_circle() const {
  return _internal_has_circle()
      ? *geometry_.circle_
      : reinterpret_cast< ::kiapi::common::types::GraphicCircleAttributes&>(::kiapi::common::types::_GraphicCircleAttributes_default_instance_);
}
inline const ::kiapi::common::types::GraphicCircleAttributes& GraphicShape::circle() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.GraphicShape.circle)
  return _internal_circle();
}
inline ::kiapi::common::types::GraphicCircleAttributes* GraphicShape::unsafe_arena_release_circle() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kiapi.common.types.GraphicShape.circle)
  if (_internal_has_circle()) {
    clear_has_geometry();
    ::kiapi::common::types::GraphicCircleAttributes* temp = geometry_.circle_;
    geometry_.circle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GraphicShape::unsafe_arena_set_allocated_circle(::kiapi::common::types::GraphicCircleAttributes* circle) {
  clear_geometry();
  if (circle) {
    set_has_circle();
    geometry_.circle_ = circle;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kiapi.common.types.GraphicShape.circle)
}
inline ::kiapi::common::types::GraphicCircleAttributes* GraphicShape::_internal_mutable_circle() {
  if (!_internal_has_circle()) {
    clear_geometry();
    set_has_circle();
    geometry_.circle_ = CreateMaybeMessage< ::kiapi::common::types::GraphicCircleAttributes >(GetArenaForAllocation());
  }
  return geometry_.circle_;
}
inline ::kiapi::common::types::GraphicCircleAttributes* GraphicShape::mutable_circle() {
  ::kiapi::common::types::GraphicCircleAttributes* _msg = _internal_mutable_circle();
  // @@protoc_insertion_point(field_mutable:kiapi.common.types.GraphicShape.circle)
  return _msg;
}

// .kiapi.common.types.PolySet polygon = 8;
inline bool GraphicShape::_internal_has_polygon() const {
  return geometry_case() == kPolygon;
}
inline bool GraphicShape::has_polygon() const {
  return _internal_has_polygon();
}
inline void GraphicShape::set_has_polygon() {
  _oneof_case_[0] = kPolygon;
}
inline void GraphicShape::clear_polygon() {
  if (_internal_has_polygon()) {
    if (GetArenaForAllocation() == nullptr) {
      delete geometry_.polygon_;
    }
    clear_has_geometry();
  }
}
inline ::kiapi::common::types::PolySet* GraphicShape::release_polygon() {
  // @@protoc_insertion_point(field_release:kiapi.common.types.GraphicShape.polygon)
  if (_internal_has_polygon()) {
    clear_has_geometry();
      ::kiapi::common::types::PolySet* temp = geometry_.polygon_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    geometry_.polygon_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kiapi::common::types::PolySet& GraphicShape::_internal_polygon() const {
  return _internal_has_polygon()
      ? *geometry_.polygon_
      : reinterpret_cast< ::kiapi::common::types::PolySet&>(::kiapi::common::types::_PolySet_default_instance_);
}
inline const ::kiapi::common::types::PolySet& GraphicShape::polygon() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.GraphicShape.polygon)
  return _internal_polygon();
}
inline ::kiapi::common::types::PolySet* GraphicShape::unsafe_arena_release_polygon() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kiapi.common.types.GraphicShape.polygon)
  if (_internal_has_polygon()) {
    clear_has_geometry();
    ::kiapi::common::types::PolySet* temp = geometry_.polygon_;
    geometry_.polygon_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GraphicShape::unsafe_arena_set_allocated_polygon(::kiapi::common::types::PolySet* polygon) {
  clear_geometry();
  if (polygon) {
    set_has_polygon();
    geometry_.polygon_ = polygon;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kiapi.common.types.GraphicShape.polygon)
}
inline ::kiapi::common::types::PolySet* GraphicShape::_internal_mutable_polygon() {
  if (!_internal_has_polygon()) {
    clear_geometry();
    set_has_polygon();
    geometry_.polygon_ = CreateMaybeMessage< ::kiapi::common::types::PolySet >(GetArenaForAllocation());
  }
  return geometry_.polygon_;
}
inline ::kiapi::common::types::PolySet* GraphicShape::mutable_polygon() {
  ::kiapi::common::types::PolySet* _msg = _internal_mutable_polygon();
  // @@protoc_insertion_point(field_mutable:kiapi.common.types.GraphicShape.polygon)
  return _msg;
}

// .kiapi.common.types.GraphicBezierAttributes bezier = 9;
inline bool GraphicShape::_internal_has_bezier() const {
  return geometry_case() == kBezier;
}
inline bool GraphicShape::has_bezier() const {
  return _internal_has_bezier();
}
inline void GraphicShape::set_has_bezier() {
  _oneof_case_[0] = kBezier;
}
inline void GraphicShape::clear_bezier() {
  if (_internal_has_bezier()) {
    if (GetArenaForAllocation() == nullptr) {
      delete geometry_.bezier_;
    }
    clear_has_geometry();
  }
}
inline ::kiapi::common::types::GraphicBezierAttributes* GraphicShape::release_bezier() {
  // @@protoc_insertion_point(field_release:kiapi.common.types.GraphicShape.bezier)
  if (_internal_has_bezier()) {
    clear_has_geometry();
      ::kiapi::common::types::GraphicBezierAttributes* temp = geometry_.bezier_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    geometry_.bezier_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kiapi::common::types::GraphicBezierAttributes& GraphicShape::_internal_bezier() const {
  return _internal_has_bezier()
      ? *geometry_.bezier_
      : reinterpret_cast< ::kiapi::common::types::GraphicBezierAttributes&>(::kiapi::common::types::_GraphicBezierAttributes_default_instance_);
}
inline const ::kiapi::common::types::GraphicBezierAttributes& GraphicShape::bezier() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.GraphicShape.bezier)
  return _internal_bezier();
}
inline ::kiapi::common::types::GraphicBezierAttributes* GraphicShape::unsafe_arena_release_bezier() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kiapi.common.types.GraphicShape.bezier)
  if (_internal_has_bezier()) {
    clear_has_geometry();
    ::kiapi::common::types::GraphicBezierAttributes* temp = geometry_.bezier_;
    geometry_.bezier_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GraphicShape::unsafe_arena_set_allocated_bezier(::kiapi::common::types::GraphicBezierAttributes* bezier) {
  clear_geometry();
  if (bezier) {
    set_has_bezier();
    geometry_.bezier_ = bezier;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kiapi.common.types.GraphicShape.bezier)
}
inline ::kiapi::common::types::GraphicBezierAttributes* GraphicShape::_internal_mutable_bezier() {
  if (!_internal_has_bezier()) {
    clear_geometry();
    set_has_bezier();
    geometry_.bezier_ = CreateMaybeMessage< ::kiapi::common::types::GraphicBezierAttributes >(GetArenaForAllocation());
  }
  return geometry_.bezier_;
}
inline ::kiapi::common::types::GraphicBezierAttributes* GraphicShape::mutable_bezier() {
  ::kiapi::common::types::GraphicBezierAttributes* _msg = _internal_mutable_bezier();
  // @@protoc_insertion_point(field_mutable:kiapi.common.types.GraphicShape.bezier)
  return _msg;
}

inline bool GraphicShape::has_geometry() const {
  return geometry_case() != GEOMETRY_NOT_SET;
}
inline void GraphicShape::clear_has_geometry() {
  _oneof_case_[0] = GEOMETRY_NOT_SET;
}
inline GraphicShape::GeometryCase GraphicShape::geometry_case() const {
  return GraphicShape::GeometryCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// CompoundShape

// repeated .kiapi.common.types.GraphicShape shapes = 1;
inline int CompoundShape::_internal_shapes_size() const {
  return shapes_.size();
}
inline int CompoundShape::shapes_size() const {
  return _internal_shapes_size();
}
inline void CompoundShape::clear_shapes() {
  shapes_.Clear();
}
inline ::kiapi::common::types::GraphicShape* CompoundShape::mutable_shapes(int index) {
  // @@protoc_insertion_point(field_mutable:kiapi.common.types.CompoundShape.shapes)
  return shapes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::types::GraphicShape >*
CompoundShape::mutable_shapes() {
  // @@protoc_insertion_point(field_mutable_list:kiapi.common.types.CompoundShape.shapes)
  return &shapes_;
}
inline const ::kiapi::common::types::GraphicShape& CompoundShape::_internal_shapes(int index) const {
  return shapes_.Get(index);
}
inline const ::kiapi::common::types::GraphicShape& CompoundShape::shapes(int index) const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.CompoundShape.shapes)
  return _internal_shapes(index);
}
inline ::kiapi::common::types::GraphicShape* CompoundShape::_internal_add_shapes() {
  return shapes_.Add();
}
inline ::kiapi::common::types::GraphicShape* CompoundShape::add_shapes() {
  ::kiapi::common::types::GraphicShape* _add = _internal_add_shapes();
  // @@protoc_insertion_point(field_add:kiapi.common.types.CompoundShape.shapes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kiapi::common::types::GraphicShape >&
CompoundShape::shapes() const {
  // @@protoc_insertion_point(field_list:kiapi.common.types.CompoundShape.shapes)
  return shapes_;
}

// -------------------------------------------------------------------

// TitleBlockInfo

// string title = 1;
inline void TitleBlockInfo::clear_title() {
  title_.ClearToEmpty();
}
inline const std::string& TitleBlockInfo::title() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.TitleBlockInfo.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TitleBlockInfo::set_title(ArgT0&& arg0, ArgT... args) {
 
 title_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kiapi.common.types.TitleBlockInfo.title)
}
inline std::string* TitleBlockInfo::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:kiapi.common.types.TitleBlockInfo.title)
  return _s;
}
inline const std::string& TitleBlockInfo::_internal_title() const {
  return title_.Get();
}
inline void TitleBlockInfo::_internal_set_title(const std::string& value) {
  
  title_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TitleBlockInfo::_internal_mutable_title() {
  
  return title_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TitleBlockInfo::release_title() {
  // @@protoc_insertion_point(field_release:kiapi.common.types.TitleBlockInfo.title)
  return title_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TitleBlockInfo::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    
  } else {
    
  }
  title_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), title,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (title_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    title_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.types.TitleBlockInfo.title)
}

// string date = 2;
inline void TitleBlockInfo::clear_date() {
  date_.ClearToEmpty();
}
inline const std::string& TitleBlockInfo::date() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.TitleBlockInfo.date)
  return _internal_date();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TitleBlockInfo::set_date(ArgT0&& arg0, ArgT... args) {
 
 date_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kiapi.common.types.TitleBlockInfo.date)
}
inline std::string* TitleBlockInfo::mutable_date() {
  std::string* _s = _internal_mutable_date();
  // @@protoc_insertion_point(field_mutable:kiapi.common.types.TitleBlockInfo.date)
  return _s;
}
inline const std::string& TitleBlockInfo::_internal_date() const {
  return date_.Get();
}
inline void TitleBlockInfo::_internal_set_date(const std::string& value) {
  
  date_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TitleBlockInfo::_internal_mutable_date() {
  
  return date_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TitleBlockInfo::release_date() {
  // @@protoc_insertion_point(field_release:kiapi.common.types.TitleBlockInfo.date)
  return date_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TitleBlockInfo::set_allocated_date(std::string* date) {
  if (date != nullptr) {
    
  } else {
    
  }
  date_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), date,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (date_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    date_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.types.TitleBlockInfo.date)
}

// string revision = 3;
inline void TitleBlockInfo::clear_revision() {
  revision_.ClearToEmpty();
}
inline const std::string& TitleBlockInfo::revision() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.TitleBlockInfo.revision)
  return _internal_revision();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TitleBlockInfo::set_revision(ArgT0&& arg0, ArgT... args) {
 
 revision_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kiapi.common.types.TitleBlockInfo.revision)
}
inline std::string* TitleBlockInfo::mutable_revision() {
  std::string* _s = _internal_mutable_revision();
  // @@protoc_insertion_point(field_mutable:kiapi.common.types.TitleBlockInfo.revision)
  return _s;
}
inline const std::string& TitleBlockInfo::_internal_revision() const {
  return revision_.Get();
}
inline void TitleBlockInfo::_internal_set_revision(const std::string& value) {
  
  revision_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TitleBlockInfo::_internal_mutable_revision() {
  
  return revision_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TitleBlockInfo::release_revision() {
  // @@protoc_insertion_point(field_release:kiapi.common.types.TitleBlockInfo.revision)
  return revision_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TitleBlockInfo::set_allocated_revision(std::string* revision) {
  if (revision != nullptr) {
    
  } else {
    
  }
  revision_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), revision,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (revision_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    revision_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.types.TitleBlockInfo.revision)
}

// string company = 4;
inline void TitleBlockInfo::clear_company() {
  company_.ClearToEmpty();
}
inline const std::string& TitleBlockInfo::company() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.TitleBlockInfo.company)
  return _internal_company();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TitleBlockInfo::set_company(ArgT0&& arg0, ArgT... args) {
 
 company_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kiapi.common.types.TitleBlockInfo.company)
}
inline std::string* TitleBlockInfo::mutable_company() {
  std::string* _s = _internal_mutable_company();
  // @@protoc_insertion_point(field_mutable:kiapi.common.types.TitleBlockInfo.company)
  return _s;
}
inline const std::string& TitleBlockInfo::_internal_company() const {
  return company_.Get();
}
inline void TitleBlockInfo::_internal_set_company(const std::string& value) {
  
  company_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TitleBlockInfo::_internal_mutable_company() {
  
  return company_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TitleBlockInfo::release_company() {
  // @@protoc_insertion_point(field_release:kiapi.common.types.TitleBlockInfo.company)
  return company_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TitleBlockInfo::set_allocated_company(std::string* company) {
  if (company != nullptr) {
    
  } else {
    
  }
  company_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), company,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (company_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    company_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.types.TitleBlockInfo.company)
}

// string comment1 = 5;
inline void TitleBlockInfo::clear_comment1() {
  comment1_.ClearToEmpty();
}
inline const std::string& TitleBlockInfo::comment1() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.TitleBlockInfo.comment1)
  return _internal_comment1();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TitleBlockInfo::set_comment1(ArgT0&& arg0, ArgT... args) {
 
 comment1_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kiapi.common.types.TitleBlockInfo.comment1)
}
inline std::string* TitleBlockInfo::mutable_comment1() {
  std::string* _s = _internal_mutable_comment1();
  // @@protoc_insertion_point(field_mutable:kiapi.common.types.TitleBlockInfo.comment1)
  return _s;
}
inline const std::string& TitleBlockInfo::_internal_comment1() const {
  return comment1_.Get();
}
inline void TitleBlockInfo::_internal_set_comment1(const std::string& value) {
  
  comment1_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TitleBlockInfo::_internal_mutable_comment1() {
  
  return comment1_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TitleBlockInfo::release_comment1() {
  // @@protoc_insertion_point(field_release:kiapi.common.types.TitleBlockInfo.comment1)
  return comment1_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TitleBlockInfo::set_allocated_comment1(std::string* comment1) {
  if (comment1 != nullptr) {
    
  } else {
    
  }
  comment1_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), comment1,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (comment1_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    comment1_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.types.TitleBlockInfo.comment1)
}

// string comment2 = 6;
inline void TitleBlockInfo::clear_comment2() {
  comment2_.ClearToEmpty();
}
inline const std::string& TitleBlockInfo::comment2() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.TitleBlockInfo.comment2)
  return _internal_comment2();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TitleBlockInfo::set_comment2(ArgT0&& arg0, ArgT... args) {
 
 comment2_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kiapi.common.types.TitleBlockInfo.comment2)
}
inline std::string* TitleBlockInfo::mutable_comment2() {
  std::string* _s = _internal_mutable_comment2();
  // @@protoc_insertion_point(field_mutable:kiapi.common.types.TitleBlockInfo.comment2)
  return _s;
}
inline const std::string& TitleBlockInfo::_internal_comment2() const {
  return comment2_.Get();
}
inline void TitleBlockInfo::_internal_set_comment2(const std::string& value) {
  
  comment2_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TitleBlockInfo::_internal_mutable_comment2() {
  
  return comment2_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TitleBlockInfo::release_comment2() {
  // @@protoc_insertion_point(field_release:kiapi.common.types.TitleBlockInfo.comment2)
  return comment2_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TitleBlockInfo::set_allocated_comment2(std::string* comment2) {
  if (comment2 != nullptr) {
    
  } else {
    
  }
  comment2_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), comment2,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (comment2_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    comment2_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.types.TitleBlockInfo.comment2)
}

// string comment3 = 7;
inline void TitleBlockInfo::clear_comment3() {
  comment3_.ClearToEmpty();
}
inline const std::string& TitleBlockInfo::comment3() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.TitleBlockInfo.comment3)
  return _internal_comment3();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TitleBlockInfo::set_comment3(ArgT0&& arg0, ArgT... args) {
 
 comment3_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kiapi.common.types.TitleBlockInfo.comment3)
}
inline std::string* TitleBlockInfo::mutable_comment3() {
  std::string* _s = _internal_mutable_comment3();
  // @@protoc_insertion_point(field_mutable:kiapi.common.types.TitleBlockInfo.comment3)
  return _s;
}
inline const std::string& TitleBlockInfo::_internal_comment3() const {
  return comment3_.Get();
}
inline void TitleBlockInfo::_internal_set_comment3(const std::string& value) {
  
  comment3_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TitleBlockInfo::_internal_mutable_comment3() {
  
  return comment3_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TitleBlockInfo::release_comment3() {
  // @@protoc_insertion_point(field_release:kiapi.common.types.TitleBlockInfo.comment3)
  return comment3_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TitleBlockInfo::set_allocated_comment3(std::string* comment3) {
  if (comment3 != nullptr) {
    
  } else {
    
  }
  comment3_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), comment3,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (comment3_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    comment3_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.types.TitleBlockInfo.comment3)
}

// string comment4 = 8;
inline void TitleBlockInfo::clear_comment4() {
  comment4_.ClearToEmpty();
}
inline const std::string& TitleBlockInfo::comment4() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.TitleBlockInfo.comment4)
  return _internal_comment4();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TitleBlockInfo::set_comment4(ArgT0&& arg0, ArgT... args) {
 
 comment4_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kiapi.common.types.TitleBlockInfo.comment4)
}
inline std::string* TitleBlockInfo::mutable_comment4() {
  std::string* _s = _internal_mutable_comment4();
  // @@protoc_insertion_point(field_mutable:kiapi.common.types.TitleBlockInfo.comment4)
  return _s;
}
inline const std::string& TitleBlockInfo::_internal_comment4() const {
  return comment4_.Get();
}
inline void TitleBlockInfo::_internal_set_comment4(const std::string& value) {
  
  comment4_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TitleBlockInfo::_internal_mutable_comment4() {
  
  return comment4_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TitleBlockInfo::release_comment4() {
  // @@protoc_insertion_point(field_release:kiapi.common.types.TitleBlockInfo.comment4)
  return comment4_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TitleBlockInfo::set_allocated_comment4(std::string* comment4) {
  if (comment4 != nullptr) {
    
  } else {
    
  }
  comment4_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), comment4,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (comment4_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    comment4_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.types.TitleBlockInfo.comment4)
}

// string comment5 = 9;
inline void TitleBlockInfo::clear_comment5() {
  comment5_.ClearToEmpty();
}
inline const std::string& TitleBlockInfo::comment5() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.TitleBlockInfo.comment5)
  return _internal_comment5();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TitleBlockInfo::set_comment5(ArgT0&& arg0, ArgT... args) {
 
 comment5_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kiapi.common.types.TitleBlockInfo.comment5)
}
inline std::string* TitleBlockInfo::mutable_comment5() {
  std::string* _s = _internal_mutable_comment5();
  // @@protoc_insertion_point(field_mutable:kiapi.common.types.TitleBlockInfo.comment5)
  return _s;
}
inline const std::string& TitleBlockInfo::_internal_comment5() const {
  return comment5_.Get();
}
inline void TitleBlockInfo::_internal_set_comment5(const std::string& value) {
  
  comment5_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TitleBlockInfo::_internal_mutable_comment5() {
  
  return comment5_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TitleBlockInfo::release_comment5() {
  // @@protoc_insertion_point(field_release:kiapi.common.types.TitleBlockInfo.comment5)
  return comment5_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TitleBlockInfo::set_allocated_comment5(std::string* comment5) {
  if (comment5 != nullptr) {
    
  } else {
    
  }
  comment5_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), comment5,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (comment5_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    comment5_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.types.TitleBlockInfo.comment5)
}

// string comment6 = 10;
inline void TitleBlockInfo::clear_comment6() {
  comment6_.ClearToEmpty();
}
inline const std::string& TitleBlockInfo::comment6() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.TitleBlockInfo.comment6)
  return _internal_comment6();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TitleBlockInfo::set_comment6(ArgT0&& arg0, ArgT... args) {
 
 comment6_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kiapi.common.types.TitleBlockInfo.comment6)
}
inline std::string* TitleBlockInfo::mutable_comment6() {
  std::string* _s = _internal_mutable_comment6();
  // @@protoc_insertion_point(field_mutable:kiapi.common.types.TitleBlockInfo.comment6)
  return _s;
}
inline const std::string& TitleBlockInfo::_internal_comment6() const {
  return comment6_.Get();
}
inline void TitleBlockInfo::_internal_set_comment6(const std::string& value) {
  
  comment6_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TitleBlockInfo::_internal_mutable_comment6() {
  
  return comment6_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TitleBlockInfo::release_comment6() {
  // @@protoc_insertion_point(field_release:kiapi.common.types.TitleBlockInfo.comment6)
  return comment6_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TitleBlockInfo::set_allocated_comment6(std::string* comment6) {
  if (comment6 != nullptr) {
    
  } else {
    
  }
  comment6_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), comment6,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (comment6_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    comment6_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.types.TitleBlockInfo.comment6)
}

// string comment7 = 11;
inline void TitleBlockInfo::clear_comment7() {
  comment7_.ClearToEmpty();
}
inline const std::string& TitleBlockInfo::comment7() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.TitleBlockInfo.comment7)
  return _internal_comment7();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TitleBlockInfo::set_comment7(ArgT0&& arg0, ArgT... args) {
 
 comment7_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kiapi.common.types.TitleBlockInfo.comment7)
}
inline std::string* TitleBlockInfo::mutable_comment7() {
  std::string* _s = _internal_mutable_comment7();
  // @@protoc_insertion_point(field_mutable:kiapi.common.types.TitleBlockInfo.comment7)
  return _s;
}
inline const std::string& TitleBlockInfo::_internal_comment7() const {
  return comment7_.Get();
}
inline void TitleBlockInfo::_internal_set_comment7(const std::string& value) {
  
  comment7_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TitleBlockInfo::_internal_mutable_comment7() {
  
  return comment7_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TitleBlockInfo::release_comment7() {
  // @@protoc_insertion_point(field_release:kiapi.common.types.TitleBlockInfo.comment7)
  return comment7_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TitleBlockInfo::set_allocated_comment7(std::string* comment7) {
  if (comment7 != nullptr) {
    
  } else {
    
  }
  comment7_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), comment7,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (comment7_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    comment7_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.types.TitleBlockInfo.comment7)
}

// string comment8 = 12;
inline void TitleBlockInfo::clear_comment8() {
  comment8_.ClearToEmpty();
}
inline const std::string& TitleBlockInfo::comment8() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.TitleBlockInfo.comment8)
  return _internal_comment8();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TitleBlockInfo::set_comment8(ArgT0&& arg0, ArgT... args) {
 
 comment8_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kiapi.common.types.TitleBlockInfo.comment8)
}
inline std::string* TitleBlockInfo::mutable_comment8() {
  std::string* _s = _internal_mutable_comment8();
  // @@protoc_insertion_point(field_mutable:kiapi.common.types.TitleBlockInfo.comment8)
  return _s;
}
inline const std::string& TitleBlockInfo::_internal_comment8() const {
  return comment8_.Get();
}
inline void TitleBlockInfo::_internal_set_comment8(const std::string& value) {
  
  comment8_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TitleBlockInfo::_internal_mutable_comment8() {
  
  return comment8_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TitleBlockInfo::release_comment8() {
  // @@protoc_insertion_point(field_release:kiapi.common.types.TitleBlockInfo.comment8)
  return comment8_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TitleBlockInfo::set_allocated_comment8(std::string* comment8) {
  if (comment8 != nullptr) {
    
  } else {
    
  }
  comment8_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), comment8,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (comment8_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    comment8_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.types.TitleBlockInfo.comment8)
}

// string comment9 = 13;
inline void TitleBlockInfo::clear_comment9() {
  comment9_.ClearToEmpty();
}
inline const std::string& TitleBlockInfo::comment9() const {
  // @@protoc_insertion_point(field_get:kiapi.common.types.TitleBlockInfo.comment9)
  return _internal_comment9();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TitleBlockInfo::set_comment9(ArgT0&& arg0, ArgT... args) {
 
 comment9_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kiapi.common.types.TitleBlockInfo.comment9)
}
inline std::string* TitleBlockInfo::mutable_comment9() {
  std::string* _s = _internal_mutable_comment9();
  // @@protoc_insertion_point(field_mutable:kiapi.common.types.TitleBlockInfo.comment9)
  return _s;
}
inline const std::string& TitleBlockInfo::_internal_comment9() const {
  return comment9_.Get();
}
inline void TitleBlockInfo::_internal_set_comment9(const std::string& value) {
  
  comment9_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TitleBlockInfo::_internal_mutable_comment9() {
  
  return comment9_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TitleBlockInfo::release_comment9() {
  // @@protoc_insertion_point(field_release:kiapi.common.types.TitleBlockInfo.comment9)
  return comment9_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TitleBlockInfo::set_allocated_comment9(std::string* comment9) {
  if (comment9 != nullptr) {
    
  } else {
    
  }
  comment9_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), comment9,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (comment9_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    comment9_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kiapi.common.types.TitleBlockInfo.comment9)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace types
}  // namespace common
}  // namespace kiapi

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::kiapi::common::types::CommandStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::kiapi::common::types::CommandStatus>() {
  return ::kiapi::common::types::CommandStatus_descriptor();
}
template <> struct is_proto_enum< ::kiapi::common::types::FrameType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::kiapi::common::types::FrameType>() {
  return ::kiapi::common::types::FrameType_descriptor();
}
template <> struct is_proto_enum< ::kiapi::common::types::DocumentType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::kiapi::common::types::DocumentType>() {
  return ::kiapi::common::types::DocumentType_descriptor();
}
template <> struct is_proto_enum< ::kiapi::common::types::ItemRequestStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::kiapi::common::types::ItemRequestStatus>() {
  return ::kiapi::common::types::ItemRequestStatus_descriptor();
}
template <> struct is_proto_enum< ::kiapi::common::types::LockedState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::kiapi::common::types::LockedState>() {
  return ::kiapi::common::types::LockedState_descriptor();
}
template <> struct is_proto_enum< ::kiapi::common::types::GraphicFillType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::kiapi::common::types::GraphicFillType>() {
  return ::kiapi::common::types::GraphicFillType_descriptor();
}
template <> struct is_proto_enum< ::kiapi::common::types::AxisAlignment> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::kiapi::common::types::AxisAlignment>() {
  return ::kiapi::common::types::AxisAlignment_descriptor();
}
template <> struct is_proto_enum< ::kiapi::common::types::MapMergeMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::kiapi::common::types::MapMergeMode>() {
  return ::kiapi::common::types::MapMergeMode_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_common_2ftypes_2fbase_5ftypes_2eproto

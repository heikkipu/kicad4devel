
/* Do not modify this file it was automatically generated by the
 * TokenList2DsnLexer CMake script.
 */

#ifndef SCHEMATIC_LEXER_H_
#define SCHEMATIC_LEXER_H_

#include <dsnlexer.h>

/**
 * C++ does not put enum _values_ in separate namespaces unless the enum itself
 * is in a separate namespace.  All the token enums must be in separate namespaces
 * otherwise the C++ compiler will eventually complain if it sees more than one
 * DSNLEXER in the same compilation unit, say by multiple header file inclusion.
 * Plus this also enables re-use of the same enum name T.  A typedef can always be used
 * to clarify which enum T is in play should that ever be a problem.  This is
 * unlikely since Parse() functions will usually only be exposed to one header
 * file like this one.  But if there is a problem, then use:
 *   typedef TSCHEMATIC_T::T T;
 * within that problem area.
 */
namespace TSCHEMATIC_T
{
    /// enum T contains all this lexer's tokens.
    enum T
    {
        // these first few are negative special ones for syntax, and are
        // inherited from DSNLEXER.
        T_NONE          = DSN_NONE,
        T_BAR           = DSN_BAR,          // Also called pipe: '|'
        T_COMMENT       = DSN_COMMENT,
        T_STRING_QUOTE  = DSN_STRING_QUOTE,
        T_QUOTE_DEF     = DSN_QUOTE_DEF,
        T_DASH          = DSN_DASH,
        T_SYMBOL        = DSN_SYMBOL,
        T_NUMBER        = DSN_NUMBER,
        T_RIGHT         = DSN_RIGHT,        // right bracket: ')'
        T_LEFT          = DSN_LEFT,         // left bracket:  '('
        T_STRING        = DSN_STRING,       // a quoted string, stripped of the quotes
        T_EOF           = DSN_EOF,          // special case for end of file

        T_alternate = 0,
        T_anchor,
        T_angles,
        T_arc,
        T_at,
        T_atomic,
        T_background,
        T_bezier,
        T_bidirectional,
        T_bitmap,
        T_bold,
        T_border,
        T_bottom,
        T_bus,
        T_bus_alias,
        T_bus_entry,
        T_cells,
        T_center,
        T_checksum,
        T_circle,
        T_clock,
        T_clock_low,
        T_color,
        T_cols,
        T_column_count,
        T_column_widths,
        T_comment,
        T_company,
        T_convert,
        T_cross_hatch,
        T_data,
        T_date,
        T_default,
        T_default_instance,
        T_diameter,
        T_diamond,
        T_directive_label,
        T_dnp,
        T_do_not_autoplace,
        T_dot,
        T_duplicate_pin_numbers_are_jumpers,
        T_edge_clock_high,
        T_effects,
        T_embedded_files,
        T_embedded_fonts,
        T_end,
        T_exclude_from_sim,
        T_extends,
        T_external,
        T_face,
        T_fields_autoplaced,
        T_file,
        T_fill,
        T_font,
        T_footprint,
        T_free,
        T_generator,
        T_generator_version,
        T_global,
        T_global_label,
        T_hatch,
        T_header,
        T_hide,
        T_hierarchical_label,
        T_hint_alt_swap,
        T_hint_pin_swap,
        T_host,
        T_href,
        T_id,
        T_image,
        T_in_bom,
        T_input,
        T_input_low,
        T_instances,
        T_inverted,
        T_inverted_clock,
        T_iref,
        T_italic,
        T_jumper_pin_groups,
        T_junction,
        T_justify,
        T_kicad_sch,
        T_kicad_symbol_lib,
        T_label,
        T_left,
        T_length,
        T_lib_id,
        T_lib_name,
        T_lib_symbols,
        T_line,
        T_line_spacing,
        T_local,
        T_margins,
        T_members,
        T_mid,
        T_mirror,
        T_name,
        T_netclass_flag,
        T_no,
        T_no_connect,
        T_non_logic,
        T_none,
        T_number,
        T_offset,
        T_on_board,
        T_open_collector,
        T_open_emitter,
        T_outline,
        T_output,
        T_output_low,
        T_page,
        T_paper,
        T_passive,
        T_path,
        T_pin,
        T_pin_del,
        T_pin_merge,
        T_pin_names,
        T_pin_numbers,
        T_pin_rename,
        T_polyline,
        T_portrait,
        T_power,
        T_power_in,
        T_power_out,
        T_private,
        T_project,
        T_property,
        T_property_del,
        T_pts,
        T_radius,
        T_rectangle,
        T_reference,
        T_required,
        T_rev,
        T_reverse_hatch,
        T_right,
        T_round,
        T_row_heights,
        T_rows,
        T_rule_area,
        T_scale,
        T_separators,
        T_shape,
        T_sheet,
        T_sheet_instances,
        T_show_name,
        T_size,
        T_span,
        T_start,
        T_stroke,
        T_symbol,
        T_symbol_instances,
        T_table,
        T_table_cell,
        T_text,
        T_text_box,
        T_thickness,
        T_title,
        T_title_block,
        T_top,
        T_tri_state,
        T_type,
        T_unconnected,
        T_unit,
        T_unit_name,
        T_unspecified,
        T_uuid,
        T_value,
        T_version,
        T_width,
        T_wire,
        T_x,
        T_xy,
        T_y,
        T_yes
    };
}   // namespace TSCHEMATIC_T


/**
 * Class SCHEMATIC_LEXER
 * is an automatically generated class using the TokenList2DnsLexer.cmake
 * technology, based on keywords provided by file:
 *    /opt/kicad/program/master/Tears_Master/eeschema/schematic.keywords
 */
class SCHEMATIC_LEXER : public DSNLEXER
{
    /// Auto generated lexer keywords table and length:
    static const KEYWORD  keywords[];
    static const KEYWORD_MAP keywords_hash;
    static const unsigned keyword_count;

public:
    /**
     * Constructor ( const std::string&, const wxString& )
     * @param aSExpression is (utf8) text possibly from the clipboard that you want to parse.
     * @param aSource is a description of the origin of @a aSExpression, such as a filename.
     *   If left empty, then _("clipboard") is used.
     */
    SCHEMATIC_LEXER( const std::string& aSExpression, const wxString& aSource = wxEmptyString ) :
        DSNLEXER( keywords, keyword_count, &keywords_hash, aSExpression, aSource )
    {
    }

    /**
     * Constructor ( FILE* )
     * takes @a aFile already opened for reading and @a aFilename as parameters.
     * The opened file is assumed to be positioned at the beginning of the file
     * for purposes of accurate line number reporting in error messages.  The
     * FILE is closed by this instance when its destructor is called.
     * @param aFile is a FILE already opened for reading.
     * @param aFilename is the name of the opened file, needed for error reporting.
     */
    SCHEMATIC_LEXER( FILE* aFile, const wxString& aFilename ) :
        DSNLEXER( keywords, keyword_count, &keywords_hash, aFile, aFilename )
    {
    }

    /**
     * Constructor ( LINE_READER* )
     * initializes a lexer and prepares to read from @a aLineReader which
     * is assumed ready, and may be in use by other DSNLEXERs also.  No ownership
     * is taken of @a aLineReader. This enables it to be used by other lexers also.
     * The transition between grammars in such a case, must happen on a text
     * line boundary, not within the same line of text.
     *
     * @param aLineReader is any subclassed instance of LINE_READER, such as
     *  STRING_LINE_READER or FILE_LINE_READER.  No ownership is taken of aLineReader.
     */
    SCHEMATIC_LEXER( LINE_READER* aLineReader ) :
        DSNLEXER( keywords, keyword_count, &keywords_hash, aLineReader )
    {
    }

    /**
     * Function TokenName
     * returns the name of the token in ASCII form.
     */
    static const char* TokenName( TSCHEMATIC_T::T aTok );

    /**
     * Function NextTok
     * returns the next token found in the input file or T_EOF when reaching
     * the end of file.  Users should wrap this function to return an enum
     * to aid in grammar debugging while running under a debugger, but leave
     * this lower level function returning an int (so the enum does not collide
     * with another usage).
     * @return TSCHEMATIC_T::T - the type of token found next.
     * @throw IO_ERROR - only if the LINE_READER throws it.
     */
    TSCHEMATIC_T::T NextTok()
    {
        return (TSCHEMATIC_T::T) DSNLEXER::NextTok();
    }

    /**
     * Function NeedSYMBOL
     * calls NextTok() and then verifies that the token read in
     * satisfies bool IsSymbol().
     * If not, an IO_ERROR is thrown.
     * @return int - the actual token read in.
     * @throw IO_ERROR, if the next token does not satisfy IsSymbol()
     */
    TSCHEMATIC_T::T NeedSYMBOL()
    {
        return (TSCHEMATIC_T::T) DSNLEXER::NeedSYMBOL();
    }

    /**
     * Function NeedSYMBOLorNUMBER
     * calls NextTok() and then verifies that the token read in
     * satisfies bool IsSymbol() or tok==T_NUMBER.
     * If not, an IO_ERROR is thrown.
     * @return int - the actual token read in.
     * @throw IO_ERROR, if the next token does not satisfy the above test
     */
    TSCHEMATIC_T::T NeedSYMBOLorNUMBER()
    {
        return (TSCHEMATIC_T::T) DSNLEXER::NeedSYMBOLorNUMBER();
    }

    /**
     * Function CurTok
     * returns whatever NextTok() returned the last time it was called.
     */
    TSCHEMATIC_T::T CurTok()
    {
        return (TSCHEMATIC_T::T) DSNLEXER::CurTok();
    }

    /**
     * Function PrevTok
     * returns whatever NextTok() returned the 2nd to last time it was called.
     */
    TSCHEMATIC_T::T PrevTok()
    {
        return (TSCHEMATIC_T::T) DSNLEXER::PrevTok();
    }

    /**
     * Function GetCurStrAsToken
     * Used to support 'loose' matches (quoted tokens)
     */
    TSCHEMATIC_T::T GetCurStrAsToken()
    {
        return (TSCHEMATIC_T::T) DSNLEXER::GetCurStrAsToken();
    }
};

// example usage

/**
 * Class _PARSER
 * holds data and functions pertinent to parsing a S-expression file .
 *
class SCHEMATIC_PARSER : public SCHEMATIC_LEXER
{

};
*/

#endif   // SCHEMATIC_LEXER_H_
